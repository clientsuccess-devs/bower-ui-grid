/*!
 * ClientSuccess/ui-grid - v4.0.2-2 - 2017-02-21
 * Copyright (c) 2017 ; License: MIT
 */

!(function () {
  "use strict";
  angular.module("ui.grid.i18n", []),
    angular.module("ui.grid", ["ui.grid.i18n"]);
})(),
  (function () {
    "use strict";
    angular.module("ui.grid").constant("uiGridConstants", {
      LOG_DEBUG_MESSAGES: !0,
      LOG_WARN_MESSAGES: !0,
      LOG_ERROR_MESSAGES: !0,
      CUSTOM_FILTERS: /CUSTOM_FILTERS/g,
      COL_FIELD: /COL_FIELD/g,
      MODEL_COL_FIELD: /MODEL_COL_FIELD/g,
      TOOLTIP: /title=\"TOOLTIP\"/g,
      DISPLAY_CELL_TEMPLATE: /DISPLAY_CELL_TEMPLATE/g,
      TEMPLATE_REGEXP: /<.+>/,
      FUNC_REGEXP: /(\([^)]*\))?$/,
      DOT_REGEXP: /\./g,
      APOS_REGEXP: /'/g,
      BRACKET_REGEXP: /^(.*)((?:\s*\[\s*\d+\s*\]\s*)|(?:\s*\[\s*"(?:[^"\\]|\\.)*"\s*\]\s*)|(?:\s*\[\s*'(?:[^'\\]|\\.)*'\s*\]\s*))(.*)$/,
      COL_CLASS_PREFIX: "ui-grid-col",
      ENTITY_BINDING: "$$this",
      events: {
        GRID_SCROLL: "uiGridScroll",
        COLUMN_MENU_SHOWN: "uiGridColMenuShown",
        ITEM_DRAGGING: "uiGridItemDragStart",
        COLUMN_HEADER_CLICK: "uiGridColumnHeaderClick",
      },
      keymap: {
        TAB: 9,
        STRG: 17,
        CAPSLOCK: 20,
        CTRL: 17,
        CTRLRIGHT: 18,
        CTRLR: 18,
        SHIFT: 16,
        RETURN: 13,
        ENTER: 13,
        BACKSPACE: 8,
        BCKSP: 8,
        ALT: 18,
        ALTR: 17,
        ALTRIGHT: 17,
        SPACE: 32,
        WIN: 91,
        MAC: 91,
        FN: null,
        PG_UP: 33,
        PG_DOWN: 34,
        UP: 38,
        DOWN: 40,
        LEFT: 37,
        RIGHT: 39,
        ESC: 27,
        DEL: 46,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
      },
      ASC: "asc",
      DESC: "desc",
      filter: {
        STARTS_WITH: 2,
        ENDS_WITH: 4,
        EXACT: 8,
        CONTAINS: 16,
        GREATER_THAN: 32,
        GREATER_THAN_OR_EQUAL: 64,
        LESS_THAN: 128,
        LESS_THAN_OR_EQUAL: 256,
        NOT_EQUAL: 512,
        SELECT: "select",
        INPUT: "input",
      },
      aggregationTypes: { sum: 2, count: 4, avg: 8, min: 16, max: 32 },
      CURRENCY_SYMBOLS: [
        "¤",
        "؋",
        "Ar",
        "Ƀ",
        "฿",
        "B/.",
        "Br",
        "Bs.",
        "Bs.F.",
        "GH₵",
        "¢",
        "c",
        "Ch.",
        "₡",
        "C$",
        "D",
        "ден",
        "دج",
        ".د.ب",
        "د.ع",
        "JD",
        "د.ك",
        "ل.د",
        "дин",
        "د.ت",
        "د.م.",
        "د.إ",
        "Db",
        "$",
        "₫",
        "Esc",
        "€",
        "ƒ",
        "Ft",
        "FBu",
        "FCFA",
        "CFA",
        "Fr",
        "FRw",
        "G",
        "gr",
        "₲",
        "h",
        "₴",
        "₭",
        "Kč",
        "kr",
        "kn",
        "MK",
        "ZK",
        "Kz",
        "K",
        "L",
        "Le",
        "лв",
        "E",
        "lp",
        "M",
        "KM",
        "MT",
        "₥",
        "Nfk",
        "₦",
        "Nu.",
        "UM",
        "T$",
        "MOP$",
        "₱",
        "Pt.",
        "£",
        "ج.م.",
        "LL",
        "LS",
        "P",
        "Q",
        "q",
        "R",
        "R$",
        "ر.ع.",
        "ر.ق",
        "ر.س",
        "៛",
        "RM",
        "p",
        "Rf.",
        "₹",
        "₨",
        "SRe",
        "Rp",
        "₪",
        "Ksh",
        "Sh.So.",
        "USh",
        "S/",
        "SDR",
        "сом",
        "৳\t",
        "WS$",
        "₮",
        "VT",
        "₩",
        "¥",
        "zł",
      ],
      scrollDirection: {
        UP: "up",
        DOWN: "down",
        LEFT: "left",
        RIGHT: "right",
        NONE: "none",
      },
      dataChange: {
        ALL: "all",
        EDIT: "edit",
        ROW: "row",
        COLUMN: "column",
        OPTIONS: "options",
      },
      scrollbars: { NEVER: 0, ALWAYS: 1 },
    });
  })(),
  angular.module("ui.grid").directive("uiGridCell", [
    "$compile",
    "$parse",
    "gridUtil",
    "uiGridConstants",
    function (a, b, c, d) {
      var e = {
        priority: 0,
        scope: !1,
        require: "?^uiGrid",
        compile: function () {
          return {
            pre: function (b, e, f, g) {
              function h() {
                var a = b.col.compiledElementFn;
                a(b, function (a, b) {
                  e.append(a);
                });
              }
              if (g && b.col.compiledElementFn) h();
              else if (g && !b.col.compiledElementFn)
                b.col.getCompiledElementFn().then(function (a) {
                  a(b, function (a, b) {
                    e.append(a);
                  });
                });
              else {
                var i = b.col.cellTemplate
                    .replace(
                      d.MODEL_COL_FIELD,
                      "row.entity." + c.preEval(b.col.field)
                    )
                    .replace(d.COL_FIELD, "grid.getCellValue(row, col)"),
                  j = a(i)(b);
                e.append(j);
              }
            },
            post: function (a, b, c, e) {
              var f = a.col.getColClass(!1);
              b.addClass(f);
              var g,
                h = function (c) {
                  var d = b;
                  g && (d.removeClass(g), (g = null)),
                    (g = angular.isFunction(a.col.cellClass)
                      ? a.col.cellClass(
                          a.grid,
                          a.row,
                          a.col,
                          a.rowRenderIndex,
                          a.colRenderIndex
                        )
                      : a.col.cellClass),
                    d.addClass(g);
                };
              a.col.cellClass && h();
              var i = a.grid.registerDataChangeCallback(h, [
                  d.dataChange.COLUMN,
                  d.dataChange.EDIT,
                ]),
                j = function (c, d) {
                  if (c !== d) {
                    (g || a.col.cellClass) && h();
                    var e = a.col.getColClass(!1);
                    e !== f && (b.removeClass(f), b.addClass(e), (f = e));
                  }
                },
                k = a.$watch("row", j),
                l = function () {
                  i(), k();
                };
              a.$on("$destroy", l), b.on("$destroy", l);
            },
          };
        },
      };
      return e;
    },
  ]),
  (function () {
    angular
      .module("ui.grid")
      .service("uiGridColumnMenuService", [
        "i18nService",
        "uiGridConstants",
        "gridUtil",
        function (a, b, c) {
          var d = {
            initialize: function (a, b) {
              (a.grid = b.grid), (b.columnMenuScope = a), (a.menuShown = !1);
            },
            setColMenuItemWatch: function (a) {
              var b = a.$watch("col.menuItems", function (b) {
                "undefined" != typeof b && b && angular.isArray(b)
                  ? (b.forEach(function (b) {
                      ("undefined" != typeof b.context && b.context) ||
                        (b.context = {}),
                        (b.context.col = a.col);
                    }),
                    (a.menuItems = a.defaultMenuItems.concat(b)))
                  : (a.menuItems = a.defaultMenuItems);
              });
              a.$on("$destroy", b);
            },
            sortable: function (a) {
              return !!(
                a.grid.options.enableSorting &&
                "undefined" != typeof a.col &&
                a.col &&
                a.col.enableSorting
              );
            },
            isActiveSort: function (a, b) {
              return (
                "undefined" != typeof a.col &&
                "undefined" != typeof a.col.sort &&
                "undefined" != typeof a.col.sort.direction &&
                a.col.sort.direction === b
              );
            },
            suppressRemoveSort: function (a) {
              return !(!a.col || !a.col.suppressRemoveSort);
            },
            hideable: function (a) {
              return (
                "undefined" == typeof a.col ||
                !a.col ||
                !a.col.colDef ||
                a.col.colDef.enableHiding !== !1
              );
            },
            getDefaultMenuItems: function (c) {
              return [
                {
                  title: a.getSafeText("sort.ascending"),
                  icon: "ui-grid-icon-sort-alt-up",
                  action: function (a) {
                    a.stopPropagation(), c.sortColumn(a, b.ASC);
                  },
                  shown: function () {
                    return d.sortable(c);
                  },
                  active: function () {
                    return d.isActiveSort(c, b.ASC);
                  },
                },
                {
                  title: a.getSafeText("sort.descending"),
                  icon: "ui-grid-icon-sort-alt-down",
                  action: function (a) {
                    a.stopPropagation(), c.sortColumn(a, b.DESC);
                  },
                  shown: function () {
                    return d.sortable(c);
                  },
                  active: function () {
                    return d.isActiveSort(c, b.DESC);
                  },
                },
                {
                  title: a.getSafeText("sort.remove"),
                  icon: "ui-grid-icon-cancel",
                  action: function (a) {
                    a.stopPropagation(), c.unsortColumn();
                  },
                  shown: function () {
                    return (
                      d.sortable(c) &&
                      "undefined" != typeof c.col &&
                      "undefined" != typeof c.col.sort &&
                      "undefined" != typeof c.col.sort.direction &&
                      null !== c.col.sort.direction &&
                      !d.suppressRemoveSort(c)
                    );
                  },
                },
                {
                  title: a.getSafeText("column.hide"),
                  icon: "ui-grid-icon-cancel",
                  shown: function () {
                    return d.hideable(c);
                  },
                  action: function (a) {
                    a.stopPropagation(), c.hideColumn();
                  },
                },
              ];
            },
            getColumnElementPosition: function (a, b, d) {
              var e = {};
              return (
                (e.left = d[0].offsetLeft),
                (e.top = d[0].offsetTop),
                (e.parentLeft = d[0].offsetParent.offsetLeft),
                (e.offset = 0),
                b.grid.options.offsetLeft &&
                  (e.offset = b.grid.options.offsetLeft),
                (e.height = c.elementHeight(d, !0)),
                (e.width = c.elementWidth(d, !0)),
                e
              );
            },
            repositionMenu: function (a, b, d, e, f) {
              var g = e[0].querySelectorAll(".ui-grid-menu"),
                h = c.closestElm(f, ".ui-grid-render-container"),
                i =
                  h.getBoundingClientRect().left -
                  a.grid.element[0].getBoundingClientRect().left,
                j = h.querySelectorAll(".ui-grid-viewport")[0].scrollLeft,
                k = b.lastMenuWidth
                  ? b.lastMenuWidth
                  : a.lastMenuWidth
                  ? a.lastMenuWidth
                  : 170,
                l = b.lastMenuPaddingRight
                  ? b.lastMenuPaddingRight
                  : a.lastMenuPaddingRight
                  ? a.lastMenuPaddingRight
                  : 10;
              if (0 !== g.length) {
                var m = g[0].querySelectorAll(".ui-grid-menu-mid");
                0 === m.length ||
                  angular.element(m).hasClass("ng-hide") ||
                  ((k = c.elementWidth(g, !0)),
                  (a.lastMenuWidth = k),
                  (b.lastMenuWidth = k),
                  (l = parseInt(
                    c.getStyles(angular.element(g)[0]).paddingRight,
                    10
                  )),
                  (a.lastMenuPaddingRight = l),
                  (b.lastMenuPaddingRight = l));
              }
              var n = d.left + i - j + d.parentLeft + d.width - k + l;
              n < d.offset && (n = d.offset),
                e.css("left", n + "px"),
                e.css("top", d.top + d.height + "px");
            },
          };
          return d;
        },
      ])
      .directive("uiGridColumnMenu", [
        "$timeout",
        "gridUtil",
        "uiGridConstants",
        "uiGridColumnMenuService",
        "$document",
        function (a, b, c, d, e) {
          var f = {
            priority: 0,
            scope: !0,
            require: "^uiGrid",
            templateUrl: "ui-grid/uiGridColumnMenu",
            replace: !0,
            link: function (f, g, h, i) {
              d.initialize(f, i),
                (f.defaultMenuItems = d.getDefaultMenuItems(f)),
                (f.menuItems = f.defaultMenuItems),
                d.setColMenuItemWatch(f),
                (f.showMenu = function (a, b, c) {
                  f.col = a;
                  var e = d.getColumnElementPosition(f, a, b);
                  f.menuShown
                    ? ((f.colElement = b),
                      (f.colElementPosition = e),
                      (f.hideThenShow = !0),
                      f.$broadcast("hide-menu", { originalEvent: c }))
                    : ((f.menuShown = !0),
                      d.repositionMenu(f, a, e, g, b),
                      (f.colElement = b),
                      (f.colElementPosition = e),
                      f.$broadcast("show-menu", { originalEvent: c }));
                }),
                (f.hideMenu = function (a) {
                  (f.menuShown = !1), a || f.$broadcast("hide-menu");
                }),
                f.$on("menu-hidden", function () {
                  f.hideThenShow
                    ? (delete f.hideThenShow,
                      d.repositionMenu(
                        f,
                        f.col,
                        f.colElementPosition,
                        g,
                        f.colElement
                      ),
                      f.$broadcast("show-menu"),
                      (f.menuShown = !0))
                    : (f.hideMenu(!0),
                      f.col &&
                        b.focus.bySelector(
                          e,
                          ".ui-grid-header-cell." +
                            f.col.getColClass() +
                            " .ui-grid-column-menu-button",
                          f.col.grid,
                          !1
                        ));
                }),
                f.$on("menu-shown", function () {
                  a(function () {
                    d.repositionMenu(
                      f,
                      f.col,
                      f.colElementPosition,
                      g,
                      f.colElement
                    ),
                      b.focus.bySelector(
                        e,
                        ".ui-grid-menu-items .ui-grid-menu-item",
                        !0
                      ),
                      delete f.colElementPosition,
                      delete f.columnElement;
                  }, 200);
                }),
                (f.sortColumn = function (a, b) {
                  a.stopPropagation(),
                    f.grid.sortColumn(f.col, b, !0).then(function () {
                      f.grid.refresh(), f.hideMenu();
                    });
                }),
                (f.unsortColumn = function () {
                  f.col.unsort(), f.grid.refresh(), f.hideMenu();
                });
              var j = function () {
                a(function () {
                  var c,
                    a = function () {
                      return b.focus.byId("grid-menu", f.grid);
                    };
                  f.grid.columns.some(function (a, b) {
                    if (angular.equals(a, f.col)) return (c = b), !0;
                  });
                  var d;
                  if (
                    (f.grid.columns.some(function (a, b) {
                      if (!a.visible) return !1;
                      if (b < c) d = a;
                      else {
                        if (b > c && !d) return (d = a), !0;
                        if (b > c && d) return !0;
                      }
                    }),
                    d)
                  ) {
                    var g = d.getColClass();
                    b.focus
                      .bySelector(
                        e,
                        ".ui-grid-header-cell." +
                          g +
                          " .ui-grid-header-cell-primary-focus",
                        !0
                      )
                      .then(angular.noop, function (b) {
                        if ("canceled" !== b) return a();
                      });
                  } else a();
                });
              };
              f.hideColumn = function () {
                (f.col.colDef.visible = !1),
                  (f.col.visible = !1),
                  f.grid.queueGridRefresh(),
                  f.hideMenu(),
                  f.grid.api.core.notifyDataChange(c.dataChange.COLUMN),
                  f.grid.api.core.raise.columnVisibilityChanged(f.col),
                  j();
              };
            },
            controller: [
              "$scope",
              function (a) {
                var b = this;
                a.$watch("menuItems", function (a) {
                  b.menuItems = a;
                });
              },
            ],
          };
          return f;
        },
      ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridFilter", [
      "$compile",
      "$templateCache",
      "i18nService",
      "gridUtil",
      function (a, b, c, d) {
        return {
          compile: function () {
            return {
              pre: function (b, c, d, e) {
                (b.col.updateFilters = function (d) {
                  if ((c.children().remove(), d)) {
                    var e = b.col.filterHeaderTemplate;
                    c.append(a(e)(b));
                  }
                }),
                  b.$on("$destroy", function () {
                    delete b.col.updateFilters;
                  });
              },
              post: function (a, b, e, f) {
                (a.aria = c.getSafeText("headerCell.aria")),
                  (a.removeFilter = function (a, c) {
                    (a.term = null),
                      d.focus.bySelector(b, ".ui-grid-filter-input-" + c);
                  });
              },
            };
          },
        };
      },
    ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooterCell", [
      "$timeout",
      "gridUtil",
      "uiGridConstants",
      "$compile",
      function (a, b, c, d) {
        var e = {
          priority: 0,
          scope: { col: "=", row: "=", renderIndex: "=" },
          replace: !0,
          require: "^uiGrid",
          compile: function (b, e, f) {
            return {
              pre: function (a, b, c, e) {
                var f = d(a.col.footerCellTemplate)(a);
                b.append(f);
              },
              post: function (a, b, d, e) {
                a.grid = e.grid;
                var f = a.col.getColClass(!1);
                b.addClass(f);
                var g,
                  h = function (c) {
                    var d = b;
                    g && (d.removeClass(g), (g = null)),
                      (g = angular.isFunction(a.col.footerCellClass)
                        ? a.col.footerCellClass(
                            a.grid,
                            a.row,
                            a.col,
                            a.rowRenderIndex,
                            a.colRenderIndex
                          )
                        : a.col.footerCellClass),
                      d.addClass(g);
                  };
                a.col.footerCellClass && h(), a.col.updateAggregationValue();
                var i = a.grid.registerDataChangeCallback(h, [
                  c.dataChange.COLUMN,
                ]);
                a.grid.api.core.on.rowsRendered(
                  a,
                  a.col.updateAggregationValue
                ),
                  a.grid.api.core.on.rowsRendered(a, h),
                  a.$on("$destroy", i);
              },
            };
          },
        };
        return e;
      },
    ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridFooter", [
      "$templateCache",
      "$compile",
      "uiGridConstants",
      "gridUtil",
      "$timeout",
      function (a, b, c, d, e) {
        return {
          restrict: "EA",
          replace: !0,
          require: ["^uiGrid", "^uiGridRenderContainer"],
          scope: !0,
          compile: function (a, c) {
            return {
              pre: function (a, c, e, f) {
                var g = f[0],
                  h = f[1];
                (a.grid = g.grid),
                  (a.colContainer = h.colContainer),
                  (h.footer = c);
                var i = a.grid.options.footerTemplate;
                d.getTemplate(i).then(function (d) {
                  var e = angular.element(d),
                    f = b(e)(a);
                  if ((c.append(f), h)) {
                    var g = c[0].getElementsByClassName(
                      "ui-grid-footer-viewport"
                    )[0];
                    g && (h.footerViewport = g);
                  }
                });
              },
              post: function (a, b, c, e) {
                var f = e[0],
                  g = e[1];
                f.grid;
                d.disableAnimations(b), (g.footer = b);
                var i = b[0].getElementsByClassName(
                  "ui-grid-footer-viewport"
                )[0];
                i && (g.footerViewport = i);
              },
            };
          },
        };
      },
    ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridGridFooter", [
      "$templateCache",
      "$compile",
      "uiGridConstants",
      "gridUtil",
      "$timeout",
      function (a, b, c, d, e) {
        return {
          restrict: "EA",
          replace: !0,
          require: "^uiGrid",
          scope: !0,
          compile: function (a, c) {
            return {
              pre: function (a, c, e, f) {
                a.grid = f.grid;
                var g = a.grid.options.gridFooterTemplate;
                d.getTemplate(g).then(function (d) {
                  var e = angular.element(d),
                    f = b(e)(a);
                  c.append(f);
                });
              },
              post: function (a, b, c, d) {},
            };
          },
        };
      },
    ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridGroupPanel", [
      "$compile",
      "uiGridConstants",
      "gridUtil",
      function (a, b, c) {
        var d = "ui-grid/ui-grid-group-panel";
        return {
          restrict: "EA",
          replace: !0,
          require: "?^uiGrid",
          scope: !1,
          compile: function (b, e) {
            return {
              pre: function (b, e, f, g) {
                var h = b.grid.options.groupPanelTemplate || d;
                c.getTemplate(h).then(function (c) {
                  var d = angular.element(c),
                    f = a(d)(b);
                  e.append(f);
                });
              },
              post: function (a, b, c, d) {
                b.bind("$destroy", function () {});
              },
            };
          },
        };
      },
    ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeaderCell", [
      "$compile",
      "$timeout",
      "$window",
      "$document",
      "gridUtil",
      "uiGridConstants",
      "ScrollEvent",
      "i18nService",
      function (a, b, c, d, e, f, g, h) {
        var i = 500,
          j = 500,
          k = {
            priority: 0,
            scope: { col: "=", row: "=", renderIndex: "=" },
            require: ["^uiGrid", "^uiGridRenderContainer"],
            replace: !0,
            compile: function () {
              return {
                pre: function (b, c, d) {
                  var e = a(b.col.headerCellTemplate)(b);
                  c.append(e);
                },
                post: function (a, c, e, g) {
                  var k = g[0],
                    l = g[1];
                  (a.i18n = {
                    headerCell: h.getSafeText("headerCell"),
                    sort: h.getSafeText("sort"),
                  }),
                    (a.isSortPriorityVisible = function () {
                      return (
                        angular.isNumber(a.col.sort.priority) &&
                        a.grid.columns.some(function (b, c) {
                          return (
                            angular.isNumber(b.sort.priority) && b !== a.col
                          );
                        })
                      );
                    }),
                    (a.getSortDirectionAriaLabel = function () {
                      var b = a.col,
                        c =
                          b.sort.direction === f.ASC
                            ? a.i18n.sort.ascending
                            : b.sort.direction === f.DESC
                            ? a.i18n.sort.descending
                            : a.i18n.sort.none,
                        d = c;
                      return (
                        a.isSortPriorityVisible() &&
                          (d =
                            d +
                            ". " +
                            a.i18n.headerCell.priority +
                            " " +
                            b.sort.priority),
                        d
                      );
                    }),
                    (a.grid = k.grid),
                    (a.renderContainer =
                      k.grid.renderContainers[l.containerId]);
                  var m = a.col.getColClass(!1);
                  c.addClass(m),
                    (a.menuShown = !1),
                    (a.asc = f.ASC),
                    (a.desc = f.DESC);
                  var p,
                    q,
                    o =
                      (angular.element(
                        c[0].querySelectorAll(".ui-grid-header-cell-menu")
                      ),
                      angular.element(
                        c[0].querySelectorAll(".ui-grid-cell-contents")
                      )),
                    r = [];
                  (a.downFn = function (e) {
                    e.stopPropagation(),
                      "undefined" != typeof e.originalEvent &&
                        void 0 !== e.originalEvent &&
                        (e = e.originalEvent),
                      (e.button && 0 !== e.button) ||
                        ((q = e.pageX),
                        (a.mousedownStartTime = new Date().getTime()),
                        (a.mousedownTimeout = b(function () {}, i)),
                        a.mousedownTimeout.then(function () {
                          a.colMenu && k.columnMenuScope.showMenu(a.col, c, e);
                        }),
                        k.fireEvent(f.events.COLUMN_HEADER_CLICK, {
                          event: e,
                          columnName: a.col.colDef.name,
                        }),
                        a.offAllEvents(),
                        "touchstart" === e.type
                          ? (d.on("touchend", a.upFn),
                            d.on("touchmove", a.moveFn))
                          : "mousedown" === e.type &&
                            (d.on("mouseup", a.upFn),
                            d.on("mousemove", a.moveFn)));
                  }),
                    (a.upFn = function (c) {
                      c.stopPropagation(),
                        b.cancel(a.mousedownTimeout),
                        a.offAllEvents(),
                        a.onDownEvents(c.type);
                      var d = new Date().getTime(),
                        e = d - a.mousedownStartTime;
                      e > i || (a.sortable && a.handleClick(c));
                    }),
                    (a.moveFn = function (c) {
                      var d = c.pageX - q;
                      0 !== d &&
                        (b.cancel(a.mousedownTimeout),
                        a.offAllEvents(),
                        a.onDownEvents(c.type));
                    }),
                    (a.clickFn = function (b) {
                      b.stopPropagation(), o.off("click", a.clickFn);
                    }),
                    (a.offAllEvents = function () {
                      o.off("touchstart", a.downFn),
                        o.off("mousedown", a.downFn),
                        d.off("touchend", a.upFn),
                        d.off("mouseup", a.upFn),
                        d.off("touchmove", a.moveFn),
                        d.off("mousemove", a.moveFn),
                        o.off("click", a.clickFn);
                    }),
                    (a.onDownEvents = function (c) {
                      switch (c) {
                        case "touchmove":
                        case "touchend":
                          o.on("click", a.clickFn),
                            o.on("touchstart", a.downFn),
                            b(function () {
                              o.on("mousedown", a.downFn);
                            }, j);
                          break;
                        case "mousemove":
                        case "mouseup":
                          o.on("click", a.clickFn),
                            o.on("mousedown", a.downFn),
                            b(function () {
                              o.on("touchstart", a.downFn);
                            }, j);
                          break;
                        default:
                          o.on("click", a.clickFn),
                            o.on("touchstart", a.downFn),
                            o.on("mousedown", a.downFn);
                      }
                    });
                  var s = function (d) {
                    var e = c;
                    p && (e.removeClass(p), (p = null)),
                      (p = angular.isFunction(a.col.headerCellClass)
                        ? a.col.headerCellClass(
                            a.grid,
                            a.row,
                            a.col,
                            a.rowRenderIndex,
                            a.colRenderIndex
                          )
                        : a.col.headerCellClass),
                      e.addClass(p),
                      b(function () {
                        var b = a.grid.renderContainers.right
                          ? a.grid.renderContainers.right
                          : a.grid.renderContainers.body;
                        a.isLastCol =
                          a.col ===
                          b.visibleColumnCache[b.visibleColumnCache.length - 1];
                      }),
                      a.col.enableSorting
                        ? (a.sortable = !0)
                        : (a.sortable = !1);
                    var g = a.filterable;
                    k.grid.options.enableFiltering && a.col.enableFiltering
                      ? (a.filterable = !0)
                      : (a.filterable = !1),
                      g !== a.filterable &&
                        ("undefined" != typeof a.col.updateFilters &&
                          a.col.updateFilters(a.filterable),
                        a.filterable
                          ? (a.col.filters.forEach(function (b, c) {
                              r.push(
                                a.$watch(
                                  "col.filters[" + c + "].term",
                                  function (a, b) {
                                    a !== b &&
                                      (k.grid.api.core.raise.filterChanged(),
                                      k.grid.api.core.notifyDataChange(
                                        f.dataChange.COLUMN
                                      ),
                                      k.grid.queueGridRefresh());
                                  }
                                )
                              );
                            }),
                            a.$on("$destroy", function () {
                              r.forEach(function (a) {
                                a();
                              });
                            }))
                          : r.forEach(function (a) {
                              a();
                            })),
                      a.col.grid.options &&
                      a.col.grid.options.enableColumnMenus !== !1 &&
                      a.col.colDef &&
                      a.col.colDef.enableColumnMenu !== !1
                        ? (a.colMenu = !0)
                        : (a.colMenu = !1),
                      a.offAllEvents(),
                      (a.sortable || a.colMenu) &&
                        (a.onDownEvents(),
                        a.$on("$destroy", function () {
                          a.offAllEvents();
                        }));
                  };
                  s();
                  var t = a.grid.registerDataChangeCallback(s, [
                    f.dataChange.COLUMN,
                  ]);
                  a.$on("$destroy", t),
                    (a.handleClick = function (b) {
                      var c = !1;
                      b.shiftKey && (c = !0),
                        k.grid.sortColumn(a.col, c).then(function () {
                          k.columnMenuScope && k.columnMenuScope.hideMenu(),
                            k.grid.refresh();
                        });
                    }),
                    (a.toggleMenu = function (b) {
                      b.stopPropagation(),
                        k.columnMenuScope.menuShown &&
                        k.columnMenuScope.col === a.col
                          ? k.columnMenuScope.hideMenu()
                          : k.columnMenuScope.showMenu(a.col, c);
                    });
                },
              };
            },
          };
        return k;
      },
    ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridHeader", [
      "$templateCache",
      "$compile",
      "uiGridConstants",
      "gridUtil",
      "$timeout",
      "ScrollEvent",
      function (a, b, c, d, e, f) {
        var g = "ui-grid/ui-grid-header",
          h = "ui-grid/ui-grid-no-header";
        return {
          restrict: "EA",
          replace: !0,
          require: ["^uiGrid", "^uiGridRenderContainer"],
          scope: !0,
          compile: function (a, c) {
            return {
              pre: function (a, c, e, i) {
                function m() {
                  k.header = k.colContainer.header = c;
                  var a = c[0].getElementsByClassName("ui-grid-header-canvas");
                  a.length > 0
                    ? (k.headerCanvas = k.colContainer.headerCanvas = a[0])
                    : (k.headerCanvas = null);
                }
                function n(a) {
                  if (!j.grid.isScrollingHorizontally) {
                    var b = d.normalizeScrollLeft(k.headerViewport, j.grid),
                      c = k.colContainer.scrollHorizontal(b),
                      e = new f(
                        j.grid,
                        null,
                        k.colContainer,
                        f.Sources.ViewPortScroll
                      );
                    (e.newScrollLeft = b),
                      c > -1 && (e.x = { percentage: c }),
                      j.grid.scrollContainers(null, e);
                  }
                }
                var j = i[0],
                  k = i[1];
                (a.grid = j.grid), (a.colContainer = k.colContainer), m();
                var l;
                (l = a.grid.options.showHeader
                  ? a.grid.options.headerTemplate
                    ? a.grid.options.headerTemplate
                    : g
                  : h),
                  d.getTemplate(l).then(function (d) {
                    var e = angular.element(d),
                      f = b(e)(a);
                    if ((c.replaceWith(f), (c = f), m(), k)) {
                      var g = c[0].getElementsByClassName(
                        "ui-grid-header-viewport"
                      )[0];
                      g &&
                        ((k.headerViewport = g),
                        angular.element(g).on("scroll", n),
                        a.$on("$destroy", function () {
                          angular.element(g).off("scroll", n);
                        }));
                    }
                    a.grid.queueRefresh();
                  });
              },
              post: function (a, b, c, e) {
                function i() {
                  var a = g.colContainer.visibleColumnCache,
                    b = "",
                    c = 0;
                  return (
                    a.forEach(function (a) {
                      (b += a.getColClassDefinition()), (c += a.drawnWidth);
                    }),
                    (g.colContainer.canvasWidth = c),
                    b
                  );
                }
                var f = e[0],
                  g = e[1];
                f.grid;
                d.disableAnimations(b), (g.header = b);
                var j = b[0].getElementsByClassName(
                  "ui-grid-header-viewport"
                )[0];
                j && (g.headerViewport = j),
                  f &&
                    f.grid.registerStyleComputation({ priority: 15, func: i });
              },
            };
          },
        };
      },
    ]);
  })(),
  (function () {
    angular
      .module("ui.grid")
      .service("uiGridGridMenuService", [
        "gridUtil",
        "i18nService",
        "uiGridConstants",
        function (a, b, c) {
          var d = {
            initialize: function (a, b) {
              (b.gridMenuScope = a),
                (a.grid = b),
                (a.registeredMenuItems = []),
                a.$on("$destroy", function () {
                  a.grid &&
                    a.grid.gridMenuScope &&
                    (a.grid.gridMenuScope = null),
                    a.grid && (a.grid = null),
                    a.registeredMenuItems && (a.registeredMenuItems = null);
                }),
                (a.registeredMenuItems = []),
                b.api.registerMethod("core", "addToGridMenu", d.addToGridMenu),
                b.api.registerMethod(
                  "core",
                  "removeFromGridMenu",
                  d.removeFromGridMenu
                );
            },
            addToGridMenu: function (b, c) {
              angular.isArray(c)
                ? b.gridMenuScope
                  ? ((b.gridMenuScope.registeredMenuItems = b.gridMenuScope
                      .registeredMenuItems
                      ? b.gridMenuScope.registeredMenuItems
                      : []),
                    (b.gridMenuScope.registeredMenuItems = b.gridMenuScope.registeredMenuItems.concat(
                      c
                    )))
                  : a.logError(
                      "Asked to addToGridMenu, but gridMenuScope not present.  Timing issue?  Please log issue with ui-grid"
                    )
                : a.logError(
                    "addToGridMenu: menuItems must be an array, and is not, not adding any items"
                  );
            },
            removeFromGridMenu: function (b, c) {
              var d = -1;
              b &&
                b.gridMenuScope &&
                b.gridMenuScope.registeredMenuItems.forEach(function (b, e) {
                  b.id === c &&
                    (d > -1
                      ? a.logError(
                          "removeFromGridMenu: found multiple items with the same id, removing only the last"
                        )
                      : (d = e));
                }),
                d > -1 && b.gridMenuScope.registeredMenuItems.splice(d, 1);
            },
            getMenuItems: function (c) {
              var e = [];
              c.grid.options.gridMenuCustomItems &&
                (angular.isArray(c.grid.options.gridMenuCustomItems)
                  ? (e = e.concat(c.grid.options.gridMenuCustomItems))
                  : a.logError(
                      "gridOptions.gridMenuCustomItems must be an array, and is not"
                    ));
              var f = [
                {
                  title: b.getSafeText("gridMenu.clearAllFilters"),
                  action: function (a) {
                    c.grid.clearAllFilters();
                  },
                  shown: function () {
                    return c.grid.options.enableFiltering;
                  },
                  order: 100,
                },
              ];
              if (
                ((e = e.concat(f)),
                (e = e.concat(c.registeredMenuItems)),
                c.grid.options.gridMenuShowHideColumns !== !1 &&
                  (e = e.concat(d.showHideColumns(c))),
                c.grid.options.gridMenuSortAlphabetical)
              ) {
                var g = ["Columns:", "Clear all filters"];
                e.sort(function (a, b) {
                  return g.indexOf(a.title) >= 0 || g.indexOf(b.title) >= 0
                    ? g.indexOf(a.title) >= 0 && g.indexOf(b.title) < 0
                      ? -1
                      : g.indexOf(b.title) >= 0 && g.indexOf(a.title) < 0
                      ? 1
                      : 0
                    : a.title < b.title
                    ? -1
                    : a.title > b.title
                    ? 1
                    : 0;
                });
              } else
                e.sort(function (a, b) {
                  return a.order - b.order;
                });
              return e;
            },
            showHideColumns: function (a) {
              var c = [];
              return a.grid.options.columnDefs &&
                0 !== a.grid.options.columnDefs.length &&
                0 !== a.grid.columns.length
                ? (c.push({
                    title: b.getSafeText("gridMenu.columns"),
                    order: 300,
                  }),
                  (a.grid.options.gridMenuTitleFilter = a.grid.options
                    .gridMenuTitleFilter
                    ? a.grid.options.gridMenuTitleFilter
                    : function (a) {
                        return a;
                      }),
                  a.grid.options.columnDefs.forEach(function (b, e) {
                    if (b.enableHiding !== !1) {
                      var f = {
                        icon: "ui-grid-icon-ok",
                        action: function (a) {
                          a.stopPropagation(),
                            d.toggleColumnVisibility(this.context.gridCol);
                        },
                        shown: function () {
                          return (
                            this.context.gridCol.colDef.visible === !0 ||
                            void 0 === this.context.gridCol.colDef.visible
                          );
                        },
                        context: {
                          gridCol: a.grid.getColumn(b.name || b.field),
                        },
                        leaveOpen: !0,
                        order: 301 + 2 * e,
                      };
                      d.setMenuItemTitle(f, b, a.grid),
                        c.push(f),
                        (f = {
                          icon: "ui-grid-icon-cancel",
                          action: function (a) {
                            a.stopPropagation(),
                              d.toggleColumnVisibility(this.context.gridCol);
                          },
                          shown: function () {
                            return !(
                              this.context.gridCol.colDef.visible === !0 ||
                              void 0 === this.context.gridCol.colDef.visible
                            );
                          },
                          context: {
                            gridCol: a.grid.getColumn(b.name || b.field),
                          },
                          leaveOpen: !0,
                          order: 301 + 2 * e + 1,
                        }),
                        d.setMenuItemTitle(f, b, a.grid),
                        c.push(f);
                    }
                  }),
                  c)
                : c;
            },
            setMenuItemTitle: function (b, c, d) {
              var e = d.options.gridMenuTitleFilter(
                c.displayName || a.readableColumnName(c.name) || c.field
              );
              "string" == typeof e
                ? (b.title = e)
                : e.then
                ? ((b.title = ""),
                  e.then(
                    function (a) {
                      b.title = a;
                    },
                    function (a) {
                      b.title = a;
                    }
                  ))
                : (a.logError(
                    "Expected gridMenuTitleFilter to return a string or a promise, it has returned neither, bad config"
                  ),
                  (b.title = "badconfig"));
            },
            toggleColumnVisibility: function (a) {
              (a.colDef.visible = !(
                a.colDef.visible === !0 || void 0 === a.colDef.visible
              )),
                a.grid.refresh(),
                a.grid.api.core.notifyDataChange(c.dataChange.COLUMN),
                a.grid.api.core.raise.columnVisibilityChanged(a);
            },
          };
          return d;
        },
      ])
      .directive("uiGridMenuButton", [
        "gridUtil",
        "uiGridConstants",
        "uiGridGridMenuService",
        "i18nService",
        function (a, b, c, d) {
          return {
            priority: 0,
            scope: !0,
            require: ["^uiGrid"],
            templateUrl: "ui-grid/ui-grid-menu-button",
            replace: !0,
            link: function (b, e, f, g) {
              var h = g[0];
              (b.i18n = { aria: d.getSafeText("gridMenu.aria") }),
                c.initialize(b, h.grid),
                (b.shown = !1),
                (b.toggleMenu = function () {
                  b.shown
                    ? (b.$broadcast("hide-menu"), (b.shown = !1))
                    : ((b.menuItems = c.getMenuItems(b)),
                      b.$broadcast("show-menu"),
                      (b.shown = !0));
                }),
                b.$on("menu-hidden", function () {
                  (b.shown = !1),
                    a.focus.bySelector(e, ".ui-grid-icon-container");
                });
            },
          };
        },
      ]);
  })(),
  (function () {
    angular
      .module("ui.grid")
      .directive("uiGridMenu", [
        "$compile",
        "$timeout",
        "$window",
        "$document",
        "gridUtil",
        "uiGridConstants",
        "i18nService",
        function (a, b, c, d, e, f, g) {
          var h = {
            priority: 0,
            scope: { menuItems: "=", autoHide: "=?" },
            require: "?^uiGrid",
            templateUrl: "ui-grid/uiGridMenu",
            replace: !1,
            link: function (d, h, i, j) {
              if (
                ((d.dynamicStyles = ""),
                j &&
                  j.grid &&
                  j.grid.options &&
                  j.grid.options.gridMenuTemplate)
              ) {
                var k = j.grid.options.gridMenuTemplate;
                e.getTemplate(k).then(function (b) {
                  var c = angular.element(b),
                    e = a(c)(d);
                  h.replaceWith(e);
                });
              }
              var l = function (a) {
                var b = a - j.grid.headerHeight - 20;
                d.dynamicStyles = [
                  ".grid" + j.grid.id + " .ui-grid-menu-mid {",
                  "max-height: " + b + "px;",
                  "}",
                ].join(" ");
              };
              j &&
                (l(j.grid.gridHeight),
                j.grid.api.core.on.gridDimensionChanged(d, function (
                  a,
                  b,
                  c,
                  d
                ) {
                  l(c);
                })),
                (d.i18n = { close: g.getSafeText("columnMenu.close") }),
                (d.showMenu = function (a, c) {
                  d.shown
                    ? d.shownMid || ((d.shownMid = !0), d.$emit("menu-shown"))
                    : ((d.shown = !0),
                      b(function () {
                        (d.shownMid = !0), d.$emit("menu-shown");
                      }));
                  var f = "click";
                  c &&
                    c.originalEvent &&
                    c.originalEvent.type &&
                    "touchstart" === c.originalEvent.type &&
                    (f = c.originalEvent.type),
                    angular.element(document).off("click touchstart", m),
                    h.off("keyup", n),
                    h.off("keydown", o),
                    b(function () {
                      angular.element(document).on(f, m),
                        h.on("keyup", n),
                        h.on("keydown", o);
                    }),
                    e.focus.bySelector(h, "button[type=button]", !0);
                }),
                (d.hideMenu = function (a) {
                  d.shown &&
                    ((d.shownMid = !1),
                    b(function () {
                      d.shownMid || ((d.shown = !1), d.$emit("menu-hidden"));
                    }, 200)),
                    angular.element(document).off("click touchstart", m),
                    h.off("keyup", n),
                    h.off("keydown", o);
                }),
                d.$on("hide-menu", function (a, b) {
                  d.hideMenu(a, b);
                }),
                d.$on("show-menu", function (a, b) {
                  d.showMenu(a, b);
                });
              var m = function () {
                  d.shown &&
                    d.$apply(function () {
                      d.hideMenu();
                    });
                },
                n = function (a) {
                  27 === a.keyCode && d.hideMenu();
                },
                o = function (a) {
                  var b = function (b) {
                    return b.focus(), a.preventDefault(), !1;
                  };
                  if (9 === a.keyCode) {
                    var c,
                      d,
                      e = h[0].querySelectorAll("button:not(.ng-hide)");
                    e.length > 0 &&
                      ((c = e[0]),
                      (d = e[e.length - 1]),
                      a.target !== d || a.shiftKey
                        ? a.target === c && a.shiftKey && b(d)
                        : b(c));
                  }
                };
              ("undefined" != typeof d.autoHide && void 0 !== d.autoHide) ||
                (d.autoHide = !0),
                d.autoHide && angular.element(c).on("resize", m),
                d.$on("$destroy", function () {
                  angular.element(c).off("resize", m),
                    angular.element(document).off("click touchstart", m),
                    h.off("keyup", n),
                    h.off("keydown", o);
                }),
                j && d.$on("$destroy", j.grid.api.core.on.scrollBegin(d, m)),
                d.$on("$destroy", d.$on(f.events.ITEM_DRAGGING, m));
            },
          };
          return h;
        },
      ])
      .directive("uiGridMenuItem", [
        "gridUtil",
        "$compile",
        "i18nService",
        function (a, b, c) {
          var d = {
            priority: 0,
            scope: {
              name: "=",
              active: "=",
              action: "=",
              icon: "=",
              shown: "=",
              context: "=",
              templateUrl: "=",
              leaveOpen: "=",
              screenReaderOnly: "=",
            },
            require: ["?^uiGrid"],
            templateUrl: "ui-grid/uiGridMenuItem",
            replace: !1,
            compile: function () {
              return {
                pre: function (c, d) {
                  c.templateUrl &&
                    a.getTemplate(c.templateUrl).then(function (a) {
                      var e = angular.element(a),
                        f = b(e)(c);
                      d.replaceWith(f);
                    });
                },
                post: function (b, d, e, f) {
                  var g = f[0];
                  ("undefined" != typeof b.shown && null !== b.shown) ||
                    (b.shown = function () {
                      return !0;
                    }),
                    (b.itemShown = function () {
                      var a = {};
                      return (
                        b.context && (a.context = b.context),
                        "undefined" != typeof g && g && (a.grid = g.grid),
                        b.shown.call(a)
                      );
                    }),
                    (b.itemAction = function (c, e) {
                      if (
                        (c.stopPropagation(), "function" == typeof b.action)
                      ) {
                        var f = {};
                        b.context && (f.context = b.context),
                          "undefined" != typeof g && g && (f.grid = g.grid),
                          b.action.call(f, c, e),
                          b.leaveOpen
                            ? a.focus.bySelector(
                                angular.element(
                                  a.closestElm(d, ".ui-grid-menu-items")
                                ),
                                "button[type=button]",
                                !0
                              )
                            : b.$emit("hide-menu");
                      }
                    }),
                    (b.i18n = c.get());
                },
              };
            },
          };
          return d;
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid");
    angular.forEach(
      [
        { tag: "Src", method: "attr" },
        { tag: "Text", method: "text" },
        { tag: "Href", method: "attr" },
        { tag: "Class", method: "addClass" },
        { tag: "Html", method: "html" },
        { tag: "Alt", method: "attr" },
        { tag: "Style", method: "css" },
        { tag: "Value", method: "attr" },
        { tag: "Id", method: "attr" },
        {
          tag: "Id",
          directiveName: "IdGrid",
          method: "attr",
          appendGridId: !0,
        },
        { tag: "Title", method: "attr" },
        { tag: "Label", method: "attr", aria: !0 },
        { tag: "Labelledby", method: "attr", aria: !0 },
        {
          tag: "Labelledby",
          directiveName: "LabelledbyGrid",
          appendGridId: !0,
          method: "attr",
          aria: !0,
        },
        { tag: "Describedby", method: "attr", aria: !0 },
        {
          tag: "Describedby",
          directiveName: "DescribedbyGrid",
          appendGridId: !0,
          method: "attr",
          aria: !0,
        },
      ],
      function (b) {
        var c = "uiGridOneBind",
          d =
            (b.aria ? c + "Aria" : c) +
            (b.directiveName ? b.directiveName : b.tag);
        a.directive(d, [
          "gridUtil",
          function (a) {
            return {
              restrict: "A",
              require: ["?uiGrid", "?^uiGrid"],
              link: function (c, e, f, g) {
                var h = function (b) {
                    var e;
                    if (c.grid) e = c.grid;
                    else if (c.col && c.col.grid) e = c.col.grid;
                    else if (
                      !g.some(function (a) {
                        if (a && a.grid) return (e = a.grid), !0;
                      })
                    )
                      throw (
                        (a.logError(
                          "[" +
                            d +
                            "] A valid grid could not be found to bind id. Are you using this directive within the correct scope? Trying to generate id: [gridID]-" +
                            b
                        ),
                        new Error("No valid grid could be found"))
                      );
                    if (e) {
                      var f = new RegExp(e.id.toString());
                      f.test(b) || (b = e.id.toString() + "-" + b);
                    }
                    return b;
                  },
                  i = c.$watch(
                    f[d],
                    function (a) {
                      if (a) {
                        if (b.appendGridId) {
                          var c = null;
                          angular.forEach(a.split(" "), function (a) {
                            c = (c ? c + " " : "") + h(a);
                          }),
                            (a = c);
                        }
                        switch (b.method) {
                          case "attr":
                            b.aria
                              ? e[b.method]("aria-" + b.tag.toLowerCase(), a)
                              : e[b.method](b.tag.toLowerCase(), a);
                            break;
                          case "addClass":
                            if (angular.isObject(a) && !angular.isArray(a)) {
                              var d = [],
                                f = !1;
                              if (
                                (angular.forEach(a, function (a, b) {
                                  null !== a &&
                                    "undefined" != typeof a &&
                                    ((f = !0), a && d.push(b));
                                }),
                                !f)
                              )
                                return;
                              a = d;
                            }
                            if (!a) return;
                            e.addClass(angular.isArray(a) ? a.join(" ") : a);
                            break;
                          default:
                            e[b.method](a);
                        }
                        i();
                      }
                    },
                    !0
                  );
              },
            };
          },
        ]);
      }
    );
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid");
    a.directive("uiGridRenderContainer", [
      "$timeout",
      "$document",
      "uiGridConstants",
      "gridUtil",
      "ScrollEvent",
      function (a, b, c, d, e) {
        return {
          replace: !0,
          transclude: !0,
          templateUrl: "ui-grid/uiGridRenderContainer",
          require: ["^uiGrid", "uiGridRenderContainer"],
          scope: {
            containerId: "=",
            rowContainerName: "=",
            colContainerName: "=",
            bindScrollHorizontal: "=",
            bindScrollVertical: "=",
            enableVerticalScrollbar: "=",
            enableHorizontalScrollbar: "=",
          },
          controller: "uiGridRenderContainer as RenderContainer",
          compile: function () {
            return {
              pre: function (b, c, d, e) {
                var f = e[0],
                  g = e[1],
                  h = (b.grid = f.grid);
                if (!b.rowContainerName)
                  throw "No row render container name specified";
                if (!b.colContainerName)
                  throw "No column render container name specified";
                if (!h.renderContainers[b.rowContainerName])
                  throw (
                    "Row render container '" +
                    b.rowContainerName +
                    "' is not registered."
                  );
                if (!h.renderContainers[b.colContainerName])
                  throw (
                    "Column render container '" +
                    b.colContainerName +
                    "' is not registered."
                  );
                var i = (b.rowContainer =
                    h.renderContainers[b.rowContainerName]),
                  j = (b.colContainer = h.renderContainers[b.colContainerName]);
                (g.containerId = b.containerId),
                  (g.rowContainer = i),
                  (g.colContainer = j);
              },
              post: function (b, c, f, g) {
                function p() {
                  var a = "",
                    c = l.canvasWidth,
                    d = l.getViewportWidth(),
                    e = k.getCanvasHeight(),
                    f = k.getViewportHeight();
                  l.needsHScrollbarPlaceholder() && (f -= j.scrollbarHeight);
                  var g, i;
                  return (
                    (g = i = l.getHeaderViewportWidth()),
                    (a +=
                      "\n .grid" +
                      h.grid.id +
                      " .ui-grid-render-container-" +
                      b.containerId +
                      " .ui-grid-canvas { width: " +
                      c +
                      "px; height: " +
                      e +
                      "px; }"),
                    (a +=
                      "\n .grid" +
                      h.grid.id +
                      " .ui-grid-render-container-" +
                      b.containerId +
                      " .ui-grid-header-canvas { width: " +
                      (c + j.scrollbarWidth) +
                      "px; }"),
                    (a += o.explicitHeaderCanvasHeight
                      ? "\n .grid" +
                        h.grid.id +
                        " .ui-grid-render-container-" +
                        b.containerId +
                        " .ui-grid-header-canvas { height: " +
                        o.explicitHeaderCanvasHeight +
                        "px; }"
                      : "\n .grid" +
                        h.grid.id +
                        " .ui-grid-render-container-" +
                        b.containerId +
                        " .ui-grid-header-canvas { height: inherit; }"),
                    (a +=
                      "\n .grid" +
                      h.grid.id +
                      " .ui-grid-render-container-" +
                      b.containerId +
                      " .ui-grid-viewport { width: " +
                      d +
                      "px; height: " +
                      f +
                      "px; }"),
                    (a +=
                      "\n .grid" +
                      h.grid.id +
                      " .ui-grid-render-container-" +
                      b.containerId +
                      " .ui-grid-header-viewport { width: " +
                      g +
                      "px; }"),
                    (a +=
                      "\n .grid" +
                      h.grid.id +
                      " .ui-grid-render-container-" +
                      b.containerId +
                      " .ui-grid-footer-canvas { width: " +
                      (c + j.scrollbarWidth) +
                      "px; }"),
                    (a +=
                      "\n .grid" +
                      h.grid.id +
                      " .ui-grid-render-container-" +
                      b.containerId +
                      " .ui-grid-footer-viewport { width: " +
                      i +
                      "px; }")
                  );
                }
                var h = g[0],
                  i = g[1],
                  j = h.grid,
                  k = i.rowContainer,
                  l = i.colContainer,
                  m = null,
                  n = null,
                  o = j.renderContainers[b.containerId];
                c.addClass("ui-grid-render-container-" + b.containerId),
                  d.on.mousewheel(c, function (a) {
                    var b = new e(j, k, l, e.Sources.RenderContainerMouseWheel);
                    if (0 !== a.deltaY) {
                      var c = a.deltaY * -1 * a.deltaFactor;
                      (m = i.viewport[0].scrollTop),
                        (b.verticalScrollLength = k.getVerticalScrollLength());
                      var f = (m + c) / b.verticalScrollLength;
                      f >= 1 &&
                        m < b.verticalScrollLength &&
                        (i.viewport[0].scrollTop = b.verticalScrollLength),
                        f < 0 ? (f = 0) : f > 1 && (f = 1),
                        (b.y = { percentage: f, pixels: c });
                    }
                    if (0 !== a.deltaX) {
                      var g = a.deltaX * a.deltaFactor;
                      (n = d.normalizeScrollLeft(i.viewport, j)),
                        (b.horizontalScrollLength =
                          l.getCanvasWidth() - l.getViewportWidth());
                      var h = (n + g) / b.horizontalScrollLength;
                      h < 0 ? (h = 0) : h > 1 && (h = 1),
                        (b.x = { percentage: h, pixels: g });
                    }
                    (0 !== a.deltaY && (b.atTop(m) || b.atBottom(m))) ||
                      (0 !== a.deltaX && (b.atLeft(n) || b.atRight(n))) ||
                      (a.preventDefault(),
                      a.stopPropagation(),
                      b.fireThrottledScrollingEvent("", b));
                  }),
                  c.bind("$destroy", function () {
                    c.unbind("keydown"),
                      [
                        "touchstart",
                        "touchmove",
                        "touchend",
                        "keydown",
                        "wheel",
                        "mousewheel",
                        "DomMouseScroll",
                        "MozMousePixelScroll",
                      ].forEach(function (a) {
                        c.unbind(a);
                      });
                  }),
                  h.grid.registerStyleComputation({ priority: 6, func: p });
              },
            };
          },
        };
      },
    ]),
      a.controller("uiGridRenderContainer", [
        "$scope",
        "gridUtil",
        function (a, b) {},
      ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridRow", [
      "gridUtil",
      function (a) {
        return {
          replace: !0,
          require: ["^uiGrid", "^uiGridRenderContainer"],
          scope: { row: "=uiGridRow", rowRenderIndex: "=" },
          compile: function () {
            return {
              pre: function (a, b, c, d) {
                function j() {
                  a.row.getRowTemplateFn.then(function (c) {
                    var d = a.$new();
                    c(d, function (a, c) {
                      h && (h.remove(), i.$destroy()),
                        b.empty().append(a),
                        (h = a),
                        (i = d);
                    });
                  });
                }
                var e = d[0],
                  f = d[1];
                e.grid;
                (a.grid = e.grid), (a.colContainer = f.colContainer);
                var h, i;
                j(),
                  a.$watch("row.getRowTemplateFn", function (a, b) {
                    a !== b && j();
                  });
              },
              post: function (a, b, c, d) {},
            };
          },
        };
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").directive("uiGridStyle", [
      "gridUtil",
      "$interpolate",
      function (a, b) {
        return {
          link: function (a, c, d, e) {
            var f = b(c.text(), !0);
            f &&
              a.$watch(f, function (a) {
                c.text(a);
              });
          },
        };
      },
    ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridViewport", [
      "gridUtil",
      "ScrollEvent",
      "uiGridConstants",
      "$log",
      function (a, b, c, d) {
        return {
          replace: !0,
          scope: {},
          controllerAs: "Viewport",
          templateUrl: "ui-grid/uiGridViewport",
          require: ["^uiGrid", "^uiGridRenderContainer"],
          link: function (c, d, e, f) {
            function m(e) {
              var f = d[0].scrollTop,
                g = a.normalizeScrollLeft(d, k),
                h = i.scrollVertical(f),
                l = j.scrollHorizontal(g),
                m = new b(k, i, j, b.Sources.ViewPortScroll);
              (m.newScrollLeft = g),
                (m.newScrollTop = f),
                l > -1 && (m.x = { percentage: l }),
                h > -1 && (m.y = { percentage: h }),
                k.scrollContainers(c.$parent.containerId, m);
            }
            function n(a) {
              h.prevScrollArgs = a;
              var b = a.getNewScrollTop(i, h.viewport);
              d[0].scrollTop = b;
            }
            function o(b) {
              h.prevScrollArgs = b;
              var c = b.getNewScrollLeft(j, h.viewport);
              d[0].scrollLeft = a.denormalizeScrollLeft(h.viewport, c, k);
            }
            function p(b) {
              var c = b.getNewScrollLeft(j, h.viewport);
              h.headerViewport &&
                (h.headerViewport.scrollLeft = a.denormalizeScrollLeft(
                  h.viewport,
                  c,
                  k
                ));
            }
            function q(b) {
              var c = b.getNewScrollLeft(j, h.viewport);
              h.footerViewport &&
                (h.footerViewport.scrollLeft = a.denormalizeScrollLeft(
                  h.viewport,
                  c,
                  k
                ));
            }
            var g = f[0],
              h = f[1];
            c.containerCtrl = h;
            var i = h.rowContainer,
              j = h.colContainer,
              k = g.grid;
            (c.grid = g.grid),
              (c.rowContainer = h.rowContainer),
              (c.colContainer = h.colContainer),
              (h.viewport = d),
              k && k.options && k.options.customScroller
                ? k.options.customScroller(d, m)
                : d.on("scroll", m);
            c.$parent.bindScrollVertical &&
              k.addVerticalScrollSync(c.$parent.containerId, n),
              c.$parent.bindScrollHorizontal &&
                (k.addHorizontalScrollSync(c.$parent.containerId, o),
                k.addHorizontalScrollSync(c.$parent.containerId + "header", p),
                k.addHorizontalScrollSync(c.$parent.containerId + "footer", q)),
              c.$on("$destroy", function () {
                d.off();
              });
          },
          controller: [
            "$scope",
            function (a) {
              this.rowStyle = function (b) {
                var c = a.rowContainer,
                  d = a.colContainer,
                  e = {};
                if (0 !== c.currentTopRow) {
                  var f =
                    "translateY(" +
                    c.currentTopRow * c.grid.options.rowHeight +
                    "px)";
                  (e.transform = f),
                    (e["-webkit-transform"] = f),
                    (e["-ms-transform"] = f);
                }
                return (
                  0 !== d.currentFirstColumn &&
                    (d.grid.isRTL()
                      ? (e["margin-right"] = d.columnOffset + "px")
                      : (e["margin-left"] = d.columnOffset + "px")),
                  e
                );
              };
            },
          ],
        };
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").directive("uiGridVisible", function () {
      return function (a, b, c) {
        a.$watch(c.uiGridVisible, function (a) {
          b[a ? "removeClass" : "addClass"]("ui-grid-invisible");
        });
      };
    });
  })(),
  (function () {
    "use strict";
    function a(a, b, c, d, e, f) {
      return {
        templateUrl: "ui-grid/ui-grid",
        scope: { uiGrid: "=" },
        replace: !0,
        transclude: !0,
        controller: "uiGridController",
        compile: function () {
          return {
            post: function (a, b, g, h) {
              function m() {
                b[0].offsetWidth <= 0 && l < k ? (setTimeout(m, j), l++) : c(o);
              }
              function n() {
                angular.element(d).on("resize", q),
                  b.on("$destroy", function () {
                    angular.element(d).off("resize", q);
                  }),
                  a.$watch(
                    function () {
                      return i.hasLeftContainer();
                    },
                    function (a, b) {
                      a !== b && i.refreshCanvas(!0);
                    }
                  ),
                  a.$watch(
                    function () {
                      return i.hasRightContainer();
                    },
                    function (a, b) {
                      a !== b && i.refreshCanvas(!0);
                    }
                  );
              }
              function o() {
                (i.gridWidth = a.gridWidth = e.elementWidth(b)),
                  (i.canvasWidth = h.grid.gridWidth),
                  (i.gridHeight = a.gridHeight = e.elementHeight(b)),
                  i.gridHeight <= i.options.rowHeight &&
                    i.options.enableMinHeightCheck &&
                    p(),
                  i.refreshCanvas(!0);
              }
              function p() {
                var c = i.options.minRowsToShow * i.options.rowHeight,
                  d = i.options.showHeader ? i.options.headerRowHeight : 0,
                  g = i.calcFooterHeight(),
                  h = 0;
                i.options.enableHorizontalScrollbar === f.scrollbars.ALWAYS &&
                  (h = e.getScrollbarWidth());
                var j = 0;
                if (
                  (angular.forEach(i.options.columnDefs, function (a) {
                    a.hasOwnProperty("filter")
                      ? j < 1 && (j = 1)
                      : a.hasOwnProperty("filters") &&
                        j < a.filters.length &&
                        (j = a.filters.length);
                  }),
                  i.options.enableFiltering && !j)
                ) {
                  var k =
                    i.options.columnDefs.length &&
                    i.options.columnDefs.every(function (a) {
                      return a.enableFiltering === !1;
                    });
                  k || (j = 1);
                }
                var l = j * d,
                  m = d + c + g + h + l;
                b.css("height", m + "px"),
                  (i.gridHeight = a.gridHeight = e.elementHeight(b));
              }
              function q(c) {
                (i.gridWidth = a.gridWidth = e.elementWidth(b)),
                  (i.gridHeight = a.gridHeight = e.elementHeight(b)),
                  i.refreshCanvas(!0);
              }
              var i = h.grid;
              (h.scrollbars = []), (i.element = b);
              var j = 100,
                k = 20,
                l = 0;
              n(), o(), i.renderingComplete(), m();
            },
          };
        },
      };
    }
    angular.module("ui.grid").controller("uiGridController", [
      "$scope",
      "$element",
      "$attrs",
      "gridUtil",
      "$q",
      "uiGridConstants",
      "$templateCache",
      "gridClassFactory",
      "$timeout",
      "$parse",
      "$compile",
      function (a, b, c, d, e, f, g, h, i, j, k) {
        function n(b, c) {
          b &&
            b !== c &&
            ((l.grid.options.columnDefs = a.uiGrid.columnDefs),
            l.grid.buildColumns({ orderByColumnDefs: !0 }).then(function () {
              l.grid.preCompileCellTemplates(),
                l.grid.callDataChangeCallbacks(f.dataChange.COLUMN);
            }));
        }
        function p(b) {
          var d = [];
          if (
            (l.grid.options.fastWatch &&
              (b = angular.isString(a.uiGrid.data)
                ? l.grid.appScope[a.uiGrid.data]
                : a.uiGrid.data),
            (o = b),
            b)
          ) {
            var g =
              l.grid.columns.length >
              (l.grid.rowHeaderColumns ? l.grid.rowHeaderColumns.length : 0);
            !g &&
              !c.uiGridColumns &&
              0 === l.grid.options.columnDefs.length &&
              b.length > 0 &&
              l.grid.buildColumnDefsFromData(b),
              !g &&
                (l.grid.options.columnDefs.length > 0 || b.length > 0) &&
                d.push(
                  l.grid.buildColumns().then(function () {
                    l.grid.preCompileCellTemplates();
                  })
                ),
              e.all(d).then(function () {
                l.grid.modifyRows(o).then(function () {
                  l.grid.redrawInPlace(!0),
                    a.$evalAsync(function () {
                      l.grid.refreshCanvas(!0),
                        l.grid.callDataChangeCallbacks(f.dataChange.ROW);
                    });
                });
              });
          }
        }
        var l = this;
        (l.grid = h.createGrid(a.uiGrid)),
          (l.grid.appScope = l.grid.appScope || a.$parent),
          b.addClass("grid" + l.grid.id),
          (l.grid.rtl = "rtl" === d.getStyles(b[0]).direction),
          (a.grid = l.grid),
          c.uiGridColumns &&
            c.$observe("uiGridColumns", function (a) {
              (l.grid.options.columnDefs = a),
                l.grid.buildColumns().then(function () {
                  l.grid.preCompileCellTemplates(), l.grid.refreshCanvas(!0);
                });
            });
        var m = [];
        l.grid.options.fastWatch
          ? ((l.uiGrid = a.uiGrid),
            angular.isString(a.uiGrid.data)
              ? (m.push(a.$parent.$watch(a.uiGrid.data, p)),
                m.push(
                  a.$parent.$watch(function () {
                    return l.grid.appScope[a.uiGrid.data]
                      ? l.grid.appScope[a.uiGrid.data].length
                      : void 0;
                  }, p)
                ))
              : (m.push(
                  a.$parent.$watch(function () {
                    return a.uiGrid.data;
                  }, p)
                ),
                m.push(
                  a.$parent.$watch(
                    function () {
                      return a.uiGrid.data.length;
                    },
                    function () {
                      p(a.uiGrid.data);
                    }
                  )
                )),
            m.push(
              a.$parent.$watch(function () {
                return a.uiGrid.columnDefs;
              }, n)
            ),
            m.push(
              a.$parent.$watch(
                function () {
                  return a.uiGrid.columnDefs.length;
                },
                function () {
                  n(a.uiGrid.columnDefs);
                }
              )
            ))
          : (angular.isString(a.uiGrid.data)
              ? m.push(a.$parent.$watchCollection(a.uiGrid.data, p))
              : m.push(
                  a.$parent.$watchCollection(function () {
                    return a.uiGrid.data;
                  }, p)
                ),
            m.push(
              a.$parent.$watchCollection(function () {
                return a.uiGrid.columnDefs;
              }, n)
            ));
        var o,
          q = a.$watch(
            function () {
              return l.grid.styleComputations;
            },
            function () {
              l.grid.refreshCanvas(!0);
            }
          );
        a.$on("$destroy", function () {
          m.forEach(function (a) {
            a();
          }),
            q();
        }),
          (l.fireEvent = function (b, c) {
            ("undefined" != typeof c && void 0 !== c) || (c = {}),
              ("undefined" != typeof c.grid && void 0 !== c.grid) ||
                (c.grid = l.grid),
              a.$broadcast(b, c);
          }),
          (l.innerCompile = function (c) {
            k(c)(a);
          });
      },
    ]),
      angular.module("ui.grid").directive("uiGrid", a),
      (a.$inject = [
        "$compile",
        "$templateCache",
        "$timeout",
        "$window",
        "gridUtil",
        "uiGridConstants",
      ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").directive("uiGridPinnedContainer", [
      "gridUtil",
      function (a) {
        return {
          restrict: "EA",
          replace: !0,
          template:
            '<div class="ui-grid-pinned-container"><div ui-grid-render-container container-id="side" row-container-name="\'body\'" col-container-name="side" bind-scroll-vertical="true" class="{{ side }} ui-grid-render-container-{{ side }}"></div></div>',
          scope: { side: "=uiGridPinnedContainer" },
          require: "^uiGrid",
          compile: function () {
            return {
              post: function (a, b, c, d) {
                function g() {
                  var a = this,
                    b = 0;
                  a.visibleColumnCache.forEach(function (a) {
                    b += a.drawnWidth;
                  });
                  var c = a.getViewportAdjustment();
                  return (b += c.width);
                }
                function h() {
                  if ("left" === a.side || "right" === a.side) {
                    for (
                      var b = e.renderContainers[a.side].visibleColumnCache,
                        c = 0,
                        d = 0;
                      d < b.length;
                      d++
                    ) {
                      var f = b[d];
                      c += f.drawnWidth || f.width || 0;
                    }
                    return c;
                  }
                }
                function i() {
                  var c = "";
                  return (
                    ("left" !== a.side && "right" !== a.side) ||
                      ((f = h()),
                      b.attr("style", null),
                      (c +=
                        ".grid" +
                        e.id +
                        " .ui-grid-pinned-container-" +
                        a.side +
                        ", .grid" +
                        e.id +
                        " .ui-grid-pinned-container-" +
                        a.side +
                        " .ui-grid-render-container-" +
                        a.side +
                        " .ui-grid-viewport { width: " +
                        f +
                        "px; } ")),
                    c
                  );
                }
                var e = d.grid,
                  f = 0;
                b.addClass("ui-grid-pinned-container-" + a.side),
                  ("left" !== a.side && "right" !== a.side) ||
                    (e.renderContainers[a.side].getViewportWidth = g),
                  e.renderContainers.body.registerViewportAdjuster(function (
                    b
                  ) {
                    return (f = h()), (b.width -= f), (b.side = a.side), b;
                  }),
                  e.registerStyleComputation({ priority: 15, func: i });
              },
            };
          },
        };
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").factory("Grid", [
      "$q",
      "$compile",
      "$parse",
      "gridUtil",
      "uiGridConstants",
      "GridOptions",
      "GridColumn",
      "GridRow",
      "GridApi",
      "rowSorter",
      "rowSearcher",
      "GridRenderContainer",
      "$timeout",
      "ScrollEvent",
      function (a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        function q() {}
        var o = function (b) {
          function g(a) {
            (c.isScrollingVertically = !1),
              c.api.core.raise.scrollEnd(a),
              (c.scrollDirection = e.scrollDirection.NONE);
          }
          function m(a) {
            (c.isScrollingHorizontally = !1),
              c.api.core.raise.scrollEnd(a),
              (c.scrollDirection = e.scrollDirection.NONE);
          }
          var c = this;
          if (void 0 === b || "undefined" == typeof b.id || !b.id)
            throw new Error(
              "No ID provided. An ID must be given when creating a grid."
            );
          if (!/^[_a-zA-Z0-9-]+$/.test(b.id))
            throw new Error(
              "Grid id '" +
                b.id +
                '" is invalid. It must follow CSS selector syntax rules.'
            );
          (c.id = b.id),
            delete b.id,
            (c.options = f.initialize(b)),
            (c.appScope = c.options.appScopeProvider),
            (c.headerHeight = c.options.headerRowHeight),
            (c.footerHeight = c.calcFooterHeight()),
            (c.columnFooterHeight = c.calcColumnFooterHeight()),
            (c.rtl = !1),
            (c.gridHeight = 0),
            (c.gridWidth = 0),
            (c.columnBuilders = []),
            (c.rowBuilders = []),
            (c.rowsProcessors = []),
            (c.columnsProcessors = []),
            (c.styleComputations = []),
            (c.viewportAdjusters = []),
            (c.rowHeaderColumns = []),
            (c.dataChangeCallbacks = {}),
            (c.verticalScrollSyncCallBackFns = {}),
            (c.horizontalScrollSyncCallBackFns = {}),
            (c.renderContainers = {}),
            (c.renderContainers.body = new l("body", c)),
            (c.cellValueGetterCache = {}),
            (c.getRowTemplateFn = null),
            (c.rows = []),
            (c.columns = []),
            (c.isScrollingVertically = !1),
            (c.isScrollingHorizontally = !1),
            (c.scrollDirection = e.scrollDirection.NONE),
            (c.disableScrolling = !1);
          var h = d.debounce(g, c.options.scrollDebounce),
            k = d.debounce(g, 0),
            n = d.debounce(m, c.options.scrollDebounce),
            o = d.debounce(m, 0);
          (c.flagScrollingVertically = function (a) {
            c.isScrollingVertically ||
              c.isScrollingHorizontally ||
              c.api.core.raise.scrollBegin(a),
              (c.isScrollingVertically = !0),
              0 !== c.options.scrollDebounce && a.withDelay ? h(a) : k(a);
          }),
            (c.flagScrollingHorizontally = function (a) {
              c.isScrollingVertically ||
                c.isScrollingHorizontally ||
                c.api.core.raise.scrollBegin(a),
                (c.isScrollingHorizontally = !0),
                0 !== c.options.scrollDebounce && a.withDelay ? n(a) : o(a);
            }),
            (c.scrollbarHeight = 0),
            (c.scrollbarWidth = 0),
            c.options.enableHorizontalScrollbar === e.scrollbars.ALWAYS &&
              (c.scrollbarHeight = d.getScrollbarWidth()),
            c.options.enableVerticalScrollbar === e.scrollbars.ALWAYS &&
              (c.scrollbarWidth = d.getScrollbarWidth()),
            (c.api = new i(c)),
            c.api.registerMethod("core", "refresh", this.refresh),
            c.api.registerMethod(
              "core",
              "queueGridRefresh",
              this.queueGridRefresh
            ),
            c.api.registerMethod("core", "refreshRows", this.refreshRows),
            c.api.registerMethod("core", "queueRefresh", this.queueRefresh),
            c.api.registerMethod(
              "core",
              "handleWindowResize",
              this.handleWindowResize
            ),
            c.api.registerMethod(
              "core",
              "addRowHeaderColumn",
              this.addRowHeaderColumn
            ),
            c.api.registerMethod("core", "scrollToIfNecessary", function (
              a,
              b
            ) {
              return c.scrollToIfNecessary(a, b);
            }),
            c.api.registerMethod("core", "scrollTo", function (a, b) {
              return c.scrollTo(a, b);
            }),
            c.api.registerMethod(
              "core",
              "registerRowsProcessor",
              this.registerRowsProcessor
            ),
            c.api.registerMethod(
              "core",
              "registerColumnsProcessor",
              this.registerColumnsProcessor
            ),
            c.api.registerMethod("core", "sortHandleNulls", j.handleNulls),
            c.api.registerEvent("core", "sortChanged"),
            c.api.registerEvent("core", "columnVisibilityChanged"),
            c.api.registerMethod(
              "core",
              "notifyDataChange",
              this.notifyDataChange
            ),
            c.api.registerMethod(
              "core",
              "clearAllFilters",
              this.clearAllFilters
            ),
            c.registerDataChangeCallback(c.columnRefreshCallback, [
              e.dataChange.COLUMN,
            ]),
            c.registerDataChangeCallback(c.processRowsCallback, [
              e.dataChange.EDIT,
            ]),
            c.registerDataChangeCallback(c.updateFooterHeightCallback, [
              e.dataChange.OPTIONS,
            ]),
            c.registerStyleComputation({
              priority: 10,
              func: c.getFooterStyles,
            });
        };
        (o.prototype.calcFooterHeight = function () {
          if (!this.hasFooter()) return 0;
          var a = 0;
          return (
            this.options.showGridFooter && (a += this.options.gridFooterHeight),
            (a += this.calcColumnFooterHeight())
          );
        }),
          (o.prototype.calcColumnFooterHeight = function () {
            var a = 0;
            return (
              this.options.showColumnFooter &&
                (a += this.options.columnFooterHeight),
              a
            );
          }),
          (o.prototype.getFooterStyles = function () {
            var a =
              ".grid" +
              this.id +
              " .ui-grid-footer-aggregates-row { height: " +
              this.options.columnFooterHeight +
              "px; }";
            return (a +=
              " .grid" +
              this.id +
              " .ui-grid-footer-info { height: " +
              this.options.gridFooterHeight +
              "px; }");
          }),
          (o.prototype.hasFooter = function () {
            return this.options.showGridFooter || this.options.showColumnFooter;
          }),
          (o.prototype.isRTL = function () {
            return this.rtl;
          }),
          (o.prototype.registerColumnBuilder = function (b) {
            this.columnBuilders.push(b);
          }),
          (o.prototype.buildColumnDefsFromData = function (a) {
            this.options.columnDefs = d.getColumnsFromData(
              a,
              this.options.excludeProperties
            );
          }),
          (o.prototype.registerRowBuilder = function (b) {
            this.rowBuilders.push(b);
          }),
          (o.prototype.registerDataChangeCallback = function (b, c, f) {
            var g = d.nextUid();
            c || (c = [e.dataChange.ALL]),
              Array.isArray(c) ||
                d.logError(
                  "Expected types to be an array or null in registerDataChangeCallback, value passed was: " +
                    c
                ),
              (this.dataChangeCallbacks[g] = {
                callback: b,
                types: c,
                _this: f,
              });
            var h = this,
              i = function () {
                delete h.dataChangeCallbacks[g];
              };
            return i;
          }),
          (o.prototype.callDataChangeCallbacks = function (b, c) {
            angular.forEach(
              this.dataChangeCallbacks,
              function (a, c) {
                (a.types.indexOf(e.dataChange.ALL) === -1 &&
                  a.types.indexOf(b) === -1 &&
                  b !== e.dataChange.ALL) ||
                  (a._this
                    ? a.callback.apply(a._this, this)
                    : a.callback(this));
              },
              this
            );
          }),
          (o.prototype.notifyDataChange = function (b) {
            var c = e.dataChange;
            b === c.ALL ||
            b === c.COLUMN ||
            b === c.EDIT ||
            b === c.ROW ||
            b === c.OPTIONS
              ? this.callDataChangeCallbacks(b)
              : d.logError(
                  "Notified of a data change, but the type was not recognised, so no action taken, type was: " +
                    b
                );
          }),
          (o.prototype.columnRefreshCallback = function (b) {
            b.buildColumns(), b.queueGridRefresh();
          }),
          (o.prototype.processRowsCallback = function (b) {
            b.queueGridRefresh();
          }),
          (o.prototype.updateFooterHeightCallback = function (b) {
            (b.footerHeight = b.calcFooterHeight()),
              (b.columnFooterHeight = b.calcColumnFooterHeight());
          }),
          (o.prototype.getColumn = function (b) {
            var c = this.columns.filter(function (a) {
              return a.colDef.name === b;
            });
            return c.length > 0 ? c[0] : null;
          }),
          (o.prototype.getColDef = function (b) {
            var c = this.options.columnDefs.filter(function (a) {
              return a.name === b;
            });
            return c.length > 0 ? c[0] : null;
          }),
          (o.prototype.assignTypes = function () {
            var a = this;
            a.options.columnDefs.forEach(function (b, c) {
              if (!b.type) {
                var e = new g(b, c, a),
                  f = a.rows.length > 0 ? a.rows[0] : null;
                f
                  ? (b.type = d.guessType(a.getCellValue(f, e)))
                  : (b.type = "string");
              }
            });
          }),
          (o.prototype.isRowHeaderColumn = function (b) {
            return this.rowHeaderColumns.indexOf(b) !== -1;
          }),
          (o.prototype.addRowHeaderColumn = function (b, c) {
            var e = this;
            void 0 === c && (c = 0);
            var f = new g(b, d.nextUid(), e);
            (f.isRowHeader = !0),
              e.isRTL()
                ? (e.createRightContainer(), (f.renderContainer = "right"))
                : (e.createLeftContainer(), (f.renderContainer = "left")),
              e.columnBuilders[0](b, f, e.options).then(function () {
                (f.enableFiltering = !1),
                  (f.enableSorting = !1),
                  (f.enableHiding = !1),
                  (f.headerPriority = c),
                  e.rowHeaderColumns.push(f),
                  (e.rowHeaderColumns = e.rowHeaderColumns.sort(function (
                    a,
                    b
                  ) {
                    return a.headerPriority - b.headerPriority;
                  })),
                  e.buildColumns().then(function () {
                    e.preCompileCellTemplates(), e.queueGridRefresh();
                  });
              });
          }),
          (o.prototype.getOnlyDataColumns = function () {
            var b = this,
              c = [];
            return (
              b.columns.forEach(function (a) {
                b.rowHeaderColumns.indexOf(a) === -1 && c.push(a);
              }),
              c
            );
          }),
          (o.prototype.buildColumns = function (c) {
            var e = { orderByColumnDefs: !1 };
            angular.extend(e, c);
            var j,
              f = this,
              h = [],
              i = f.rowHeaderColumns.length;
            for (j = 0; j < f.columns.length; j++)
              f.getColDef(f.columns[j].name) || (f.columns.splice(j, 1), j--);
            for (var k = f.rowHeaderColumns.length - 1; k >= 0; k--)
              f.columns.unshift(f.rowHeaderColumns[k]);
            if (
              (f.options.columnDefs.forEach(function (a, b) {
                f.preprocessColDef(a);
                var c = f.getColumn(a.name);
                c
                  ? c.updateColumnDef(a, !1)
                  : ((c = new g(a, d.nextUid(), f)),
                    f.columns.splice(b + i, 0, c)),
                  f.columnBuilders.forEach(function (b) {
                    h.push(b.call(f, a, c, f.options));
                  });
              }),
              e.orderByColumnDefs)
            ) {
              var l = f.columns.slice(0),
                m = Math.min(f.options.columnDefs.length, f.columns.length);
              for (j = 0; j < m; j++)
                f.columns[j + i].name !== f.options.columnDefs[j].name
                  ? (l[j + i] = f.getColumn(f.options.columnDefs[j].name))
                  : (l[j + i] = f.columns[j + i]);
              (f.columns.length = 0),
                Array.prototype.splice.apply(f.columns, [0, 0].concat(l));
            }
            return a.all(h).then(function () {
              f.rows.length > 0 && f.assignTypes();
            });
          }),
          (o.prototype.preCompileCellTemplate = function (a) {
            var c = this,
              d = a.cellTemplate.replace(
                e.MODEL_COL_FIELD,
                c.getQualifiedColField(a)
              );
            d = d.replace(e.COL_FIELD, "grid.getCellValue(row, col)");
            var f = b(d);
            (a.compiledElementFn = f),
              a.compiledElementFnDefer &&
                a.compiledElementFnDefer.resolve(a.compiledElementFn);
          }),
          (o.prototype.preCompileCellTemplates = function () {
            var a = this;
            a.columns.forEach(function (b) {
              b.cellTemplate
                ? a.preCompileCellTemplate(b)
                : b.cellTemplatePromise &&
                  b.cellTemplatePromise.then(function () {
                    a.preCompileCellTemplate(b);
                  });
            });
          }),
          (o.prototype.getQualifiedColField = function (a) {
            var b = "row.entity";
            return a.field === e.ENTITY_BINDING
              ? b
              : d.preEval(b + "." + a.field);
          }),
          (o.prototype.createLeftContainer = function () {
            this.hasLeftContainer() ||
              (this.renderContainers.left = new l("left", this, {
                disableColumnOffset: !0,
              }));
          }),
          (o.prototype.createRightContainer = function () {
            this.hasRightContainer() ||
              (this.renderContainers.right = new l("right", this, {
                disableColumnOffset: !0,
              }));
          }),
          (o.prototype.hasLeftContainer = function () {
            return void 0 !== this.renderContainers.left;
          }),
          (o.prototype.hasRightContainer = function () {
            return void 0 !== this.renderContainers.right;
          }),
          (o.prototype.preprocessColDef = function (b) {
            var c = this;
            if (!b.field && !b.name)
              throw new Error(
                "colDef.name or colDef.field property is required"
              );
            if (void 0 === b.name && void 0 !== b.field) {
              for (var d = b.field, e = 2; c.getColumn(d); )
                (d = b.field + e.toString()), e++;
              b.name = d;
            }
          }),
          (o.prototype.newInN = function (b, c, d, e) {
            for (var f = this, g = [], h = 0; h < c.length; h++) {
              for (
                var i = e ? c[h][e] : c[h], j = !1, k = 0;
                k < b.length;
                k++
              ) {
                var l = d ? b[k][d] : b[k];
                if (f.options.rowEquality(i, l)) {
                  j = !0;
                  break;
                }
              }
              j || g.push(i);
            }
            return g;
          }),
          (o.prototype.getRow = function (b, c) {
            var d = this;
            c = "undefined" == typeof c ? d.rows : c;
            var e = c.filter(function (a) {
              return d.options.rowEquality(a.entity, b);
            });
            return e.length > 0 ? e[0] : null;
          }),
          (o.prototype.modifyRows = function (c) {
            var d = this,
              e = d.rows.slice(0),
              f = d.rowHashMap || d.createRowHashMap();
            (d.rowHashMap = d.createRowHashMap()),
              (d.rows.length = 0),
              c.forEach(function (a, b) {
                var c, g;
                (g = d.options.enableRowHashing ? f.get(a) : d.getRow(a, e)),
                  g && ((c = g), (c.entity = a)),
                  c || (c = d.processRowBuilders(new h(a, b, d))),
                  d.rows.push(c),
                  d.rowHashMap.put(a, c);
              }),
              d.assignTypes();
            var g = a.when(d.processRowsProcessors(d.rows)).then(function (a) {
                return d.setVisibleRows(a);
              }),
              i = a
                .when(d.processColumnsProcessors(d.columns))
                .then(function (a) {
                  return d.setVisibleColumns(a);
                });
            return a.all([g, i]);
          }),
          (o.prototype.addRows = function (b) {
            for (var c = this, d = c.rows.length, e = 0; e < b.length; e++) {
              var f = c.processRowBuilders(new h(b[e], e + d, c));
              if (c.options.enableRowHashing) {
                var g = c.rowHashMap.get(f.entity);
                g && (g.row = f);
              }
              c.rows.push(f);
            }
          }),
          (o.prototype.processRowBuilders = function (b) {
            var c = this;
            return (
              c.rowBuilders.forEach(function (a) {
                a.call(c, b, c.options);
              }),
              b
            );
          }),
          (o.prototype.registerStyleComputation = function (b) {
            this.styleComputations.push(b);
          }),
          (o.prototype.registerRowsProcessor = function (b, c) {
            if (!angular.isFunction(b))
              throw "Attempt to register non-function rows processor: " + b;
            this.rowsProcessors.push({ processor: b, priority: c }),
              this.rowsProcessors.sort(function (b, c) {
                return b.priority - c.priority;
              });
          }),
          (o.prototype.removeRowsProcessor = function (b) {
            var c = -1;
            this.rowsProcessors.forEach(function (a, d) {
              a.processor === b && (c = d);
            }),
              c !== -1 && this.rowsProcessors.splice(c, 1);
          }),
          (o.prototype.processRowsProcessors = function (c) {
            function h(b, c) {
              var e = d.rowsProcessors[b].processor;
              return a.when(e.call(d, c, d.columns)).then(function (c) {
                if (!c)
                  throw (
                    "Processor at index " +
                    b +
                    " did not return a set of renderable rows"
                  );
                if (!angular.isArray(c))
                  throw "Processor at index " + b + " did not return an array";
                return (
                  b++,
                  b <= d.rowsProcessors.length - 1 ? h(b, c) : void g.resolve(c)
                );
              });
            }
            var d = this,
              e = c.slice(0);
            if (0 === d.rowsProcessors.length) return a.when(e);
            var g = a.defer();
            return h(0, e), g.promise;
          }),
          (o.prototype.setVisibleRows = function (b) {
            var c = this;
            for (var d in c.renderContainers) {
              var e = c.renderContainers[d];
              (e.canvasHeightShouldUpdate = !0),
                "undefined" == typeof e.visibleRowCache
                  ? (e.visibleRowCache = [])
                  : (e.visibleRowCache.length = 0);
            }
            for (var f = 0; f < b.length; f++) {
              var g = b[f],
                h =
                  "undefined" != typeof g.renderContainer && g.renderContainer
                    ? g.renderContainer
                    : "body";
              g.visible && c.renderContainers[h].visibleRowCache.push(g);
            }
            c.api.core.raise.rowsVisibleChanged(this.api),
              c.api.core.raise.rowsRendered(this.api);
          }),
          (o.prototype.registerColumnsProcessor = function (b, c) {
            if (!angular.isFunction(b))
              throw "Attempt to register non-function rows processor: " + b;
            this.columnsProcessors.push({ processor: b, priority: c }),
              this.columnsProcessors.sort(function (b, c) {
                return b.priority - c.priority;
              });
          }),
          (o.prototype.removeColumnsProcessor = function (b) {
            var c = this.columnsProcessors.indexOf(b);
            "undefined" != typeof c &&
              void 0 !== c &&
              this.columnsProcessors.splice(c, 1);
          }),
          (o.prototype.processColumnsProcessors = function (c) {
            function h(b, c) {
              var f = d.columnsProcessors[b].processor;
              return a.when(f.call(d, c, d.rows)).then(function (c) {
                if (!c)
                  throw (
                    "Processor at index " +
                    b +
                    " did not return a set of renderable rows"
                  );
                if (!angular.isArray(c))
                  throw "Processor at index " + b + " did not return an array";
                return (
                  b++,
                  b <= d.columnsProcessors.length - 1
                    ? h(b, e)
                    : void g.resolve(e)
                );
              });
            }
            var d = this,
              e = c.slice(0);
            if (0 === d.columnsProcessors.length) return a.when(e);
            var g = a.defer();
            return h(0, e), g.promise;
          }),
          (o.prototype.setVisibleColumns = function (b) {
            var c = this;
            for (var d in c.renderContainers) {
              var e = c.renderContainers[d];
              e.visibleColumnCache.length = 0;
            }
            for (var f = 0; f < b.length; f++) {
              var g = b[f];
              g.visible &&
                ("undefined" != typeof g.renderContainer && g.renderContainer
                  ? c.renderContainers[
                      g.renderContainer
                    ].visibleColumnCache.push(g)
                  : c.renderContainers.body.visibleColumnCache.push(g));
            }
          }),
          (o.prototype.handleWindowResize = function (b) {
            var c = this;
            return (
              (c.gridWidth = d.elementWidth(c.element)),
              (c.gridHeight = d.elementHeight(c.element)),
              c.queueRefresh()
            );
          }),
          (o.prototype.queueRefresh = function () {
            var b = this;
            return (
              b.refreshCanceller && m.cancel(b.refreshCanceller),
              (b.refreshCanceller = m(function () {
                b.refreshCanvas(!0);
              })),
              b.refreshCanceller.then(function () {
                b.refreshCanceller = null;
              }),
              b.refreshCanceller
            );
          }),
          (o.prototype.queueGridRefresh = function () {
            var b = this;
            return (
              b.gridRefreshCanceller && m.cancel(b.gridRefreshCanceller),
              (b.gridRefreshCanceller = m(function () {
                b.refresh(!0);
              })),
              b.gridRefreshCanceller.then(function () {
                b.gridRefreshCanceller = null;
              }),
              b.gridRefreshCanceller
            );
          }),
          (o.prototype.updateCanvasHeight = function () {
            var b = this;
            for (var c in b.renderContainers)
              if (b.renderContainers.hasOwnProperty(c)) {
                var d = b.renderContainers[c];
                d.canvasHeightShouldUpdate = !0;
              }
          }),
          (o.prototype.buildStyles = function () {
            var b = this;
            (b.customStyles = ""),
              b.styleComputations
                .sort(function (a, b) {
                  return null === a.priority
                    ? 1
                    : null === b.priority
                    ? -1
                    : null === a.priority && null === b.priority
                    ? 0
                    : a.priority - b.priority;
                })
                .forEach(function (a) {
                  var c = a.func.call(b);
                  angular.isString(c) && (b.customStyles += "\n" + c);
                });
          }),
          (o.prototype.minColumnsToRender = function () {
            var b = this,
              c = this.getViewportWidth(),
              d = 0,
              e = 0;
            return (
              b.columns.forEach(function (a, f) {
                if (e < c) (e += a.drawnWidth), d++;
                else {
                  for (var g = 0, h = f; h >= f - d; h--)
                    g += b.columns[h].drawnWidth;
                  g < c && d++;
                }
              }),
              d
            );
          }),
          (o.prototype.getBodyHeight = function () {
            var b = this.getViewportHeight();
            return b;
          }),
          (o.prototype.getViewportHeight = function () {
            var b = this,
              c = this.gridHeight - this.headerHeight - this.footerHeight,
              d = b.getViewportAdjustment();
            return (c += d.height);
          }),
          (o.prototype.getViewportWidth = function () {
            var b = this,
              c = this.gridWidth,
              d = b.getViewportAdjustment();
            return (c += d.width);
          }),
          (o.prototype.getHeaderViewportWidth = function () {
            var b = this.getViewportWidth();
            return b;
          }),
          (o.prototype.addVerticalScrollSync = function (a, b) {
            this.verticalScrollSyncCallBackFns[a] = b;
          }),
          (o.prototype.addHorizontalScrollSync = function (a, b) {
            this.horizontalScrollSyncCallBackFns[a] = b;
          }),
          (o.prototype.scrollContainers = function (a, b) {
            if (b.y) {
              var c = ["body", "left", "right"];
              this.flagScrollingVertically(b),
                "body" === a
                  ? (c = ["left", "right"])
                  : "left" === a
                  ? (c = ["body", "right"])
                  : "right" === a && (c = ["body", "left"]);
              for (var d = 0; d < c.length; d++) {
                var e = c[d];
                this.verticalScrollSyncCallBackFns[e] &&
                  this.verticalScrollSyncCallBackFns[e](b);
              }
            }
            if (b.x) {
              var f = ["body", "bodyheader", "bodyfooter"];
              this.flagScrollingHorizontally(b),
                "body" === a && (f = ["bodyheader", "bodyfooter"]);
              for (var g = 0; g < f.length; g++) {
                var h = f[g];
                this.horizontalScrollSyncCallBackFns[h] &&
                  this.horizontalScrollSyncCallBackFns[h](b);
              }
            }
          }),
          (o.prototype.registerViewportAdjuster = function (b) {
            this.viewportAdjusters.push(b);
          }),
          (o.prototype.removeViewportAdjuster = function (b) {
            var c = this.viewportAdjusters.indexOf(b);
            "undefined" != typeof c &&
              void 0 !== c &&
              this.viewportAdjusters.splice(c, 1);
          }),
          (o.prototype.getViewportAdjustment = function () {
            var b = this,
              c = { height: 0, width: 0 };
            return (
              b.viewportAdjusters.forEach(function (a) {
                c = a.call(this, c);
              }),
              c
            );
          }),
          (o.prototype.getVisibleRowCount = function () {
            return this.renderContainers.body.visibleRowCache.length;
          }),
          (o.prototype.getVisibleRows = function () {
            return this.renderContainers.body.visibleRowCache;
          }),
          (o.prototype.getVisibleColumnCount = function () {
            return this.renderContainers.body.visibleColumnCache.length;
          }),
          (o.prototype.searchRows = function (b) {
            return k.search(this, b, this.columns);
          }),
          (o.prototype.sortByColumn = function (b) {
            return j.sort(this, b, this.columns);
          }),
          (o.prototype.getCellValue = function (b, d) {
            return "undefined" != typeof b.entity["$$" + d.uid]
              ? b.entity["$$" + d.uid].rendered
              : this.options.flatEntityAccess && "undefined" != typeof d.field
              ? b.entity[d.field]
              : (d.cellValueGetterCache ||
                  (d.cellValueGetterCache = c(b.getEntityQualifiedColField(d))),
                d.cellValueGetterCache(b));
          }),
          (o.prototype.getCellDisplayValue = function (b, d) {
            if (!d.cellDisplayGetterCache) {
              var e = d.cellFilter ? " | " + d.cellFilter : "";
              "undefined" != typeof b.entity["$$" + d.uid]
                ? (d.cellDisplayGetterCache = c(
                    b.entity["$$" + d.uid].rendered + e
                  ))
                : this.options.flatEntityAccess && "undefined" != typeof d.field
                ? (d.cellDisplayGetterCache = c(b.entity[d.field] + e))
                : (d.cellDisplayGetterCache = c(
                    b.getEntityQualifiedColField(d) + e
                  ));
            }
            return d.cellDisplayGetterCache(b);
          }),
          (o.prototype.getNextColumnSortPriority = function () {
            var b = this,
              c = 0;
            return (
              b.columns.forEach(function (a) {
                a.sort &&
                  void 0 !== a.sort.priority &&
                  a.sort.priority >= c &&
                  (c = a.sort.priority + 1);
              }),
              c
            );
          }),
          (o.prototype.resetColumnSorting = function (b) {
            var c = this;
            c.columns.forEach(function (a) {
              a === b || a.suppressRemoveSort || (a.sort = {});
            });
          }),
          (o.prototype.getColumnSorting = function () {
            var d,
              b = this,
              c = [];
            return (
              (d = b.columns.slice(0)),
              d.sort(j.prioritySort).forEach(function (a) {
                a.sort &&
                  "undefined" != typeof a.sort.direction &&
                  a.sort.direction &&
                  (a.sort.direction === e.ASC || a.sort.direction === e.DESC) &&
                  c.push(a);
              }),
              c
            );
          }),
          (o.prototype.sortColumn = function (c, d, e) {
            var f = this,
              g = null;
            if ("undefined" == typeof c || !c)
              throw new Error("No column parameter provided");
            if (
              ("boolean" == typeof d ? (e = d) : (g = d),
              e
                ? void 0 === c.sort.priority &&
                  (c.sort.priority = f.getNextColumnSortPriority())
                : (f.resetColumnSorting(c),
                  (c.sort.priority = void 0),
                  (c.sort.priority = f.getNextColumnSortPriority())),
              g)
            )
              c.sort.direction = g;
            else {
              var h = c.sortDirectionCycle.indexOf(
                c.sort.direction ? c.sort.direction : null
              );
              (h = (h + 1) % c.sortDirectionCycle.length),
                c.colDef &&
                  c.suppressRemoveSort &&
                  !c.sortDirectionCycle[h] &&
                  (h = (h + 1) % c.sortDirectionCycle.length),
                c.sortDirectionCycle[h]
                  ? (c.sort.direction = c.sortDirectionCycle[h])
                  : p(c, f);
            }
            return (
              f.api.core.raise.sortChanged(f, f.getColumnSorting()), a.when(c)
            );
          });
        var p = function (b, c) {
          c.columns.forEach(function (a) {
            a.sort &&
              void 0 !== a.sort.priority &&
              a.sort.priority > b.sort.priority &&
              (a.sort.priority -= 1);
          }),
            (b.sort = {});
        };
        return (
          (o.prototype.renderingComplete = function () {
            angular.isFunction(this.options.onRegisterApi) &&
              this.options.onRegisterApi(this.api),
              this.api.core.raise.renderingComplete(this.api);
          }),
          (o.prototype.createRowHashMap = function () {
            var b = this,
              c = new q();
            return (c.grid = b), c;
          }),
          (o.prototype.refresh = function (c) {
            var d = this,
              e = d.processRowsProcessors(d.rows).then(function (a) {
                d.setVisibleRows(a);
              }),
              f = d.processColumnsProcessors(d.columns).then(function (a) {
                d.setVisibleColumns(a);
              });
            return a.all([e, f]).then(function () {
              d.redrawInPlace(c), d.refreshCanvas(!0);
            });
          }),
          (o.prototype.refreshRows = function () {
            var b = this;
            return b.processRowsProcessors(b.rows).then(function (a) {
              b.setVisibleRows(a), b.redrawInPlace(), b.refreshCanvas(!0);
            });
          }),
          (o.prototype.refreshCanvas = function (b) {
            var c = this;
            b && c.buildStyles();
            var e = a.defer(),
              f = [];
            for (var g in c.renderContainers)
              if (c.renderContainers.hasOwnProperty(g)) {
                var h = c.renderContainers[g];
                if (null === h.canvasWidth || isNaN(h.canvasWidth)) continue;
                (h.header || h.headerCanvas) &&
                  ((h.explicitHeaderHeight = h.explicitHeaderHeight || null),
                  (h.explicitHeaderCanvasHeight =
                    h.explicitHeaderCanvasHeight || null),
                  f.push(h));
              }
            return (
              f.length > 0
                ? (b && c.buildStyles(),
                  m(function () {
                    var i,
                      j,
                      a = !1,
                      g = 0,
                      h = 0,
                      k = function (b, c) {
                        return b !== c && (a = !0), c;
                      };
                    for (i = 0; i < f.length; i++)
                      if (
                        ((j = f[i]),
                        null !== j.canvasWidth && !isNaN(j.canvasWidth))
                      ) {
                        if (j.header) {
                          var l = (j.headerHeight = k(
                              j.headerHeight,
                              parseInt(d.outerElementHeight(j.header), 10)
                            )),
                            m = d.getBorderSize(j.header, "top"),
                            n = d.getBorderSize(j.header, "bottom"),
                            o = parseInt(l - m - n, 10);
                          (o = o < 0 ? 0 : o),
                            (j.innerHeaderHeight = o),
                            !j.explicitHeaderHeight && o > g && (g = o);
                        }
                        if (j.headerCanvas) {
                          var p = (j.headerCanvasHeight = k(
                            j.headerCanvasHeight,
                            parseInt(d.outerElementHeight(j.headerCanvas), 10)
                          ));
                          !j.explicitHeaderCanvasHeight && p > h && (h = p);
                        }
                      }
                    for (i = 0; i < f.length; i++)
                      (j = f[i]),
                        g > 0 &&
                          "undefined" != typeof j.headerHeight &&
                          null !== j.headerHeight &&
                          (j.explicitHeaderHeight || j.headerHeight < g) &&
                          (j.explicitHeaderHeight = k(
                            j.explicitHeaderHeight,
                            g
                          )),
                        h > 0 &&
                          "undefined" != typeof j.headerCanvasHeight &&
                          null !== j.headerCanvasHeight &&
                          (j.explicitHeaderCanvasHeight ||
                            j.headerCanvasHeight < h) &&
                          (j.explicitHeaderCanvasHeight = k(
                            j.explicitHeaderCanvasHeight,
                            h
                          ));
                    b && a && c.buildStyles(), e.resolve();
                  }))
                : m(function () {
                    e.resolve();
                  }),
              e.promise
            );
          }),
          (o.prototype.redrawInPlace = function (b) {
            var c = this;
            for (var d in c.renderContainers) {
              var e = c.renderContainers[d];
              b
                ? (e.adjustRows(e.prevScrollTop, null),
                  e.adjustColumns(e.prevScrollLeft, null))
                : (e.adjustRows(null, e.prevScrolltopPercentage),
                  e.adjustColumns(null, e.prevScrollleftPercentage));
            }
          }),
          (o.prototype.hasLeftContainerColumns = function () {
            return (
              this.hasLeftContainer() &&
              this.renderContainers.left.renderedColumns.length > 0
            );
          }),
          (o.prototype.hasRightContainerColumns = function () {
            return (
              this.hasRightContainer() &&
              this.renderContainers.right.renderedColumns.length > 0
            );
          }),
          (o.prototype.scrollToIfNecessary = function (b, c) {
            var d = this,
              e = new n(d, "uiGrid.scrollToIfNecessary"),
              f = d.renderContainers.body.visibleRowCache,
              g = d.renderContainers.body.visibleColumnCache,
              h = d.renderContainers.body.prevScrollTop + d.headerHeight;
            h = h < 0 ? 0 : h;
            var i = d.renderContainers.body.prevScrollLeft,
              j =
                d.renderContainers.body.prevScrollTop +
                d.gridHeight -
                d.renderContainers.body.headerHeight -
                d.footerHeight -
                d.scrollbarWidth,
              k =
                d.renderContainers.body.prevScrollLeft +
                Math.ceil(d.renderContainers.body.getViewportWidth());
            if (null !== b) {
              var l = f.indexOf(b),
                m =
                  d.renderContainers.body.getCanvasHeight() -
                  d.renderContainers.body.getViewportHeight(),
                o = l * d.options.rowHeight + d.headerHeight;
              o = o < 0 ? 0 : o;
              var p, q;
              o < h
                ? ((p = d.renderContainers.body.prevScrollTop - (h - o)),
                  (q = p / m),
                  (e.y = { percentage: q }))
                : o > j &&
                  ((p = o - j + d.renderContainers.body.prevScrollTop),
                  (q = p / m),
                  (e.y = { percentage: q }));
            }
            if (null !== c) {
              for (
                var r = g.indexOf(c),
                  s =
                    d.renderContainers.body.getCanvasWidth() -
                    d.renderContainers.body.getViewportWidth(),
                  t = 0,
                  u = 0;
                u < r;
                u++
              ) {
                var v = g[u];
                t += v.drawnWidth;
              }
              t = t < 0 ? 0 : t;
              var w = t + c.drawnWidth;
              w = w < 0 ? 0 : w;
              var x, y;
              t < i
                ? ((x = d.renderContainers.body.prevScrollLeft - (i - t)),
                  (y = x / s),
                  (y = y > 1 ? 1 : y),
                  (e.x = { percentage: y }))
                : w > k &&
                  ((x = w - k + d.renderContainers.body.prevScrollLeft),
                  (y = x / s),
                  (y = y > 1 ? 1 : y),
                  (e.x = { percentage: y }));
            }
            var z = a.defer();
            if (e.y || e.x) {
              (e.withDelay = !1), d.scrollContainers("", e);
              var A = d.api.core.on.scrollEnd(null, function () {
                z.resolve(e), A();
              });
            } else z.resolve();
            return z.promise;
          }),
          (o.prototype.scrollTo = function (a, b) {
            var c = null,
              d = null;
            return (
              null !== a && "undefined" != typeof a && (c = this.getRow(a)),
              null !== b &&
                "undefined" != typeof b &&
                (d = this.getColumn(b.name ? b.name : b.field)),
              this.scrollToIfNecessary(c, d)
            );
          }),
          (o.prototype.clearAllFilters = function (b, c, d) {
            if (
              (void 0 === b && (b = !0),
              void 0 === c && (c = !1),
              void 0 === d && (d = !1),
              this.columns.forEach(function (a) {
                a.filters.forEach(function (a) {
                  (a.term = void 0),
                    c && (a.condition = void 0),
                    d && (a.flags = void 0);
                });
              }),
              b)
            )
              return this.refreshRows();
          }),
          (q.prototype = {
            put: function (a, b) {
              this[this.grid.options.rowIdentity(a)] = b;
            },
            get: function (a) {
              return this[this.grid.options.rowIdentity(a)];
            },
            remove: function (a) {
              var b = this[(a = this.grid.options.rowIdentity(a))];
              return delete this[a], b;
            },
          }),
          o
        );
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").factory("GridApi", [
      "$q",
      "$rootScope",
      "gridUtil",
      "uiGridConstants",
      "GridRow",
      "uiGridGridMenuService",
      function (a, b, c, d, e, f) {
        function h(a, c, d, e) {
          return b.$on(a, function (a) {
            var b = Array.prototype.slice.call(arguments);
            b.splice(0, 1), c.apply(e ? e : d.api, b);
          });
        }
        var g = function (b) {
          (this.grid = b),
            (this.listeners = []),
            this.registerEvent("core", "renderingComplete"),
            this.registerEvent("core", "filterChanged"),
            this.registerMethod(
              "core",
              "setRowInvisible",
              e.prototype.setRowInvisible
            ),
            this.registerMethod(
              "core",
              "clearRowInvisible",
              e.prototype.clearRowInvisible
            ),
            this.registerMethod(
              "core",
              "getVisibleRows",
              this.grid.getVisibleRows
            ),
            this.registerEvent("core", "rowsVisibleChanged"),
            this.registerEvent("core", "rowsRendered"),
            this.registerEvent("core", "scrollBegin"),
            this.registerEvent("core", "scrollEnd"),
            this.registerEvent("core", "canvasHeightChanged"),
            this.registerEvent("core", "gridDimensionChanged");
        };
        return (
          (g.prototype.suppressEvents = function (a, b) {
            var c = this,
              d = angular.isArray(a) ? a : [a],
              e = c.listeners.filter(function (a) {
                return d.some(function (b) {
                  return a.handler === b;
                });
              });
            e.forEach(function (a) {
              a.dereg();
            }),
              b(),
              e.forEach(function (a) {
                a.dereg = h(a.eventId, a.handler, c.grid, a._this);
              });
          }),
          (g.prototype.registerEvent = function (a, d) {
            var e = this;
            e[a] || (e[a] = {});
            var f = e[a];
            f.on || ((f.on = {}), (f.raise = {}));
            var g = e.grid.id + a + d;
            (f.raise[d] = function () {
              b.$emit.apply(
                b,
                [g].concat(Array.prototype.slice.call(arguments))
              );
            }),
              (f.on[d] = function (b, f, i) {
                if (null !== b && "undefined" == typeof b.$on)
                  return void c.logError(
                    "asked to listen on " +
                      a +
                      ".on." +
                      d +
                      " but scope wasn't passed in the input parameters.  It is legitimate to pass null, but you've passed something else, so you probably forgot to provide scope rather than did it deliberately, not registering"
                  );
                var j = h(g, f, e.grid, i),
                  k = { handler: f, dereg: j, eventId: g, scope: b, _this: i };
                e.listeners.push(k);
                var l = function () {
                  k.dereg();
                  var a = e.listeners.indexOf(k);
                  e.listeners.splice(a, 1);
                };
                return (
                  b &&
                    b.$on("$destroy", function () {
                      l();
                    }),
                  l
                );
              });
          }),
          (g.prototype.registerEventsFromObject = function (a) {
            var b = this,
              c = [];
            angular.forEach(a, function (a, b) {
              var d = { name: b, events: [] };
              angular.forEach(a, function (a, b) {
                d.events.push(b);
              }),
                c.push(d);
            }),
              c.forEach(function (a) {
                a.events.forEach(function (c) {
                  b.registerEvent(a.name, c);
                });
              });
          }),
          (g.prototype.registerMethod = function (a, b, d, e) {
            this[a] || (this[a] = {});
            var f = this[a];
            f[b] = c.createBoundedWrapper(e || this.grid, d);
          }),
          (g.prototype.registerMethodsFromObject = function (a, b) {
            var c = this,
              d = [];
            angular.forEach(a, function (a, b) {
              var c = { name: b, methods: [] };
              angular.forEach(a, function (a, b) {
                c.methods.push({ name: b, fn: a });
              }),
                d.push(c);
            }),
              d.forEach(function (a) {
                a.methods.forEach(function (d) {
                  c.registerMethod(a.name, d.name, d.fn, b);
                });
              });
          }),
          g
        );
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").factory("GridColumn", [
      "gridUtil",
      "uiGridConstants",
      "i18nService",
      function (a, b, c) {
        function d(a, c, d) {
          var e = this;
          (e.grid = d),
            (e.uid = c),
            e.updateColumnDef(a, !0),
            (e.aggregationValue = void 0),
            (e.updateAggregationValue = function () {
              if (!e.aggregationType) return void (e.aggregationValue = void 0);
              var a = 0,
                c = e.grid.getVisibleRows(),
                d = function () {
                  var a = [];
                  return (
                    c.forEach(function (b) {
                      var c = e.grid.getCellValue(b, e),
                        d = Number(c);
                      isNaN(d) || a.push(d);
                    }),
                    a
                  );
                };
              angular.isFunction(e.aggregationType)
                ? (e.aggregationValue = e.aggregationType(c, e))
                : e.aggregationType === b.aggregationTypes.count
                ? (e.aggregationValue = e.grid.getVisibleRowCount())
                : e.aggregationType === b.aggregationTypes.sum
                ? (d().forEach(function (b) {
                    a += b;
                  }),
                  (e.aggregationValue = a))
                : e.aggregationType === b.aggregationTypes.avg
                ? (d().forEach(function (b) {
                    a += b;
                  }),
                  (a /= d().length),
                  (e.aggregationValue = a))
                : e.aggregationType === b.aggregationTypes.min
                ? (e.aggregationValue = Math.min.apply(null, d()))
                : e.aggregationType === b.aggregationTypes.max
                ? (e.aggregationValue = Math.max.apply(null, d()))
                : (e.aggregationValue = " ");
            }),
            (this.getAggregationValue = function () {
              return e.aggregationValue;
            });
        }
        return (
          (d.prototype.hideColumn = function () {
            this.colDef.visible = !1;
          }),
          (d.prototype.setPropertyOrDefault = function (a, b, c) {
            var d = this;
            "undefined" != typeof a[b] && a[b]
              ? (d[b] = a[b])
              : "undefined" != typeof d[b]
              ? (d[b] = d[b])
              : (d[b] = c ? c : {});
          }),
          (d.prototype.updateColumnDef = function (c, d) {
            var e = this;
            if (((e.colDef = c), void 0 === c.name))
              throw new Error(
                "colDef.name is required for column at index " +
                  e.grid.options.columnDefs.indexOf(c)
              );
            if (
              ((e.displayName =
                void 0 === c.displayName
                  ? a.readableColumnName(c.name)
                  : c.displayName),
              !angular.isNumber(e.width) ||
                !e.hasCustomWidth ||
                c.allowCustomWidthOverride)
            ) {
              var f = c.width,
                g =
                  "Cannot parse column width '" +
                  f +
                  "' for column named '" +
                  c.name +
                  "'";
              if (
                ((e.hasCustomWidth = !1),
                angular.isString(f) || angular.isNumber(f))
              )
                if (angular.isString(f))
                  if (a.endsWith(f, "%")) {
                    var h = f.replace(/%/g, ""),
                      i = parseInt(h, 10);
                    if (isNaN(i)) throw new Error(g);
                    e.width = f;
                  } else if (f.match(/^(\d+)$/))
                    e.width = parseInt(f.match(/^(\d+)$/)[1], 10);
                  else {
                    if (!f.match(/^\*+$/)) throw new Error(g);
                    e.width = f;
                  }
                else e.width = f;
              else e.width = "*";
            }
            ["minWidth", "maxWidth"].forEach(function (a) {
              var b = c[a],
                d =
                  "Cannot parse column " +
                  a +
                  " '" +
                  b +
                  "' for column named '" +
                  c.name +
                  "'";
              if (angular.isString(b) || angular.isNumber(b))
                if (angular.isString(b)) {
                  if (!b.match(/^(\d+)$/)) throw new Error(d);
                  e[a] = parseInt(b.match(/^(\d+)$/)[1], 10);
                } else e[a] = b;
              else e[a] = "minWidth" === a ? 30 : 9e3;
            }),
              (e.field = void 0 === c.field ? c.name : c.field),
              "string" != typeof e.field &&
                a.logError(
                  "Field is not a string, this is likely to break the code, Field is: " +
                    e.field
                ),
              (e.name = c.name),
              (e.displayName =
                void 0 === c.displayName
                  ? a.readableColumnName(c.name)
                  : c.displayName),
              (e.aggregationType = angular.isDefined(c.aggregationType)
                ? c.aggregationType
                : null),
              (e.footerCellTemplate = angular.isDefined(c.footerCellTemplate)
                ? c.footerCellTemplate
                : null),
              "undefined" == typeof c.cellTooltip || c.cellTooltip === !1
                ? (e.cellTooltip = !1)
                : c.cellTooltip === !0
                ? (e.cellTooltip = function (a, b) {
                    return e.grid.getCellValue(a, b);
                  })
                : "function" == typeof c.cellTooltip
                ? (e.cellTooltip = c.cellTooltip)
                : (e.cellTooltip = function (a, b) {
                    return b.colDef.cellTooltip;
                  }),
              "undefined" == typeof c.headerTooltip || c.headerTooltip === !1
                ? (e.headerTooltip = !1)
                : c.headerTooltip === !0
                ? (e.headerTooltip = function (a) {
                    return a.displayName;
                  })
                : "function" == typeof c.headerTooltip
                ? (e.headerTooltip = c.headerTooltip)
                : (e.headerTooltip = function (a) {
                    return a.colDef.headerTooltip;
                  }),
              (e.footerCellClass = c.footerCellClass),
              (e.cellClass = c.cellClass),
              (e.headerCellClass = c.headerCellClass),
              (e.cellFilter = c.cellFilter ? c.cellFilter : ""),
              (e.sortCellFiltered = !!c.sortCellFiltered),
              (e.filterCellFiltered = !!c.filterCellFiltered),
              (e.headerCellFilter = c.headerCellFilter
                ? c.headerCellFilter
                : ""),
              (e.footerCellFilter = c.footerCellFilter
                ? c.footerCellFilter
                : ""),
              (e.visible = a.isNullOrUndefined(c.visible) || c.visible),
              (e.headerClass = c.headerClass),
              (e.enableSorting =
                "undefined" != typeof c.enableSorting
                  ? c.enableSorting
                  : e.grid.options.enableSorting),
              (e.sortingAlgorithm = c.sortingAlgorithm),
              (e.sortDirectionCycle =
                "undefined" != typeof c.sortDirectionCycle
                  ? c.sortDirectionCycle
                  : [null, b.ASC, b.DESC]),
              "undefined" == typeof e.suppressRemoveSort &&
                (e.suppressRemoveSort =
                  "undefined" != typeof c.suppressRemoveSort &&
                  c.suppressRemoveSort),
              (e.enableFiltering =
                "undefined" == typeof c.enableFiltering || c.enableFiltering),
              e.setPropertyOrDefault(c, "menuItems", []),
              d && e.setPropertyOrDefault(c, "sort");
            var j = [];
            c.filter
              ? j.push(c.filter)
              : c.filters
              ? (j = c.filters)
              : j.push({}),
              d
                ? (e.setPropertyOrDefault(c, "filter"),
                  e.setPropertyOrDefault(c, "extraStyle"),
                  e.setPropertyOrDefault(c, "filters", j))
                : e.filters.length === j.length &&
                  e.filters.forEach(function (a, b) {
                    "undefined" != typeof j[b].placeholder &&
                      (a.placeholder = j[b].placeholder),
                      "undefined" != typeof j[b].ariaLabel &&
                        (a.ariaLabel = j[b].ariaLabel),
                      "undefined" != typeof j[b].flags &&
                        (a.flags = j[b].flags),
                      "undefined" != typeof j[b].type && (a.type = j[b].type),
                      "undefined" != typeof j[b].selectOptions &&
                        (a.selectOptions = j[b].selectOptions);
                  });
          }),
          (d.prototype.unsort = function () {
            (this.sort = {}),
              this.grid.api.core.raise.sortChanged(
                this.grid,
                this.grid.getColumnSorting()
              );
          }),
          (d.prototype.getColClass = function (a) {
            var c = b.COL_CLASS_PREFIX + this.uid;
            return a ? "." + c : c;
          }),
          (d.prototype.isPinnedLeft = function () {
            return "left" === this.renderContainer;
          }),
          (d.prototype.isPinnedRight = function () {
            return "right" === this.renderContainer;
          }),
          (d.prototype.getColClassDefinition = function () {
            return (
              " .grid" +
              this.grid.id +
              " " +
              this.getColClass(!0) +
              " { min-width: " +
              this.drawnWidth +
              "px; max-width: " +
              this.drawnWidth +
              "px; }"
            );
          }),
          (d.prototype.getRenderContainer = function () {
            var b = this,
              c = b.renderContainer;
            return (
              (null !== c && "" !== c && void 0 !== c) || (c = "body"),
              b.grid.renderContainers[c]
            );
          }),
          (d.prototype.showColumn = function () {
            this.colDef.visible = !0;
          }),
          (d.prototype.getAggregationText = function () {
            var a = this;
            if (a.colDef.aggregationHideLabel) return "";
            if (a.colDef.aggregationLabel) return a.colDef.aggregationLabel;
            switch (a.colDef.aggregationType) {
              case b.aggregationTypes.count:
                return c.getSafeText("aggregation.count");
              case b.aggregationTypes.sum:
                return c.getSafeText("aggregation.sum");
              case b.aggregationTypes.avg:
                return c.getSafeText("aggregation.avg");
              case b.aggregationTypes.min:
                return c.getSafeText("aggregation.min");
              case b.aggregationTypes.max:
                return c.getSafeText("aggregation.max");
              default:
                return "";
            }
          }),
          (d.prototype.getCellTemplate = function () {
            var a = this;
            return a.cellTemplatePromise;
          }),
          (d.prototype.getCompiledElementFn = function () {
            var a = this;
            return a.compiledElementFnDefer.promise;
          }),
          d
        );
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").factory("GridOptions", [
      "gridUtil",
      "uiGridConstants",
      function (a, b) {
        return {
          initialize: function (c) {
            return (
              (c.onRegisterApi = c.onRegisterApi || angular.noop()),
              (c.data = c.data || []),
              (c.columnDefs = c.columnDefs || []),
              (c.excludeProperties = c.excludeProperties || ["$$hashKey"]),
              (c.enableRowHashing = c.enableRowHashing !== !1),
              (c.rowIdentity =
                c.rowIdentity ||
                function (c) {
                  return a.hashKey(c);
                }),
              (c.getRowIdentity =
                c.getRowIdentity ||
                function (b) {
                  return b.$$hashKey;
                }),
              (c.flatEntityAccess = c.flatEntityAccess === !0),
              (c.showHeader =
                "undefined" == typeof c.showHeader || c.showHeader),
              c.showHeader
                ? (c.headerRowHeight =
                    "undefined" != typeof c.headerRowHeight
                      ? c.headerRowHeight
                      : 30)
                : (c.headerRowHeight = 0),
              "string" == typeof c.rowHeight
                ? (c.rowHeight = parseInt(c.rowHeight) || 30)
                : (c.rowHeight = c.rowHeight || 30),
              (c.minRowsToShow =
                "undefined" != typeof c.minRowsToShow ? c.minRowsToShow : 10),
              (c.showGridFooter = c.showGridFooter === !0),
              (c.showColumnFooter = c.showColumnFooter === !0),
              (c.columnFooterHeight =
                "undefined" != typeof c.columnFooterHeight
                  ? c.columnFooterHeight
                  : 30),
              (c.gridFooterHeight =
                "undefined" != typeof c.gridFooterHeight
                  ? c.gridFooterHeight
                  : 30),
              (c.columnWidth =
                "undefined" != typeof c.columnWidth ? c.columnWidth : 50),
              (c.maxVisibleColumnCount =
                "undefined" != typeof c.maxVisibleColumnCount
                  ? c.maxVisibleColumnCount
                  : 200),
              (c.virtualizationThreshold =
                "undefined" != typeof c.virtualizationThreshold
                  ? c.virtualizationThreshold
                  : 20),
              (c.columnVirtualizationThreshold =
                "undefined" != typeof c.columnVirtualizationThreshold
                  ? c.columnVirtualizationThreshold
                  : 10),
              (c.excessRows =
                "undefined" != typeof c.excessRows ? c.excessRows : 4),
              (c.scrollThreshold =
                "undefined" != typeof c.scrollThreshold
                  ? c.scrollThreshold
                  : 4),
              (c.excessColumns =
                "undefined" != typeof c.excessColumns ? c.excessColumns : 4),
              (c.horizontalScrollThreshold =
                "undefined" != typeof c.horizontalScrollThreshold
                  ? c.horizontalScrollThreshold
                  : 2),
              (c.aggregationCalcThrottle =
                "undefined" != typeof c.aggregationCalcThrottle
                  ? c.aggregationCalcThrottle
                  : 500),
              (c.wheelScrollThrottle =
                "undefined" != typeof c.wheelScrollThrottle
                  ? c.wheelScrollThrottle
                  : 70),
              (c.scrollDebounce =
                "undefined" != typeof c.scrollDebounce
                  ? c.scrollDebounce
                  : 300),
              (c.enableSorting = c.enableSorting !== !1),
              (c.enableFiltering = c.enableFiltering === !0),
              (c.enableColumnMenus = c.enableColumnMenus !== !1),
              (c.enableVerticalScrollbar =
                "undefined" != typeof c.enableVerticalScrollbar
                  ? c.enableVerticalScrollbar
                  : b.scrollbars.ALWAYS),
              (c.enableHorizontalScrollbar =
                "undefined" != typeof c.enableHorizontalScrollbar
                  ? c.enableHorizontalScrollbar
                  : b.scrollbars.ALWAYS),
              (c.enableMinHeightCheck = c.enableMinHeightCheck !== !1),
              (c.minimumColumnSize =
                "undefined" != typeof c.minimumColumnSize
                  ? c.minimumColumnSize
                  : 10),
              (c.rowEquality =
                c.rowEquality ||
                function (a, b) {
                  return a === b;
                }),
              (c.headerTemplate = c.headerTemplate || null),
              (c.footerTemplate = c.footerTemplate || "ui-grid/ui-grid-footer"),
              (c.gridFooterTemplate =
                c.gridFooterTemplate || "ui-grid/ui-grid-grid-footer"),
              (c.rowTemplate = c.rowTemplate || "ui-grid/ui-grid-row"),
              (c.gridMenuTemplate = c.gridMenuTemplate || "ui-grid/uiGridMenu"),
              (c.appScopeProvider = c.appScopeProvider || null),
              c
            );
          },
        };
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").factory("GridRenderContainer", [
      "gridUtil",
      "uiGridConstants",
      function (a, b) {
        function c(a, b, c) {
          var d = this;
          (d.name = a),
            (d.grid = b),
            (d.visibleRowCache = []),
            (d.visibleColumnCache = []),
            (d.renderedRows = []),
            (d.renderedColumns = []),
            (d.prevScrollTop = 0),
            (d.prevScrolltopPercentage = 0),
            (d.prevRowScrollIndex = 0),
            (d.prevScrollLeft = 0),
            (d.prevScrollleftPercentage = 0),
            (d.prevColumnScrollIndex = 0),
            (d.columnStyles = ""),
            (d.viewportAdjusters = []),
            (d.hasHScrollbar = !1),
            (d.hasVScrollbar = !1),
            (d.canvasHeightShouldUpdate = !0),
            (d.$$canvasHeight = 0),
            c && angular.isObject(c) && angular.extend(d, c),
            b.registerStyleComputation({
              priority: 5,
              func: function () {
                return d.updateColumnWidths(), d.columnStyles;
              },
            });
        }
        return (
          (c.prototype.reset = function () {
            (this.visibleColumnCache.length = 0),
              (this.visibleRowCache.length = 0),
              (this.renderedRows.length = 0),
              (this.renderedColumns.length = 0);
          }),
          (c.prototype.containsColumn = function (a) {
            return this.visibleColumnCache.indexOf(a) !== -1;
          }),
          (c.prototype.minRowsToRender = function () {
            for (
              var b = this,
                c = 0,
                d = 0,
                e = b.getViewportHeight(),
                f = b.visibleRowCache.length - 1;
              d < e && f >= 0;
              f--
            )
              (d += b.visibleRowCache[f].height), c++;
            return c;
          }),
          (c.prototype.minColumnsToRender = function () {
            for (
              var b = this, c = this.getViewportWidth(), d = 0, e = 0, f = 0;
              f < b.visibleColumnCache.length;
              f++
            ) {
              var g = b.visibleColumnCache[f];
              if (e < c) (e += g.drawnWidth ? g.drawnWidth : 0), d++;
              else {
                for (var h = 0, i = f; i >= f - d; i--)
                  h += b.visibleColumnCache[i].drawnWidth
                    ? b.visibleColumnCache[i].drawnWidth
                    : 0;
                h < c && d++;
              }
            }
            return d;
          }),
          (c.prototype.getVisibleRowCount = function () {
            return this.visibleRowCache.length;
          }),
          (c.prototype.registerViewportAdjuster = function (b) {
            this.viewportAdjusters.push(b);
          }),
          (c.prototype.removeViewportAdjuster = function (b) {
            var c = this.viewportAdjusters.indexOf(b);
            c > -1 && this.viewportAdjusters.splice(c, 1);
          }),
          (c.prototype.getViewportAdjustment = function () {
            var b = this,
              c = { height: 0, width: 0 };
            return (
              b.viewportAdjusters.forEach(function (a) {
                c = a.call(this, c);
              }),
              c
            );
          }),
          (c.prototype.getMargin = function (b) {
            var c = this,
              d = 0;
            return (
              c.viewportAdjusters.forEach(function (a) {
                var c = a.call(this, { height: 0, width: 0 });
                c.side && c.side === b && (d += c.width * -1);
              }),
              d
            );
          }),
          (c.prototype.getViewportHeight = function () {
            var b = this,
              c = b.headerHeight ? b.headerHeight : b.grid.headerHeight,
              d = b.grid.gridHeight - c - b.grid.footerHeight,
              e = b.getViewportAdjustment();
            return (d += e.height);
          }),
          (c.prototype.getViewportWidth = function () {
            var b = this,
              c = b.grid.gridWidth,
              d = b.getViewportAdjustment();
            return (c += d.width);
          }),
          (c.prototype.getHeaderViewportWidth = function () {
            var c = this.getViewportWidth();
            return c;
          }),
          (c.prototype.getCanvasHeight = function () {
            var b = this;
            if (!b.canvasHeightShouldUpdate) return b.$$canvasHeight;
            var c = b.$$canvasHeight;
            return (
              (b.$$canvasHeight = 0),
              b.visibleRowCache.forEach(function (a) {
                b.$$canvasHeight += a.height;
              }),
              (b.canvasHeightShouldUpdate = !1),
              b.grid.api.core.raise.canvasHeightChanged(c, b.$$canvasHeight),
              b.$$canvasHeight
            );
          }),
          (c.prototype.getVerticalScrollLength = function () {
            return this.getCanvasHeight() -
              this.getViewportHeight() +
              this.grid.scrollbarHeight !==
              0
              ? this.getCanvasHeight() -
                  this.getViewportHeight() +
                  this.grid.scrollbarHeight
              : -1;
          }),
          (c.prototype.getHorizontalScrollLength = function () {
            return this.getCanvasWidth() -
              this.getViewportWidth() +
              this.grid.scrollbarWidth !==
              0
              ? this.getCanvasWidth() -
                  this.getViewportWidth() +
                  this.grid.scrollbarWidth
              : -1;
          }),
          (c.prototype.getCanvasWidth = function () {
            var b = this,
              c = b.canvasWidth;
            return c;
          }),
          (c.prototype.setRenderedRows = function (b) {
            this.renderedRows.length = b.length;
            for (var c = 0; c < b.length; c++) this.renderedRows[c] = b[c];
          }),
          (c.prototype.setRenderedColumns = function (b) {
            this.renderedColumns.length = b.length;
            for (var d = 0; d < b.length; d++) this.renderedColumns[d] = b[d];
            this.updateColumnOffset();
          }),
          (c.prototype.updateColumnOffset = function () {
            for (var b = 0, c = 0; c < this.currentFirstColumn; c++)
              b += this.visibleColumnCache[c].drawnWidth;
            this.columnOffset = b;
          }),
          (c.prototype.scrollVertical = function (a) {
            var c = -1;
            if (a !== this.prevScrollTop) {
              var d = a - this.prevScrollTop;
              d > 0 && (this.grid.scrollDirection = b.scrollDirection.DOWN),
                d < 0 && (this.grid.scrollDirection = b.scrollDirection.UP);
              var e = this.getVerticalScrollLength();
              return (
                (c = a / e),
                c > 1 && (c = 1),
                c < 0 && (c = 0),
                this.adjustScrollVertical(a, c),
                c
              );
            }
          }),
          (c.prototype.scrollHorizontal = function (a) {
            var c = -1;
            if (a !== this.prevScrollLeft) {
              var d = a - this.prevScrollLeft;
              d > 0 && (this.grid.scrollDirection = b.scrollDirection.RIGHT),
                d < 0 && (this.grid.scrollDirection = b.scrollDirection.LEFT);
              var e = this.getHorizontalScrollLength();
              return (
                (c = 0 !== e ? a / e : 0), this.adjustScrollHorizontal(a, c), c
              );
            }
          }),
          (c.prototype.adjustScrollVertical = function (b, c, d) {
            (this.prevScrollTop !== b || d) &&
              (("undefined" != typeof b && void 0 !== b && null !== b) ||
                (b = (this.getCanvasHeight() - this.getViewportHeight()) * c),
              this.adjustRows(b, c, !1),
              (this.prevScrollTop = b),
              (this.prevScrolltopPercentage = c),
              this.grid.queueRefresh());
          }),
          (c.prototype.adjustScrollHorizontal = function (b, c, d) {
            (this.prevScrollLeft !== b || d) &&
              (("undefined" != typeof b && void 0 !== b && null !== b) ||
                (b = (this.getCanvasWidth() - this.getViewportWidth()) * c),
              this.adjustColumns(b, c),
              (this.prevScrollLeft = b),
              (this.prevScrollleftPercentage = c),
              this.grid.queueRefresh());
          }),
          (c.prototype.adjustRows = function (b, c, d) {
            var e = this,
              f = e.minRowsToRender(),
              g = e.visibleRowCache,
              h = g.length - f;
            ("undefined" != typeof c && null !== c) ||
              !b ||
              (c = b / e.getVerticalScrollLength());
            var i = Math.ceil(Math.min(h, h * c));
            i > h && (i = h);
            var j = [];
            if (g.length > e.grid.options.virtualizationThreshold) {
              if ("undefined" != typeof b && null !== b) {
                if (
                  !e.grid.suppressParentScrollDown &&
                  e.prevScrollTop < b &&
                  i < e.prevRowScrollIndex + e.grid.options.scrollThreshold &&
                  i < h
                )
                  return;
                if (
                  !e.grid.suppressParentScrollUp &&
                  e.prevScrollTop > b &&
                  i > e.prevRowScrollIndex - e.grid.options.scrollThreshold &&
                  i < h
                )
                  return;
              }
              var k = {},
                l = {};
              (k = Math.max(0, i - e.grid.options.excessRows)),
                (l = Math.min(g.length, i + f + e.grid.options.excessRows)),
                (j = [k, l]);
            } else {
              var m = e.visibleRowCache.length;
              j = [0, Math.max(m, f + e.grid.options.excessRows)];
            }
            e.updateViewableRowRange(j), (e.prevRowScrollIndex = i);
          }),
          (c.prototype.adjustColumns = function (b, c) {
            var d = this,
              e = d.minColumnsToRender(),
              f = d.visibleColumnCache,
              g = f.length - e;
            ("undefined" != typeof c && null !== c) ||
              !b ||
              (c = b / d.getHorizontalScrollLength());
            var h = Math.ceil(Math.min(g, g * c));
            h > g && (h = g);
            var i = [];
            if (
              f.length > d.grid.options.columnVirtualizationThreshold &&
              d.getCanvasWidth() > d.getViewportWidth()
            ) {
              var j = Math.max(0, h - d.grid.options.excessColumns),
                k = Math.min(f.length, h + e + d.grid.options.excessColumns);
              i = [j, k];
            } else {
              var l = d.visibleColumnCache.length;
              i = [0, Math.max(l, e + d.grid.options.excessColumns)];
            }
            d.updateViewableColumnRange(i), (d.prevColumnScrollIndex = h);
          }),
          (c.prototype.updateViewableRowRange = function (b) {
            var c = this.visibleRowCache.slice(b[0], b[1]);
            (this.currentTopRow = b[0]), this.setRenderedRows(c);
          }),
          (c.prototype.updateViewableColumnRange = function (b) {
            var c = this.visibleColumnCache.slice(b[0], b[1]);
            (this.currentFirstColumn = b[0]), this.setRenderedColumns(c);
          }),
          (c.prototype.headerCellWrapperStyle = function () {
            var a = this;
            if (0 !== a.currentFirstColumn) {
              var b = a.columnOffset;
              return a.grid.isRTL()
                ? { "margin-right": b + "px" }
                : { "margin-left": b + "px" };
            }
            return null;
          }),
          (c.prototype.updateColumnWidths = function () {
            var b = this,
              c = [],
              d = 0,
              e = 0,
              f = "",
              g = b.grid.getViewportWidth() - b.grid.scrollbarWidth,
              h = [];
            angular.forEach(b.grid.renderContainers, function (a, b) {
              h = h.concat(a.visibleColumnCache);
            }),
              h.forEach(function (b, f) {
                var h = 0;
                b.visible &&
                  (angular.isNumber(b.width)
                    ? ((h = parseInt(b.width, 10)),
                      (e += h),
                      (b.drawnWidth = h))
                    : a.endsWith(b.width, "%")
                    ? ((h = parseFloat(
                        (parseInt(b.width.replace(/%/g, ""), 10) / 100) * g
                      )),
                      h > b.maxWidth && (h = b.maxWidth),
                      h < b.minWidth && (h = b.minWidth),
                      (e += h),
                      (b.drawnWidth = h))
                    : angular.isString(b.width) &&
                      b.width.indexOf("*") !== -1 &&
                      ((d += b.width.length), c.push(b)));
              });
            var i = g - e;
            if (c.length > 0) {
              var m = i / d;
              c.forEach(function (a) {
                var b = parseInt(a.width.length * m, 10);
                b > a.maxWidth && (b = a.maxWidth),
                  b < a.minWidth && (b = a.minWidth),
                  (e += b),
                  (a.drawnWidth = b);
              });
            }
            for (
              var n = function (a) {
                  a.drawnWidth < a.maxWidth &&
                    o > 0 &&
                    (a.drawnWidth++, e++, o--, (p = !0));
                },
                o = g - e,
                p = !0;
              o > 0 && p;

            )
              (p = !1), c.forEach(n);
            var q = function (a) {
                a.drawnWidth > a.minWidth &&
                  r > 0 &&
                  (a.drawnWidth--, e--, r--, (p = !0));
              },
              r = e - g;
            for (p = !0; r > 0 && p; ) (p = !1), c.forEach(q);
            var s = 0;
            b.visibleColumnCache.forEach(function (a) {
              a.visible && (s += a.drawnWidth);
            }),
              h.forEach(function (a) {
                f += a.getColClassDefinition();
              }),
              (b.canvasWidth = s),
              (this.columnStyles = f);
          }),
          (c.prototype.needsHScrollbarPlaceholder = function () {
            return (
              this.grid.options.enableHorizontalScrollbar &&
              !this.hasHScrollbar &&
              !this.grid.disableScrolling
            );
          }),
          (c.prototype.getViewportStyle = function () {
            var a = this,
              c = {};
            return (
              (a.hasHScrollbar = !1),
              (a.hasVScrollbar = !1),
              a.grid.disableScrolling
                ? ((c["overflow-x"] = "hidden"),
                  (c["overflow-y"] = "hidden"),
                  c)
                : ("body" === a.name
                    ? ((a.hasHScrollbar =
                        a.grid.options.enableHorizontalScrollbar !==
                        b.scrollbars.NEVER),
                      a.grid.isRTL()
                        ? a.grid.hasLeftContainerColumns() ||
                          (a.hasVScrollbar =
                            a.grid.options.enableVerticalScrollbar !==
                            b.scrollbars.NEVER)
                        : a.grid.hasRightContainerColumns() ||
                          (a.hasVScrollbar =
                            a.grid.options.enableVerticalScrollbar !==
                            b.scrollbars.NEVER))
                    : "left" === a.name
                    ? (a.hasVScrollbar =
                        !!a.grid.isRTL() &&
                        a.grid.options.enableVerticalScrollbar !==
                          b.scrollbars.NEVER)
                    : (a.hasVScrollbar =
                        !a.grid.isRTL() &&
                        a.grid.options.enableVerticalScrollbar !==
                          b.scrollbars.NEVER),
                  (c["overflow-x"] = a.hasHScrollbar ? "scroll" : "hidden"),
                  (c["overflow-y"] = a.hasVScrollbar ? "scroll" : "hidden"),
                  c)
            );
          }),
          c
        );
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").factory("GridRow", [
      "gridUtil",
      "uiGridConstants",
      function (a, b) {
        function c(b, c, d) {
          (this.grid = d),
            (this.entity = b),
            (this.uid = a.nextUid()),
            (this.visible = !0),
            (this.$$height = d.options.rowHeight);
        }
        return (
          Object.defineProperty(c.prototype, "height", {
            get: function () {
              return this.$$height;
            },
            set: function (a) {
              a !== this.$$height &&
                (this.grid.updateCanvasHeight(), (this.$$height = a));
            },
          }),
          (c.prototype.getQualifiedColField = function (a) {
            return "row." + this.getEntityQualifiedColField(a);
          }),
          (c.prototype.getEntityQualifiedColField = function (c) {
            var d = "entity";
            return c.field === b.ENTITY_BINDING
              ? d
              : a.preEval(d + "." + c.field);
          }),
          (c.prototype.setRowInvisible = function (a) {
            a && a.setThisRowInvisible && a.setThisRowInvisible("user");
          }),
          (c.prototype.clearRowInvisible = function (a) {
            a && a.clearThisRowInvisible && a.clearThisRowInvisible("user");
          }),
          (c.prototype.setThisRowInvisible = function (a, b) {
            this.invisibleReason || (this.invisibleReason = {}),
              (this.invisibleReason[a] = !0),
              this.evaluateRowVisibility(b);
          }),
          (c.prototype.clearThisRowInvisible = function (a, b) {
            "undefined" != typeof this.invisibleReason &&
              delete this.invisibleReason[a],
              this.evaluateRowVisibility(b);
          }),
          (c.prototype.evaluateRowVisibility = function (a) {
            var b = !0;
            "undefined" != typeof this.invisibleReason &&
              angular.forEach(this.invisibleReason, function (a, c) {
                a && (b = !1);
              }),
              ("undefined" != typeof this.visible && this.visible === b) ||
                ((this.visible = b),
                a ||
                  (this.grid.queueGridRefresh(),
                  this.grid.api.core.raise.rowsVisibleChanged(this)));
          }),
          c
        );
      },
    ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").factory("GridRowColumn", [
      "$parse",
      "$filter",
      function (b, c) {
        var d = function a(b, c) {
          if (!(this instanceof a))
            throw "Using GridRowColumn as a function insead of as a constructor. Must be called with `new` keyword";
          (this.row = b), (this.col = c);
        };
        return (
          (d.prototype.getIntersectionValueRaw = function () {
            var a = b(this.row.getEntityQualifiedColField(this.col)),
              c = this.row;
            return a(c);
          }),
          d
        );
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").factory("ScrollEvent", [
      "gridUtil",
      function (a) {
        function b(b, c, d, e) {
          var f = this;
          if (!b) throw new Error("grid argument is required");
          (f.grid = b),
            (f.source = e),
            (f.withDelay = !0),
            (f.sourceRowContainer = c),
            (f.sourceColContainer = d),
            (f.newScrollLeft = null),
            (f.newScrollTop = null),
            (f.x = null),
            (f.y = null),
            (f.verticalScrollLength = -9999999),
            (f.horizontalScrollLength = -999999),
            (f.fireThrottledScrollingEvent = a.throttle(
              function (a) {
                f.grid.scrollContainers(a, f);
              },
              f.grid.options.wheelScrollThrottle,
              { trailing: !0 }
            ));
        }
        return (
          (b.prototype.getNewScrollLeft = function (b, c) {
            var d = this;
            if (!d.newScrollLeft) {
              var g,
                e = b.getCanvasWidth() - b.getViewportWidth(),
                f = a.normalizeScrollLeft(c, d.grid);
              if (
                "undefined" != typeof d.x.percentage &&
                void 0 !== d.x.percentage
              )
                g = d.x.percentage;
              else {
                if ("undefined" == typeof d.x.pixels || void 0 === d.x.pixels)
                  throw new Error(
                    "No percentage or pixel value provided for scroll event X axis"
                  );
                g = d.x.percentage = (f + d.x.pixels) / e;
              }
              return Math.max(0, g * e);
            }
            return d.newScrollLeft;
          }),
          (b.prototype.getNewScrollTop = function (a, b) {
            var c = this;
            if (!c.newScrollTop) {
              var f,
                d = a.getVerticalScrollLength(),
                e = b[0].scrollTop;
              if (
                "undefined" != typeof c.y.percentage &&
                void 0 !== c.y.percentage
              )
                f = c.y.percentage;
              else {
                if ("undefined" == typeof c.y.pixels || void 0 === c.y.pixels)
                  throw new Error(
                    "No percentage or pixel value provided for scroll event Y axis"
                  );
                f = c.y.percentage = (e + c.y.pixels) / d;
              }
              return Math.max(0, f * d);
            }
            return c.newScrollTop;
          }),
          (b.prototype.atTop = function (a) {
            return (
              this.y &&
              (0 === this.y.percentage || this.verticalScrollLength < 0) &&
              0 === a
            );
          }),
          (b.prototype.atBottom = function (a) {
            return (
              this.y &&
              (1 === this.y.percentage || 0 === this.verticalScrollLength) &&
              a > 0
            );
          }),
          (b.prototype.atLeft = function (a) {
            return (
              this.x &&
              (0 === this.x.percentage || this.horizontalScrollLength < 0) &&
              0 === a
            );
          }),
          (b.prototype.atRight = function (a) {
            return (
              this.x &&
              (1 === this.x.percentage || 0 === this.horizontalScrollLength) &&
              a > 0
            );
          }),
          (b.Sources = {
            ViewPortScroll: "ViewPortScroll",
            RenderContainerMouseWheel: "RenderContainerMouseWheel",
            RenderContainerTouchMove: "RenderContainerTouchMove",
            Other: 99,
          }),
          b
        );
      },
    ]);
  })(),
  (function () {
    "use strict";
    angular.module("ui.grid").service("gridClassFactory", [
      "gridUtil",
      "$q",
      "$compile",
      "$templateCache",
      "uiGridConstants",
      "Grid",
      "GridColumn",
      "GridRow",
      function (a, b, c, d, e, f, g, h) {
        var i = {
          createGrid: function (d) {
            (d = "undefined" != typeof d ? d : {}), (d.id = a.newId());
            var e = new f(d);
            if (e.options.rowTemplate) {
              var g = b.defer();
              (e.getRowTemplateFn = g.promise),
                a.getTemplate(e.options.rowTemplate).then(
                  function (a) {
                    var b = c(a);
                    g.resolve(b);
                  },
                  function (a) {
                    throw new Error(
                      "Couldn't fetch/use row template '" +
                        e.options.rowTemplate +
                        "'"
                    );
                  }
                );
            }
            return (
              e.registerColumnBuilder(i.defaultColumnBuilder),
              e.registerRowBuilder(i.rowTemplateAssigner),
              e.registerRowsProcessor(function (b) {
                return (
                  b.forEach(function (a) {
                    a.evaluateRowVisibility(!0);
                  }, 50),
                  b
                );
              }),
              e.registerColumnsProcessor(function (b) {
                return (
                  b.forEach(function (a) {
                    a.visible =
                      !angular.isDefined(a.colDef.visible) || a.colDef.visible;
                  }),
                  b
                );
              }, 50),
              e.registerRowsProcessor(e.searchRows, 100),
              e.options.externalSort &&
              angular.isFunction(e.options.externalSort)
                ? e.registerRowsProcessor(e.options.externalSort, 200)
                : e.registerRowsProcessor(e.sortByColumn, 200),
              e
            );
          },
          defaultColumnBuilder: function (c, d, f) {
            var g = [],
              h = function (b, f, h, i, j) {
                c[b] ? (d[f] = c[b]) : (d[f] = h),
                  g.push(
                    a.getTemplate(d[f]).then(
                      function (a) {
                        angular.isFunction(a) && (a = a());
                        var c =
                          "cellTooltip" === j
                            ? "col.cellTooltip(row,col)"
                            : "col.headerTooltip(col)";
                        j && d[j] === !1
                          ? (a = a.replace(e.TOOLTIP, ""))
                          : j &&
                            d[j] &&
                            (a = a.replace(
                              e.TOOLTIP,
                              'title="{{' + c + ' CUSTOM_FILTERS }}"'
                            )),
                          i
                            ? (d[b] = a.replace(e.CUSTOM_FILTERS, function () {
                                return d[i] ? "|" + d[i] : "";
                              }))
                            : (d[b] = a);
                      },
                      function (a) {
                        throw new Error(
                          "Couldn't fetch/use colDef." + b + " '" + c[b] + "'"
                        );
                      }
                    )
                  );
              };
            return (
              h(
                "cellTemplate",
                "providedCellTemplate",
                "ui-grid/uiGridCell",
                "cellFilter",
                "cellTooltip"
              ),
              (d.cellTemplatePromise = g[0]),
              h(
                "headerCellTemplate",
                "providedHeaderCellTemplate",
                "ui-grid/uiGridHeaderCell",
                "headerCellFilter",
                "headerTooltip"
              ),
              h(
                "footerCellTemplate",
                "providedFooterCellTemplate",
                "ui-grid/uiGridFooterCell",
                "footerCellFilter"
              ),
              h(
                "filterHeaderTemplate",
                "providedFilterHeaderTemplate",
                "ui-grid/ui-grid-filter"
              ),
              (d.compiledElementFnDefer = b.defer()),
              b.all(g)
            );
          },
          rowTemplateAssigner: function (e) {
            var f = this;
            if (e.rowTemplate) {
              var g = b.defer();
              (e.getRowTemplateFn = g.promise),
                a.getTemplate(e.rowTemplate).then(
                  function (a) {
                    var b = c(a);
                    g.resolve(b);
                  },
                  function (a) {
                    throw new Error(
                      "Couldn't fetch/use row template '" + e.rowTemplate + "'"
                    );
                  }
                );
            } else
              (e.rowTemplate = f.options.rowTemplate),
                (e.getRowTemplateFn = f.getRowTemplateFn);
            return e.getRowTemplateFn;
          },
        };
        return i;
      },
    ]);
  })(),
  (function () {
    function b(a) {
      return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    var a = angular.module("ui.grid");
    a.service("rowSearcher", [
      "gridUtil",
      "uiGridConstants",
      function (a, c) {
        var d = c.filter.CONTAINS,
          e = {};
        return (
          (e.getTerm = function (b) {
            if ("undefined" == typeof b.term) return b.term;
            var c = b.term;
            return "string" == typeof c && (c = c.trim()), c;
          }),
          (e.stripTerm = function (c) {
            var d = e.getTerm(c);
            return "string" == typeof d ? b(d.replace(/(^\*|\*$)/g, "")) : d;
          }),
          (e.guessCondition = function (b) {
            if ("undefined" == typeof b.term || !b.term) return d;
            var c = e.getTerm(b);
            if (/\*/.test(c)) {
              var f = "";
              (b.flags && b.flags.caseSensitive) || (f += "i");
              var g = c.replace(/(\\)?\*/g, function (a, b) {
                return b ? a : "[\\s\\S]*?";
              });
              return new RegExp("^" + g + "$", f);
            }
            return d;
          }),
          (e.setupFilters = function (d) {
            for (var f = [], g = d.length, h = 0; h < g; h++) {
              var i = d[h];
              if (i.noTerm || !a.isNullOrUndefined(i.term)) {
                var j = {},
                  k = "";
                (i.flags && i.flags.caseSensitive) || (k += "i"),
                  a.isNullOrUndefined(i.term) ||
                    (i.rawTerm ? (j.term = i.term) : (j.term = e.stripTerm(i))),
                  (j.noTerm = i.noTerm),
                  i.condition
                    ? (j.condition = i.condition)
                    : (j.condition = e.guessCondition(i)),
                  (j.flags = angular.extend(
                    { caseSensitive: !1, date: !1 },
                    i.flags
                  )),
                  j.condition === c.filter.STARTS_WITH &&
                    (j.startswithRE = new RegExp("^" + j.term, k)),
                  j.condition === c.filter.ENDS_WITH &&
                    (j.endswithRE = new RegExp(j.term + "$", k)),
                  j.condition === c.filter.CONTAINS &&
                    (j.containsRE = new RegExp(j.term, k)),
                  j.condition === c.filter.EXACT &&
                    (j.exactRE = new RegExp("^" + j.term + "$", k)),
                  f.push(j);
              }
            }
            return f;
          }),
          (e.runColumnFilter = function (b, d, e, f) {
            var i,
              g = typeof f.condition,
              h = f.term;
            if (
              ((i = e.filterCellFiltered
                ? b.getCellDisplayValue(d, e)
                : b.getCellValue(d, e)),
              f.condition instanceof RegExp)
            )
              return f.condition.test(i);
            if ("function" === g) return f.condition(h, i, d, e);
            if (f.startswithRE) return f.startswithRE.test(i);
            if (f.endswithRE) return f.endswithRE.test(i);
            if (f.containsRE) return f.containsRE.test(i);
            if (f.exactRE) return f.exactRE.test(i);
            if (f.condition === c.filter.NOT_EQUAL) {
              var j = new RegExp("^" + h + "$");
              return !j.exec(i);
            }
            if ("number" == typeof i && "string" == typeof h) {
              var k = parseFloat(h.replace(/\\\./, ".").replace(/\\\-/, "-"));
              isNaN(k) || (h = k);
            }
            return (
              f.flags.date === !0 &&
                ((i = new Date(i)), (h = new Date(h.replace(/\\/g, "")))),
              f.condition === c.filter.GREATER_THAN
                ? i > h
                : f.condition === c.filter.GREATER_THAN_OR_EQUAL
                ? i >= h
                : f.condition === c.filter.LESS_THAN
                ? i < h
                : f.condition !== c.filter.LESS_THAN_OR_EQUAL || i <= h
            );
          }),
          (e.searchColumn = function (c, d, f, g) {
            if (c.options.useExternalFiltering) return !0;
            for (var h = g.length, i = 0; i < h; i++) {
              var j = g[i];
              if ((!a.isNullOrUndefined(j.term) && "" !== j.term) || j.noTerm) {
                var k = e.runColumnFilter(c, d, f, j);
                if (!k) return !1;
              }
            }
            return !0;
          }),
          (e.search = function (c, d, f) {
            if (d) {
              if (!c.options.enableFiltering) return d;
              for (
                var g = [],
                  h = f.length,
                  i = function (b) {
                    var c = !1;
                    return (
                      b.forEach(function (b) {
                        ((!a.isNullOrUndefined(b.term) && "" !== b.term) ||
                          b.noTerm) &&
                          (c = !0);
                      }),
                      c
                    );
                  },
                  j = 0;
                j < h;
                j++
              ) {
                var k = f[j];
                "undefined" != typeof k.filters &&
                  i(k.filters) &&
                  g.push({ col: k, filters: e.setupFilters(k.filters) });
              }
              if (g.length > 0) {
                for (
                  var l = function (a, b, c, d) {
                      b.visible &&
                        !e.searchColumn(a, b, c, d) &&
                        (b.visible = !1);
                    },
                    m = function (a, b) {
                      for (var c = d.length, e = 0; e < c; e++)
                        l(a, d[e], b.col, b.filters);
                    },
                    n = g.length,
                    o = 0;
                  o < n;
                  o++
                )
                  m(c, g[o]);
                c.api.core.raise.rowsVisibleChanged &&
                  c.api.core.raise.rowsVisibleChanged();
              }
              return d;
            }
          }),
          e
        );
      },
    ]);
  })(),
  (function () {
    var a = angular.module("ui.grid");
    a.service("rowSorter", [
      "$parse",
      "uiGridConstants",
      function (a, b) {
        var c =
            "(" +
            b.CURRENCY_SYMBOLS.map(function (a) {
              return "\\" + a;
            }).join("|") +
            ")?",
          e =
            (new RegExp("^[-+]?" + c + "[\\d,.]+" + c + "%?$"),
            { colSortFnCache: {} });
        return (
          (e.guessSortFn = function (b) {
            switch (b) {
              case "number":
                return e.sortNumber;
              case "numberStr":
                return e.sortNumberStr;
              case "boolean":
                return e.sortBool;
              case "string":
                return e.sortAlpha;
              case "date":
                return e.sortDate;
              case "object":
                return e.basicSort;
              default:
                throw new Error("No sorting function found for type:" + b);
            }
          }),
          (e.handleNulls = function (b, c) {
            if ((!b && 0 !== b && b !== !1) || (!c && 0 !== c && c !== !1)) {
              if (!b && 0 !== b && b !== !1 && !c && 0 !== c && c !== !1)
                return 0;
              if (!b && 0 !== b && b !== !1) return 1;
              if (!c && 0 !== c && c !== !1) return -1;
            }
            return null;
          }),
          (e.basicSort = function (b, c) {
            var d = e.handleNulls(b, c);
            return null !== d ? d : b === c ? 0 : b < c ? -1 : 1;
          }),
          (e.sortNumber = function (b, c) {
            var d = e.handleNulls(b, c);
            return null !== d ? d : b - c;
          }),
          (e.sortNumberStr = function (b, c) {
            var d = e.handleNulls(b, c);
            if (null !== d) return d;
            var f,
              g,
              h = !1,
              i = !1;
            return (
              (f = parseFloat(b.replace(/[^0-9.-]/g, ""))),
              isNaN(f) && (h = !0),
              (g = parseFloat(c.replace(/[^0-9.-]/g, ""))),
              isNaN(g) && (i = !0),
              h && i ? 0 : h ? 1 : i ? -1 : f - g
            );
          }),
          (e.sortAlpha = function (b, c) {
            var d = e.handleNulls(b, c);
            if (null !== d) return d;
            var f = b.toString().toLowerCase(),
              g = c.toString().toLowerCase();
            return f === g ? 0 : f.localeCompare(g);
          }),
          (e.sortDate = function (b, c) {
            var d = e.handleNulls(b, c);
            if (null !== d) return d;
            b instanceof Date || (b = new Date(b)),
              c instanceof Date || (c = new Date(c));
            var f = b.getTime(),
              g = c.getTime();
            return f === g ? 0 : f < g ? -1 : 1;
          }),
          (e.sortBool = function (b, c) {
            var d = e.handleNulls(b, c);
            return null !== d ? d : b && c ? 0 : b || c ? (b ? 1 : -1) : 0;
          }),
          (e.getSortFn = function (b, c, d) {
            var f;
            return (
              e.colSortFnCache[c.colDef.name]
                ? (f = e.colSortFnCache[c.colDef.name])
                : void 0 !== c.sortingAlgorithm
                ? ((f = c.sortingAlgorithm),
                  (e.colSortFnCache[c.colDef.name] = c.sortingAlgorithm))
                : c.sortCellFiltered && c.cellFilter
                ? ((f = e.sortAlpha), (e.colSortFnCache[c.colDef.name] = f))
                : ((f = e.guessSortFn(c.colDef.type)),
                  f
                    ? (e.colSortFnCache[c.colDef.name] = f)
                    : (f = e.sortAlpha)),
              f
            );
          }),
          (e.prioritySort = function (a, b) {
            return void 0 !== a.sort.priority && void 0 !== b.sort.priority
              ? a.sort.priority < b.sort.priority
                ? -1
                : a.sort.priority === b.sort.priority
                ? 0
                : 1
              : void 0 !== a.sort.priority
              ? -1
              : void 0 !== b.sort.priority
              ? 1
              : 0;
          }),
          (e.sort = function (c, d, f) {
            if (d) {
              if (c.options.useExternalSorting) return d;
              var g = [];
              if (
                (f.forEach(function (a) {
                  !a.sort ||
                    a.sort.ignoreSort ||
                    !a.sort.direction ||
                    (a.sort.direction !== b.ASC &&
                      a.sort.direction !== b.DESC) ||
                    g.push(a);
                }),
                (g = g.sort(e.prioritySort)),
                0 === g.length)
              )
                return d;
              var h,
                i,
                j = function (a, b) {
                  a.entity.$$uiGridIndex = b;
                };
              d.forEach(j);
              var k = d.slice(0),
                l = function (a, d) {
                  for (var l, f = 0, j = 0; 0 === f && j < g.length; ) {
                    (h = g[j]),
                      (i = g[j].sort.direction),
                      (l = e.getSortFn(c, h, k));
                    var m, n;
                    h.sortCellFiltered
                      ? ((m = c.getCellDisplayValue(a, h)),
                        (n = c.getCellDisplayValue(d, h)))
                      : ((m = c.getCellValue(a, h)),
                        (n = c.getCellValue(d, h))),
                      (f = l(m, n, a, d, i, h)),
                      j++;
                  }
                  return 0 === f
                    ? a.entity.$$uiGridIndex - d.entity.$$uiGridIndex
                    : i === b.ASC
                    ? f
                    : 0 - f;
                },
                m = d.sort(l),
                n = function (a, b) {
                  delete a.entity.$$uiGridIndex;
                };
              return d.forEach(n), m;
            }
          }),
          e
        );
      },
    ]);
  })(),
  (function () {
    function c(a) {
      var b = a;
      return (
        "undefined" != typeof b.length && b.length && (b = a[0]),
        b.ownerDocument.defaultView.getComputedStyle(b, null)
      );
    }
    function g(a, b, c, d, e) {
      for (
        var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0,
          g = 0,
          h = ["Top", "Right", "Bottom", "Left"];
        f < 4;
        f += 2
      ) {
        var i = h[f];
        if ("margin" === c) {
          var j = parseFloat(e[c + i]);
          isNaN(j) || (g += j);
        }
        if (d) {
          if ("content" === c) {
            var k = parseFloat(e["padding" + i]);
            isNaN(k) || (g -= k);
          }
          if ("margin" !== c) {
            var l = parseFloat(e["border" + i + "Width"]);
            isNaN(l) || (g -= l);
          }
        } else {
          var m = parseFloat(e["padding" + i]);
          if ((isNaN(m) || (g += m), "padding" !== c)) {
            var n = parseFloat(e["border" + i + "Width"]);
            isNaN(n) || (g += n);
          }
        }
      }
      return g;
    }
    function h(a, b, e) {
      var h,
        f = !0,
        i = c(a),
        j = "border-box" === i.boxSizing;
      if (h <= 0 || null == h) {
        if (((h = i[b]), (h < 0 || null == h) && (h = a.style[b]), d.test(h)))
          return h;
        (f = j && !0), (h = parseFloat(h) || 0);
      }
      var k = h + g(a, b, e || (j ? "border" : "content"), f, i);
      return k;
    }
    function i(a) {
      a = angular.element(a)[0];
      var b = a.parentElement;
      return (
        b || (b = document.getElementsByTagName("body")[0]),
        parseInt(c(b).fontSize) || parseInt(c(a).fontSize) || 16
      );
    }
    var b,
      a = angular.module("ui.grid");
    "function" != typeof Function.prototype.bind &&
      (b = function () {
        var a = Array.prototype.slice;
        return function (b) {
          var c = this,
            d = a.call(arguments, 1);
          return d.length
            ? function () {
                return arguments.length
                  ? c.apply(b, d.concat(a.call(arguments)))
                  : c.apply(b, d);
              }
            : function () {
                return arguments.length ? c.apply(b, arguments) : c.call(b);
              };
        };
      });
    var d = new RegExp(
        "^(" + /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source + ")(?!px)[a-z%]+$",
        "i"
      ),
      e = /^(block|none|table(?!-c[ea]).+)/,
      f = { position: "absolute", visibility: "hidden", display: "block" },
      j = ["0", "0", "0", "0"],
      k = "uiGrid-";
    a.service("gridUtil", [
      "$log",
      "$window",
      "$document",
      "$http",
      "$templateCache",
      "$timeout",
      "$interval",
      "$injector",
      "$q",
      "$interpolate",
      "uiGridConstants",
      function (a, d, l, m, n, o, p, q, r, s, t) {
        function y(a, b) {
          var c = angular.element(this),
            d = 0,
            e = 0,
            f = 0,
            g = 0;
          if (
            (b.originalEvent && (b = b.originalEvent),
            "detail" in b && (f = b.detail * -1),
            "wheelDelta" in b && (f = b.wheelDelta),
            "wheelDeltaY" in b && (f = b.wheelDeltaY),
            "wheelDeltaX" in b && (e = b.wheelDeltaX * -1),
            "axis" in b &&
              b.axis === b.HORIZONTAL_AXIS &&
              ((e = f * -1), (f = 0)),
            (d = 0 === f ? e : f),
            "deltaY" in b && ((f = b.deltaY * -1), (d = f)),
            "deltaX" in b && ((e = b.deltaX), 0 === f && (d = e * -1)),
            0 !== f || 0 !== e)
          ) {
            if (1 === b.deltaMode) {
              var j = c.data("mousewheel-line-height");
              (d *= j), (f *= j), (e *= j);
            } else if (2 === b.deltaMode) {
              var k = c.data("mousewheel-page-height");
              (d *= k), (f *= k), (e *= k);
            }
            (g = Math.max(Math.abs(f), Math.abs(e))),
              (!x || g < x) && ((x = g), A(b, g) && (x /= 40)),
              (d = Math[d >= 1 ? "floor" : "ceil"](d / x)),
              (e = Math[e >= 1 ? "floor" : "ceil"](e / x)),
              (f = Math[f >= 1 ? "floor" : "ceil"](f / x));
            var l = {
              originalEvent: b,
              deltaX: e,
              deltaY: f,
              deltaFactor: x,
              preventDefault: function () {
                b.preventDefault();
              },
              stopPropagation: function () {
                b.stopPropagation();
              },
            };
            w && clearTimeout(w), (w = setTimeout(z, 200)), a.call(c[0], l);
          }
        }
        function z() {
          x = null;
        }
        function A(a, b) {
          return "mousewheel" === a.type && b % 120 === 0;
        }
        var u = {
          augmentWidthOrHeight: g,
          getStyles: c,
          createBoundedWrapper: function (a, b) {
            return function () {
              return b.apply(a, arguments);
            };
          },
          readableColumnName: function (a) {
            return "undefined" == typeof a || void 0 === a || null === a
              ? a
              : ("string" != typeof a && (a = String(a)),
                a
                  .replace(/_+/g, " ")
                  .replace(/^[A-Z]+$/, function (a) {
                    var str = a.charAt(0).toUpperCase() + a.slice(1);
                    return str.toLowerCase();
                  })
                  .replace(/([\w\u00C0-\u017F]+)/g, function (a) {
                    return a.charAt(0) + a.slice(1);
                  })
                  .replace(/(\w+?(?=[A-Z]))/g, "$1 "));
          },
          getColumnsFromData: function (a, b) {
            var c = [];
            if (!a || "undefined" == typeof a[0] || void 0 === a[0]) return [];
            angular.isUndefined(b) && (b = []);
            var d = a[0];
            return (
              angular.forEach(d, function (a, d) {
                b.indexOf(d) === -1 && c.push({ name: d });
              }),
              c
            );
          },
          newId: (function () {
            var a = new Date().getTime();
            return function () {
              return (a += 1);
            };
          })(),
          getTemplate: function (a) {
            if (n.get(a)) return u.postProcessTemplate(n.get(a));
            if (angular.isFunction(a.then))
              return a.then(u.postProcessTemplate);
            try {
              if (angular.element(a).length > 0)
                return r.when(a).then(u.postProcessTemplate);
            } catch (a) {}
            return (
              u.logDebug("fetching url", a),
              m({ method: "GET", url: a })
                .then(
                  function (b) {
                    var c = b.data.trim();
                    return n.put(a, c), c;
                  },
                  function (b) {
                    throw new Error("Could not get template " + a + ": " + b);
                  }
                )
                .then(u.postProcessTemplate)
            );
          },
          postProcessTemplate: function (a) {
            var b = s.startSymbol(),
              c = s.endSymbol();
            return (
              ("{{" === b && "}}" === c) ||
                ((a = a.replace(/\{\{/g, b)), (a = a.replace(/\}\}/g, c))),
              r.when(a)
            );
          },
          guessType: function (a) {
            var b = typeof a;
            switch (b) {
              case "number":
              case "boolean":
              case "string":
                return b;
              default:
                return angular.isDate(a) ? "date" : "object";
            }
          },
          elementWidth: function (a) {},
          elementHeight: function (a) {},
          getScrollbarWidth: function () {
            var a = document.createElement("div");
            (a.style.visibility = "hidden"),
              (a.style.width = "100px"),
              (a.style.msOverflowStyle = "scrollbar"),
              document.body.appendChild(a);
            var b = a.offsetWidth;
            a.style.overflow = "scroll";
            var c = document.createElement("div");
            (c.style.width = "100%"), a.appendChild(c);
            var d = c.offsetWidth;
            return a.parentNode.removeChild(a), b - d;
          },
          swap: function (a, b, c, d) {
            var e,
              f,
              g = {};
            for (f in b) (g[f] = a.style[f]), (a.style[f] = b[f]);
            e = c.apply(a, d || []);
            for (f in b) a.style[f] = g[f];
            return e;
          },
          fakeElement: function (a, b, c, d) {
            var e,
              f,
              g = angular.element(a).clone()[0];
            for (f in b) g.style[f] = b[f];
            return (
              angular.element(document.body).append(g),
              (e = c.call(g, g)),
              angular.element(g).remove(),
              e
            );
          },
          normalizeWheelEvent: function (a) {
            var b,
              c,
              k,
              d = a || window.event,
              f = ([].slice.call(arguments, 1), 0),
              g = 0,
              h = 0,
              i = 0,
              j = 0;
            return (
              d.originalEvent && (d = d.originalEvent),
              d.wheelDelta && (f = d.wheelDelta),
              d.detail && (f = d.detail * -1),
              (h = f),
              void 0 !== d.axis &&
                d.axis === d.HORIZONTAL_AXIS &&
                ((h = 0), (g = f * -1)),
              d.deltaY && ((h = d.deltaY * -1), (f = h)),
              d.deltaX && ((g = d.deltaX), (f = g * -1)),
              void 0 !== d.wheelDeltaY && (h = d.wheelDeltaY),
              void 0 !== d.wheelDeltaX && (g = d.wheelDeltaX),
              (i = Math.abs(f)),
              (!b || i < b) && (b = i),
              (j = Math.max(Math.abs(h), Math.abs(g))),
              (!c || j < c) && (c = j),
              (k = f > 0 ? "floor" : "ceil"),
              (f = Math[k](f / b)),
              (g = Math[k](g / c)),
              (h = Math[k](h / c)),
              { delta: f, deltaX: g, deltaY: h }
            );
          },
          isTouchEnabled: function () {
            var a;
            return (
              ("ontouchstart" in d ||
                (d.DocumentTouch && l instanceof DocumentTouch)) &&
                (a = !0),
              a
            );
          },
          isNullOrUndefined: function (a) {
            return void 0 === a || null === a;
          },
          endsWith: function (a, b) {
            return (
              !(!a || !b || "string" != typeof a) &&
              a.indexOf(b, a.length - b.length) !== -1
            );
          },
          arrayContainsObjectWithProperty: function (a, b, c) {
            var d = !1;
            return (
              angular.forEach(a, function (a) {
                a[b] === c && (d = !0);
              }),
              d
            );
          },
          numericAndNullSort: function (a, b) {
            return null === a
              ? 1
              : null === b
              ? -1
              : null === a && null === b
              ? 0
              : a - b;
          },
          disableAnimations: function (a) {
            var b;
            try {
              (b = q.get("$animate")),
                angular.version.major > 1 ||
                (1 === angular.version.major && angular.version.minor >= 4)
                  ? b.enabled(a, !1)
                  : b.enabled(!1, a);
            } catch (a) {}
          },
          enableAnimations: function (a) {
            var b;
            try {
              return (
                (b = q.get("$animate")),
                angular.version.major > 1 ||
                (1 === angular.version.major && angular.version.minor >= 4)
                  ? b.enabled(a, !0)
                  : b.enabled(!0, a),
                b
              );
            } catch (a) {}
          },
          nextUid: function () {
            for (var c, b = j.length; b; ) {
              if ((b--, (c = j[b].charCodeAt(0)), 57 === c))
                return (j[b] = "A"), k + j.join("");
              if (90 !== c)
                return (j[b] = String.fromCharCode(c + 1)), k + j.join("");
              j[b] = "0";
            }
            return j.unshift("0"), k + j.join("");
          },
          hashKey: function (b) {
            var d,
              c = typeof b;
            return (
              "object" === c && null !== b
                ? "function" == typeof (d = b.$$hashKey)
                  ? (d = b.$$hashKey())
                  : "undefined" != typeof b.$$hashKey && b.$$hashKey
                  ? (d = b.$$hashKey)
                  : void 0 === d && (d = b.$$hashKey = u.nextUid())
                : (d = b),
              c + ":" + d
            );
          },
          resetUids: function () {
            j = ["0", "0", "0"];
          },
          logError: function (b) {
            t.LOG_ERROR_MESSAGES && a.error(b);
          },
          logWarn: function (b) {
            t.LOG_WARN_MESSAGES && a.warn(b);
          },
          logDebug: function () {
            t.LOG_DEBUG_MESSAGES && a.debug.apply(a, arguments);
          },
        };
        (u.focus = {
          queue: [],
          byId: function (a, b) {
            this._purgeQueue();
            var c = o(function () {
              var c = (b && b.id ? b.id + "-" : "") + a,
                e = d.document.getElementById(c);
              e
                ? e.focus()
                : u.logWarn("[focus.byId] Element id " + c + " was not found.");
            });
            return this.queue.push(c), c;
          },
          byElement: function (a) {
            if (!angular.isElement(a))
              return (
                u.logWarn(
                  "Trying to focus on an element that isn't an element."
                ),
                r.reject("not-element")
              );
            (a = angular.element(a)), this._purgeQueue();
            var b = o(function () {
              a && a[0].focus();
            });
            return this.queue.push(b), b;
          },
          bySelector: function (a, b, c) {
            var d = this;
            if (!angular.isElement(a))
              throw new Error("The parent element is not an element.");
            a = angular.element(a);
            var e = function () {
              var c = a[0].querySelector(b);
              return d.byElement(c);
            };
            if ((this._purgeQueue(), c)) {
              var f = o(e);
              return this.queue.push(o(e)), f;
            }
            return e();
          },
          _purgeQueue: function () {
            this.queue.forEach(function (a) {
              o.cancel(a);
            }),
              (this.queue = []);
          },
        }),
          ["width", "height"].forEach(function (a) {
            var b = a.charAt(0).toUpperCase() + a.substr(1);
            (u["element" + b] = function (b, d) {
              var g = b;
              if (
                (g && "undefined" != typeof g.length && g.length && (g = b[0]),
                g && null !== g)
              ) {
                var i = c(g);
                return 0 === g.offsetWidth && e.test(i.display)
                  ? u.swap(g, f, function () {
                      return h(g, a, d);
                    })
                  : h(g, a, d);
              }
              return null;
            }),
              (u["outerElement" + b] = function (a, c) {
                return a
                  ? u["element" + b].call(this, a, c ? "margin" : "border")
                  : null;
              });
          }),
          (u.closestElm = function (b, c) {
            "undefined" != typeof b.length && b.length && (b = b[0]);
            var d;
            [
              "matches",
              "webkitMatchesSelector",
              "mozMatchesSelector",
              "msMatchesSelector",
              "oMatchesSelector",
            ].some(function (a) {
              return "function" == typeof document.body[a] && ((d = a), !0);
            });
            for (var e; null !== b; ) {
              if (((e = b.parentElement), null !== e && e[d](c))) return e;
              b = e;
            }
            return null;
          }),
          (u.type = function (a) {
            var b = Function.prototype.toString.call(a.constructor);
            return b.match(/function (.*?)\(/)[1];
          }),
          (u.getBorderSize = function (b, d) {
            "undefined" != typeof b.length && b.length && (b = b[0]);
            var e = c(b);
            (d = d
              ? "border" + d.charAt(0).toUpperCase() + d.slice(1)
              : "border"),
              (d += "Width");
            var f = parseInt(e[d], 10);
            return isNaN(f) ? 0 : f;
          }),
          (u.detectBrowser = function () {
            var b = d.navigator.userAgent,
              c = {
                chrome: /chrome/i,
                safari: /safari/i,
                firefox: /firefox/i,
                ie: /internet explorer|trident\//i,
              };
            for (var e in c) if (c[e].test(b)) return e;
            return "unknown";
          }),
          (u.rtlScrollType = function a() {
            if (a.type) return a.type;
            var b = angular.element(
                '<div dir="rtl" style="font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll">A</div>'
              )[0],
              c = "reverse";
            return (
              document.body.appendChild(b),
              b.scrollLeft > 0
                ? (c = "default")
                : ((b.scrollLeft = 1), 0 === b.scrollLeft && (c = "negative")),
              angular.element(b).remove(),
              (a.type = c),
              c
            );
          }),
          (u.normalizeScrollLeft = function (b, c) {
            "undefined" != typeof b.length && b.length && (b = b[0]);
            var d = b.scrollLeft;
            if (c.isRTL())
              switch (u.rtlScrollType()) {
                case "default":
                  return b.scrollWidth - d - b.clientWidth;
                case "negative":
                  return Math.abs(d);
                case "reverse":
                  return d;
              }
            return d;
          }),
          (u.denormalizeScrollLeft = function (b, c, d) {
            if (
              ("undefined" != typeof b.length && b.length && (b = b[0]),
              d.isRTL())
            )
              switch (u.rtlScrollType()) {
                case "default":
                  var e = b.scrollWidth - b.clientWidth;
                  return e - c;
                case "negative":
                  return c * -1;
                case "reverse":
                  return c;
              }
            return c;
          }),
          (u.preEval = function (a) {
            var b = t.BRACKET_REGEXP.exec(a);
            if (b)
              return (
                (b[1] ? u.preEval(b[1]) : b[1]) +
                b[2] +
                (b[3] ? u.preEval(b[3]) : b[3])
              );
            a = a.replace(t.APOS_REGEXP, "\\'");
            var c = a.split(t.DOT_REGEXP),
              d = [c.shift()];
            return (
              angular.forEach(c, function (a) {
                d.push(a.replace(t.FUNC_REGEXP, "']$1"));
              }),
              d.join("['")
            );
          }),
          (u.debounce = function (a, b, c) {
            function h() {
              (f = this), (e = arguments);
              var h = function () {
                  (d = null), c || (g = a.apply(f, e));
                },
                i = c && !d;
              return (
                d && o.cancel(d), (d = o(h, b, !1)), i && (g = a.apply(f, e)), g
              );
            }
            var d, e, f, g;
            return (
              (h.cancel = function () {
                o.cancel(d), (d = null);
              }),
              h
            );
          }),
          (u.throttle = function (a, b, c) {
            function h(b) {
              (d = +new Date()),
                a.apply(f, g),
                p(
                  function () {
                    e = null;
                  },
                  0,
                  1,
                  !1
                );
            }
            c = c || {};
            var f,
              g,
              d = 0,
              e = null;
            return function () {
              if (((f = this), (g = arguments), null === e)) {
                var a = +new Date() - d;
                a > b ? h() : c.trailing && (e = p(h, b - a, 1, !1));
              }
            };
          }),
          (u.on = {}),
          (u.off = {}),
          (u._events = {}),
          (u.addOff = function (a) {
            u.off[a] = function (b, c) {
              var d = u._events[a].indexOf(c);
              d > 0 && u._events[a].removeAt(d);
            };
          });
        var w,
          x,
          v =
            "onwheel" in document || document.documentMode >= 9
              ? ["wheel"]
              : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"];
        return (
          (u.on.mousewheel = function (a, c) {
            if (a && c) {
              var d = angular.element(a);
              d.data("mousewheel-line-height", i(d)),
                d.data("mousewheel-page-height", u.elementHeight(d)),
                d.data("mousewheel-callbacks") ||
                  d.data("mousewheel-callbacks", {});
              var e = d.data("mousewheel-callbacks");
              e[c] = (Function.prototype.bind || b).call(y, d[0], c);
              for (var f = v.length; f; ) d.on(v[--f], e[c]);
              d.on("$destroy", function () {
                for (var b = v.length; b; ) d.off(v[--b], e[c]);
              });
            }
          }),
          (u.off.mousewheel = function (a, b) {
            var c = angular.element(a),
              d = c.data("mousewheel-callbacks"),
              e = d[b];
            if (e) for (var f = v.length; f; ) c.off(v[--f], e);
            delete d[b],
              0 === Object.keys(d).length &&
                (c.removeData("mousewheel-line-height"),
                c.removeData("mousewheel-page-height"),
                c.removeData("mousewheel-callbacks"));
          }),
          u
        );
      },
    ]),
      a.filter("px", function () {
        return function (a) {
          return a.match(/^[\d\.]+$/) ? a + "px" : a;
        };
      });
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            var b = {
              aggregate: { label: "položky" },
              groupPanel: {
                description:
                  "Přesuňte záhlaví zde pro vytvoření skupiny dle sloupce.",
              },
              search: {
                placeholder: "Hledat...",
                showingItems: "Zobrazuji položky:",
                selectedItems: "Vybrané položky:",
                totalItems: "Celkem položek:",
                size: "Velikost strany:",
                first: "První strana",
                next: "Další strana",
                previous: "Předchozí strana",
                last: "Poslední strana",
              },
              menu: { text: "Vyberte sloupec:" },
              sort: {
                ascending: "Seřadit od A-Z",
                descending: "Seřadit od Z-A",
                remove: "Odebrat seřazení",
              },
              column: { hide: "Schovat sloupec" },
              aggregation: {
                count: "celkem řádků: ",
                sum: "celkem: ",
                avg: "avg: ",
                min: "min.: ",
                max: "max.: ",
              },
              pinning: {
                pinLeft: "Zamknout vlevo",
                pinRight: "Zamknout vpravo",
                unpin: "Odemknout",
              },
              gridMenu: {
                columns: "Sloupce:",
                importerTitle: "Importovat soubor",
                exporterAllAsCsv: "Exportovat všechna data do csv",
                exporterVisibleAsCsv: "Exportovat viditelná data do csv",
                exporterSelectedAsCsv: "Exportovat vybraná data do csv",
                exporterAllAsPdf: "Exportovat všechna data do pdf",
                exporterVisibleAsPdf: "Exportovat viditelná data do pdf",
                exporterSelectedAsPdf: "Exportovat vybraná data do pdf",
                clearAllFilters: "Odstranit všechny filtry",
              },
              importer: {
                noHeaders:
                  "Názvy sloupců se nepodařilo získat, obsahuje soubor záhlaví?",
                noObjects:
                  "Data se nepodařilo zpracovat, obsahuje soubor řádky mimo záhlaví?",
                invalidCsv: "Soubor nelze zpracovat, jedná se o CSV?",
                invalidJson: "Soubor nelze zpracovat, je to JSON?",
                jsonNotArray: "Soubor musí obsahovat json. Ukončuji..",
              },
              pagination: {
                sizes: "položek na stránku",
                totalItems: "položek",
              },
              grouping: {
                group: "Seskupit",
                ungroup: "Odebrat seskupení",
                aggregate_count: "Agregace: Count",
                aggregate_sum: "Agregace: Sum",
                aggregate_max: "Agregace: Max",
                aggregate_min: "Agregace: Min",
                aggregate_avg: "Agregace: Avg",
                aggregate_remove: "Agregace: Odebrat",
              },
            };
            return (
              a.add("cs", b),
              a.add("cz", b),
              a.add("cs-cz", b),
              a.add("cs-CZ", b),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("da", {
                aggregate: { label: "artikler" },
                groupPanel: {
                  description:
                    "Grupér rækker udfra en kolonne ved at trække dens overskift hertil.",
                },
                search: {
                  placeholder: "Søg...",
                  showingItems: "Viste rækker:",
                  selectedItems: "Valgte rækker:",
                  totalItems: "Rækker totalt:",
                  size: "Side størrelse:",
                  first: "Første side",
                  next: "Næste side",
                  previous: "Forrige side",
                  last: "Sidste side",
                },
                menu: { text: "Vælg kolonner:" },
                sort: {
                  ascending: "Sorter stigende",
                  descending: "Sorter faldende",
                  none: "Sorter ingen",
                  remove: "Fjern sortering",
                },
                column: { hide: "Skjul kolonne" },
                aggregation: {
                  count: "antal rækker: ",
                  sum: "sum: ",
                  avg: "gns: ",
                  min: "min: ",
                  max: "max: ",
                },
                gridMenu: {
                  columns: "Kolonner:",
                  importerTitle: "Importer fil",
                  exporterAllAsCsv: "Eksporter alle data som csv",
                  exporterVisibleAsCsv: "Eksporter synlige data som csv",
                  exporterSelectedAsCsv: "Eksporter markerede data som csv",
                  exporterAllAsPdf: "Eksporter alle data som pdf",
                  exporterVisibleAsPdf: "Eksporter synlige data som pdf",
                  exporterSelectedAsPdf: "Eksporter markerede data som pdf",
                  clearAllFilters: "Clear all filters",
                },
                importer: {
                  noHeaders:
                    "Column names were unable to be derived, does the file have a header?",
                  noObjects:
                    "Objects were not able to be derived, was there data in the file other than headers?",
                  invalidCsv:
                    "File was unable to be processed, is it valid CSV?",
                  invalidJson:
                    "File was unable to be processed, is it valid Json?",
                  jsonNotArray:
                    "Imported json file must contain an array, aborting.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Gå til første",
                    pageBack: "Gå tilbage",
                    pageSelected: "Valgte side",
                    pageForward: "Gå frem",
                    pageToLast: "Gå til sidste",
                  },
                  sizes: "genstande per side",
                  totalItems: "genstande",
                  through: "gennem",
                  of: "af",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("de", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Filter für Spalte",
                    removeFilter: "Filter löschen",
                    columnMenuButtonLabel: "Spaltenmenü",
                  },
                  priority: "Priorität:",
                  filterLabel: "Filter für Spalte: ",
                },
                aggregate: { label: "Eintrag" },
                groupPanel: {
                  description:
                    "Ziehen Sie eine Spaltenüberschrift hierhin, um nach dieser Spalte zu gruppieren.",
                },
                search: {
                  placeholder: "Suche...",
                  showingItems: "Zeige Einträge:",
                  selectedItems: "Ausgewählte Einträge:",
                  totalItems: "Einträge gesamt:",
                  size: "Einträge pro Seite:",
                  first: "Erste Seite",
                  next: "Nächste Seite",
                  previous: "Vorherige Seite",
                  last: "Letzte Seite",
                },
                menu: { text: "Spalten auswählen:" },
                sort: {
                  ascending: "aufsteigend sortieren",
                  descending: "absteigend sortieren",
                  none: "keine Sortierung",
                  remove: "Sortierung zurücksetzen",
                },
                column: { hide: "Spalte ausblenden" },
                aggregation: {
                  count: "Zeilen insgesamt: ",
                  sum: "gesamt: ",
                  avg: "Durchschnitt: ",
                  min: "min: ",
                  max: "max: ",
                },
                pinning: {
                  pinLeft: "Links anheften",
                  pinRight: "Rechts anheften",
                  unpin: "Lösen",
                },
                columnMenu: { close: "Schließen" },
                gridMenu: {
                  aria: { buttonLabel: "Tabellenmenü" },
                  columns: "Spalten:",
                  importerTitle: "Datei importieren",
                  exporterAllAsCsv: "Alle Daten als CSV exportieren",
                  exporterVisibleAsCsv: "sichtbare Daten als CSV exportieren",
                  exporterSelectedAsCsv: "markierte Daten als CSV exportieren",
                  exporterAllAsPdf: "Alle Daten als PDF exportieren",
                  exporterVisibleAsPdf: "sichtbare Daten als PDF exportieren",
                  exporterSelectedAsPdf: "markierte Daten als PDF exportieren",
                  clearAllFilters: "Alle Filter zurücksetzen",
                },
                importer: {
                  noHeaders:
                    "Es konnten keine Spaltennamen ermittelt werden. Sind in der Datei Spaltendefinitionen enthalten?",
                  noObjects:
                    "Es konnten keine Zeileninformationen gelesen werden, Sind in der Datei außer den Spaltendefinitionen auch Daten enthalten?",
                  invalidCsv:
                    "Die Datei konnte nicht eingelesen werden, ist es eine gültige CSV-Datei?",
                  invalidJson:
                    "Die Datei konnte nicht eingelesen werden. Enthält sie gültiges JSON?",
                  jsonNotArray:
                    "Die importierte JSON-Datei muß ein Array enthalten. Breche Import ab.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Zum Anfang",
                    pageBack: "Seite zurück",
                    pageSelected: "Ausgwählte Seite",
                    pageForward: "Seite vor",
                    pageToLast: "Zum Ende",
                  },
                  sizes: "Einträge pro Seite",
                  totalItems: "Einträge",
                  through: "bis",
                  of: "von",
                },
                grouping: {
                  group: "Gruppieren",
                  ungroup: "Gruppierung aufheben",
                  aggregate_count: "Agg: Anzahl",
                  aggregate_sum: "Agg: Summe",
                  aggregate_max: "Agg: Maximum",
                  aggregate_min: "Agg: Minimum",
                  aggregate_avg: "Agg: Mittelwert",
                  aggregate_remove: "Aggregation entfernen",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("en", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Filter for column",
                    removeFilter: "Remove Filter",
                    columnMenuButtonLabel: "Column Menu",
                  },
                  priority: "Priority:",
                  filterLabel: "Filter for column: ",
                },
                aggregate: { label: "items" },
                groupPanel: {
                  description:
                    "Drag a column header here and drop it to group by that column.",
                },
                search: {
                  placeholder: "Search...",
                  showingItems: "Showing Items:",
                  selectedItems: "Selected Items:",
                  totalItems: "Total Items:",
                  size: "Page Size:",
                  first: "First Page",
                  next: "Next Page",
                  previous: "Previous Page",
                  last: "Last Page",
                },
                menu: { text: "Choose Columns:" },
                sort: {
                  ascending: "Sort Ascending",
                  descending: "Sort Descending",
                  none: "Sort None",
                  remove: "Remove Sort",
                },
                column: { hide: "Hide Column" },
                aggregation: {
                  count: "total rows: ",
                  sum: "total: ",
                  avg: "avg: ",
                  min: "min: ",
                  max: "max: ",
                },
                pinning: {
                  pinLeft: "Pin Left",
                  pinRight: "Pin Right",
                  unpin: "Unpin",
                },
                columnMenu: { close: "Close" },
                gridMenu: {
                  aria: { buttonLabel: "Grid Menu" },
                  columns: "Columns:",
                  importerTitle: "Import file",
                  exporterAllAsCsv: "Export all data as csv",
                  exporterVisibleAsCsv: "Export visible data as csv",
                  exporterSelectedAsCsv: "Export selected data as csv",
                  exporterAllAsPdf: "Export all data as pdf",
                  exporterVisibleAsPdf: "Export visible data as pdf",
                  exporterSelectedAsPdf: "Export selected data as pdf",
                  clearAllFilters: "Clear all filters",
                },
                importer: {
                  noHeaders:
                    "Column names were unable to be derived, does the file have a header?",
                  noObjects:
                    "Objects were not able to be derived, was there data in the file other than headers?",
                  invalidCsv:
                    "File was unable to be processed, is it valid CSV?",
                  invalidJson:
                    "File was unable to be processed, is it valid Json?",
                  jsonNotArray:
                    "Imported json file must contain an array, aborting.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Page to first",
                    pageBack: "Page back",
                    pageSelected: "Selected page",
                    pageForward: "Page forward",
                    pageToLast: "Page to last",
                  },
                  sizes: "items per page",
                  totalItems: "items",
                  through: "through",
                  of: "of",
                },
                grouping: {
                  group: "Group",
                  ungroup: "Ungroup",
                  aggregate_count: "Agg: Count",
                  aggregate_sum: "Agg: Sum",
                  aggregate_max: "Agg: Max",
                  aggregate_min: "Agg: Min",
                  aggregate_avg: "Agg: Avg",
                  aggregate_remove: "Agg: Remove",
                },
                validate: {
                  error: "Error:",
                  minLength:
                    "Value should be at least THRESHOLD characters long.",
                  maxLength:
                    "Value should be at most THRESHOLD characters long.",
                  required: "A value is needed.",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("es", {
                aggregate: { label: "Artículos" },
                groupPanel: {
                  description:
                    "Arrastre un encabezado de columna aquí y suéltelo para agrupar por esa columna.",
                },
                search: {
                  placeholder: "Buscar...",
                  showingItems: "Artículos Mostrados:",
                  selectedItems: "Artículos Seleccionados:",
                  totalItems: "Artículos Totales:",
                  size: "Tamaño de Página:",
                  first: "Primera Página",
                  next: "Página Siguiente",
                  previous: "Página Anterior",
                  last: "Última Página",
                },
                menu: { text: "Elegir columnas:" },
                sort: {
                  ascending: "Orden Ascendente",
                  descending: "Orden Descendente",
                  remove: "Sin Ordenar",
                },
                column: { hide: "Ocultar la columna" },
                aggregation: {
                  count: "filas totales: ",
                  sum: "total: ",
                  avg: "media: ",
                  min: "min: ",
                  max: "max: ",
                },
                pinning: {
                  pinLeft: "Fijar a la Izquierda",
                  pinRight: "Fijar a la Derecha",
                  unpin: "Quitar Fijación",
                },
                gridMenu: {
                  columns: "Columnas:",
                  importerTitle: "Importar archivo",
                  exporterAllAsCsv: "Exportar todo como csv",
                  exporterVisibleAsCsv: "Exportar vista como csv",
                  exporterSelectedAsCsv: "Exportar selección como csv",
                  exporterAllAsPdf: "Exportar todo como pdf",
                  exporterVisibleAsPdf: "Exportar vista como pdf",
                  exporterSelectedAsPdf: "Exportar selección como pdf",
                  clearAllFilters: "Limpiar todos los filtros",
                },
                importer: {
                  noHeaders:
                    "No fue posible derivar los nombres de las columnas, ¿tiene encabezados el archivo?",
                  noObjects:
                    "No fue posible obtener registros, ¿contiene datos el archivo, aparte de los encabezados?",
                  invalidCsv:
                    "No fue posible procesar el archivo, ¿es un CSV válido?",
                  invalidJson:
                    "No fue posible procesar el archivo, ¿es un Json válido?",
                  jsonNotArray:
                    "El archivo json importado debe contener un array, abortando.",
                },
                pagination: {
                  sizes: "registros por página",
                  totalItems: "registros",
                  of: "de",
                },
                grouping: {
                  group: "Agrupar",
                  ungroup: "Desagrupar",
                  aggregate_count: "Agr: Cont",
                  aggregate_sum: "Agr: Sum",
                  aggregate_max: "Agr: Máx",
                  aggregate_min: "Agr: Min",
                  aggregate_avg: "Agr: Prom",
                  aggregate_remove: "Agr: Quitar",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("fa", {
                aggregate: { label: "قلم" },
                groupPanel: {
                  description:
                    "عنوان یک ستون را بگیر و به گروهی از آن ستون رها کن.",
                },
                search: {
                  placeholder: "جستجو...",
                  showingItems: "نمایش اقلام:",
                  selectedItems: "قلم‌های انتخاب شده:",
                  totalItems: "مجموع اقلام:",
                  size: "اندازه‌ی صفحه:",
                  first: "اولین صفحه",
                  next: "صفحه‌ی‌بعدی",
                  previous: "صفحه‌ی‌ قبلی",
                  last: "آخرین صفحه",
                },
                menu: { text: "ستون‌های انتخابی:" },
                sort: {
                  ascending: "ترتیب صعودی",
                  descending: "ترتیب نزولی",
                  remove: "حذف مرتب کردن",
                },
                column: { hide: "پنهان‌کردن ستون" },
                aggregation: {
                  count: "تعداد: ",
                  sum: "مجموع: ",
                  avg: "میانگین: ",
                  min: "کمترین: ",
                  max: "بیشترین: ",
                },
                pinning: {
                  pinLeft: "پین کردن سمت چپ",
                  pinRight: "پین کردن سمت راست",
                  unpin: "حذف پین",
                },
                gridMenu: {
                  columns: "ستون‌ها:",
                  importerTitle: "وارد کردن فایل",
                  exporterAllAsCsv: "خروجی تمام داده‌ها در فایل csv",
                  exporterVisibleAsCsv:
                    "خروجی داده‌های قابل مشاهده در فایل csv",
                  exporterSelectedAsCsv:
                    "خروجی داده‌های انتخاب‌شده در فایل csv",
                  exporterAllAsPdf: "خروجی تمام داده‌ها در فایل pdf",
                  exporterVisibleAsPdf:
                    "خروجی داده‌های قابل مشاهده در فایل pdf",
                  exporterSelectedAsPdf:
                    "خروجی داده‌های انتخاب‌شده در فایل pdf",
                  clearAllFilters: "پاک کردن تمام فیلتر",
                },
                importer: {
                  noHeaders: "نام ستون قابل استخراج نیست. آیا فایل عنوان دارد؟",
                  noObjects:
                    "اشیا قابل استخراج نیستند. آیا به جز عنوان‌ها در فایل داده وجود دارد؟",
                  invalidCsv:
                    "فایل قابل پردازش نیست. آیا فرمت  csv  معتبر است؟",
                  invalidJson:
                    "فایل قابل پردازش نیست. آیا فرمت json   معتبر است؟",
                  jsonNotArray:
                    "فایل json وارد شده باید حاوی آرایه باشد. عملیات ساقط شد.",
                },
                pagination: {
                  sizes: "اقلام در هر صفحه",
                  totalItems: "اقلام",
                  of: "از",
                },
                grouping: {
                  group: "گروه‌بندی",
                  ungroup: "حذف گروه‌بندی",
                  aggregate_count: "Agg: تعداد",
                  aggregate_sum: "Agg: جمع",
                  aggregate_max: "Agg: بیشینه",
                  aggregate_min: "Agg: کمینه",
                  aggregate_avg: "Agg: میانگین",
                  aggregate_remove: "Agg: حذف",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("fi", {
                aggregate: { label: "rivit" },
                groupPanel: {
                  description:
                    "Raahaa ja pudota otsikko tähän ryhmittääksesi sarakkeen mukaan.",
                },
                search: {
                  placeholder: "Hae...",
                  showingItems: "Näytetään rivejä:",
                  selectedItems: "Valitut rivit:",
                  totalItems: "Rivejä yht.:",
                  size: "Näytä:",
                  first: "Ensimmäinen sivu",
                  next: "Seuraava sivu",
                  previous: "Edellinen sivu",
                  last: "Viimeinen sivu",
                },
                menu: { text: "Valitse sarakkeet:" },
                sort: {
                  ascending: "Järjestä nouseva",
                  descending: "Järjestä laskeva",
                  remove: "Poista järjestys",
                },
                column: { hide: "Piilota sarake" },
                aggregation: {
                  count: "Rivejä yht.: ",
                  sum: "Summa: ",
                  avg: "K.a.: ",
                  min: "Min: ",
                  max: "Max: ",
                },
                pinning: {
                  pinLeft: "Lukitse vasemmalle",
                  pinRight: "Lukitse oikealle",
                  unpin: "Poista lukitus",
                },
                gridMenu: {
                  columns: "Sarakkeet:",
                  importerTitle: "Tuo tiedosto",
                  exporterAllAsCsv: "Vie tiedot csv-muodossa",
                  exporterVisibleAsCsv: "Vie näkyvä tieto csv-muodossa",
                  exporterSelectedAsCsv: "Vie valittu tieto csv-muodossa",
                  exporterAllAsPdf: "Vie tiedot pdf-muodossa",
                  exporterVisibleAsPdf: "Vie näkyvä tieto pdf-muodossa",
                  exporterSelectedAsPdf: "Vie valittu tieto pdf-muodossa",
                  clearAllFilters: "Puhdista kaikki suodattimet",
                },
                importer: {
                  noHeaders:
                    "Sarakkeen nimiä ei voitu päätellä, onko tiedostossa otsikkoriviä?",
                  noObjects:
                    "Tietoja ei voitu lukea, onko tiedostossa muuta kuin otsikkot?",
                  invalidCsv:
                    "Tiedostoa ei voitu käsitellä, oliko se CSV-muodossa?",
                  invalidJson:
                    "Tiedostoa ei voitu käsitellä, oliko se JSON-muodossa?",
                  jsonNotArray: "Tiedosto ei sisältänyt taulukkoa, lopetetaan.",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("fr", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Filtre de la colonne",
                    removeFilter: "Supprimer le filtre",
                    columnMenuButtonLabel: "Menu de la colonne",
                  },
                  priority: "Priorité:",
                  filterLabel: "Filtre de la colonne: ",
                },
                aggregate: { label: "éléments" },
                groupPanel: {
                  description:
                    "Faites glisser une en-tête de colonne ici pour créer un groupe de colonnes.",
                },
                search: {
                  placeholder: "Recherche...",
                  showingItems: "Affichage des éléments :",
                  selectedItems: "Éléments sélectionnés :",
                  totalItems: "Nombre total d'éléments:",
                  size: "Taille de page:",
                  first: "Première page",
                  next: "Page Suivante",
                  previous: "Page précédente",
                  last: "Dernière page",
                },
                menu: { text: "Choisir des colonnes :" },
                sort: {
                  ascending: "Trier par ordre croissant",
                  descending: "Trier par ordre décroissant",
                  none: "Aucun tri",
                  remove: "Enlever le tri",
                },
                column: { hide: "Cacher la colonne" },
                aggregation: {
                  count: "lignes totales: ",
                  sum: "total: ",
                  avg: "moy: ",
                  min: "min: ",
                  max: "max: ",
                },
                pinning: {
                  pinLeft: "Épingler à gauche",
                  pinRight: "Épingler à droite",
                  unpin: "Détacher",
                },
                columnMenu: { close: "Fermer" },
                gridMenu: {
                  aria: { buttonLabel: "Menu du tableau" },
                  columns: "Colonnes:",
                  importerTitle: "Importer un fichier",
                  exporterAllAsCsv: "Exporter toutes les données en CSV",
                  exporterVisibleAsCsv: "Exporter les données visibles en CSV",
                  exporterSelectedAsCsv:
                    "Exporter les données sélectionnées en CSV",
                  exporterAllAsPdf: "Exporter toutes les données en PDF",
                  exporterVisibleAsPdf: "Exporter les données visibles en PDF",
                  exporterSelectedAsPdf:
                    "Exporter les données sélectionnées en PDF",
                  clearAllFilters: "Nettoyez tous les filtres",
                },
                importer: {
                  noHeaders:
                    "Impossible de déterminer le nom des colonnes, le fichier possède-t-il une en-tête ?",
                  noObjects:
                    "Aucun objet trouvé, le fichier possède-t-il des données autres que l'en-tête ?",
                  invalidCsv:
                    "Le fichier n'a pas pu être traité, le CSV est-il valide ?",
                  invalidJson:
                    "Le fichier n'a pas pu être traité, le JSON est-il valide ?",
                  jsonNotArray:
                    "Le fichier JSON importé doit contenir un tableau, abandon.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Aller à la première page",
                    pageBack: "Page précédente",
                    pageSelected: "Page sélectionnée",
                    pageForward: "Page suivante",
                    pageToLast: "Aller à la dernière page",
                  },
                  sizes: "éléments par page",
                  totalItems: "éléments",
                  through: "à",
                  of: "sur",
                },
                grouping: {
                  group: "Grouper",
                  ungroup: "Dégrouper",
                  aggregate_count: "Agg: Compter",
                  aggregate_sum: "Agg: Somme",
                  aggregate_max: "Agg: Max",
                  aggregate_min: "Agg: Min",
                  aggregate_avg: "Agg: Moy",
                  aggregate_remove: "Agg: Retirer",
                },
                validate: {
                  error: "Erreur:",
                  minLength:
                    "La valeur doit être supérieure ou égale à THRESHOLD caractères.",
                  maxLength:
                    "La valeur doit être inférieure ou égale à THRESHOLD caractères.",
                  required: "Une valeur est nécéssaire.",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("he", {
                aggregate: { label: "items" },
                groupPanel: {
                  description: "גרור עמודה לכאן ושחרר בכדי לקבץ עמודה זו.",
                },
                search: {
                  placeholder: "חפש...",
                  showingItems: "מציג:",
                  selectedItems: 'סה"כ נבחרו:',
                  totalItems: 'סה"כ רשומות:',
                  size: "תוצאות בדף:",
                  first: "דף ראשון",
                  next: "דף הבא",
                  previous: "דף קודם",
                  last: "דף אחרון",
                },
                menu: { text: "בחר עמודות:" },
                sort: {
                  ascending: "סדר עולה",
                  descending: "סדר יורד",
                  remove: "בטל",
                },
                column: { hide: "טור הסתר" },
                aggregation: {
                  count: "total rows: ",
                  sum: "total: ",
                  avg: "avg: ",
                  min: "min: ",
                  max: "max: ",
                },
                gridMenu: {
                  columns: "Columns:",
                  importerTitle: "Import file",
                  exporterAllAsCsv: "Export all data as csv",
                  exporterVisibleAsCsv: "Export visible data as csv",
                  exporterSelectedAsCsv: "Export selected data as csv",
                  exporterAllAsPdf: "Export all data as pdf",
                  exporterVisibleAsPdf: "Export visible data as pdf",
                  exporterSelectedAsPdf: "Export selected data as pdf",
                  clearAllFilters: "Clean all filters",
                },
                importer: {
                  noHeaders:
                    "Column names were unable to be derived, does the file have a header?",
                  noObjects:
                    "Objects were not able to be derived, was there data in the file other than headers?",
                  invalidCsv:
                    "File was unable to be processed, is it valid CSV?",
                  invalidJson:
                    "File was unable to be processed, is it valid Json?",
                  jsonNotArray:
                    "Imported json file must contain an array, aborting.",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("hy", {
                aggregate: { label: "տվյալներ" },
                groupPanel: {
                  description:
                    "Ըստ սյան խմբավորելու համար քաշեք և գցեք վերնագիրն այստեղ։",
                },
                search: {
                  placeholder: "Փնտրում...",
                  showingItems: "Ցուցադրված տվյալներ՝",
                  selectedItems: "Ընտրված:",
                  totalItems: "Ընդամենը՝",
                  size: "Տողերի քանակը էջում՝",
                  first: "Առաջին էջ",
                  next: "Հաջորդ էջ",
                  previous: "Նախորդ էջ",
                  last: "Վերջին էջ",
                },
                menu: { text: "Ընտրել սյուները:" },
                sort: {
                  ascending: "Աճման կարգով",
                  descending: "Նվազման կարգով",
                  remove: "Հանել ",
                },
                column: { hide: "Թաքցնել սյունը" },
                aggregation: {
                  count: "ընդամենը տող՝ ",
                  sum: "ընդամենը՝ ",
                  avg: "միջին՝ ",
                  min: "մին՝ ",
                  max: "մաքս՝ ",
                },
                pinning: {
                  pinLeft: "Կպցնել ձախ կողմում",
                  pinRight: "Կպցնել աջ կողմում",
                  unpin: "Արձակել",
                },
                gridMenu: {
                  columns: "Սյուներ:",
                  importerTitle: "Ներմուծել ֆայլ",
                  exporterAllAsCsv: "Արտահանել ամբողջը CSV",
                  exporterVisibleAsCsv: "Արտահանել երևացող տվյալները CSV",
                  exporterSelectedAsCsv: "Արտահանել ընտրված տվյալները CSV",
                  exporterAllAsPdf: "Արտահանել PDF",
                  exporterVisibleAsPdf: "Արտահանել երևացող տվյալները PDF",
                  exporterSelectedAsPdf: "Արտահանել ընտրված տվյալները PDF",
                  clearAllFilters: "Մաքրել բոլոր ֆիլտրերը",
                },
                importer: {
                  noHeaders:
                    "Հնարավոր չեղավ որոշել սյան վերնագրերը։ Արդյո՞ք ֆայլը ունի վերնագրեր։",
                  noObjects:
                    "Հնարավոր չեղավ կարդալ տվյալները։ Արդյո՞ք ֆայլում կան տվյալներ։",
                  invalidCsv:
                    "Հնարավոր չեղավ մշակել ֆայլը։ Արդյո՞ք այն վավեր CSV է։",
                  invalidJson:
                    "Հնարավոր չեղավ մշակել ֆայլը։ Արդյո՞ք այն վավեր Json է։",
                  jsonNotArray:
                    "Ներմուծված json ֆայլը պետք է պարունակի զանգված, կասեցվում է։",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("it", {
                aggregate: { label: "elementi" },
                groupPanel: {
                  description:
                    "Trascina un'intestazione all'interno del gruppo della colonna.",
                },
                search: {
                  placeholder: "Ricerca...",
                  showingItems: "Mostra:",
                  selectedItems: "Selezionati:",
                  totalItems: "Totali:",
                  size: "Tot Pagine:",
                  first: "Prima",
                  next: "Prossima",
                  previous: "Precedente",
                  last: "Ultima",
                },
                menu: { text: "Scegli le colonne:" },
                sort: {
                  ascending: "Asc.",
                  descending: "Desc.",
                  remove: "Annulla ordinamento",
                },
                column: { hide: "Nascondi" },
                aggregation: {
                  count: "righe totali: ",
                  sum: "tot: ",
                  avg: "media: ",
                  min: "minimo: ",
                  max: "massimo: ",
                },
                pinning: {
                  pinLeft: "Blocca a sx",
                  pinRight: "Blocca a dx",
                  unpin: "Blocca in alto",
                },
                gridMenu: {
                  columns: "Colonne:",
                  importerTitle: "Importa",
                  exporterAllAsCsv: "Esporta tutti i dati in CSV",
                  exporterVisibleAsCsv: "Esporta i dati visibili in CSV",
                  exporterSelectedAsCsv: "Esporta i dati selezionati in CSV",
                  exporterAllAsPdf: "Esporta tutti i dati in PDF",
                  exporterVisibleAsPdf: "Esporta i dati visibili in PDF",
                  exporterSelectedAsPdf: "Esporta i dati selezionati in PDF",
                  clearAllFilters: "Pulire tutti i filtri",
                },
                importer: {
                  noHeaders:
                    "Impossibile reperire i nomi delle colonne, sicuro che siano indicati all'interno del file?",
                  noObjects:
                    "Impossibile reperire gli oggetti, sicuro che siano indicati all'interno del file?",
                  invalidCsv:
                    "Impossibile elaborare il file, sicuro che sia un CSV?",
                  invalidJson:
                    "Impossibile elaborare il file, sicuro che sia un JSON valido?",
                  jsonNotArray:
                    "Errore! Il file JSON da importare deve contenere un array.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Prima",
                    pageBack: "Indietro",
                    pageSelected: "Pagina selezionata",
                    pageForward: "Avanti",
                    pageToLast: "Ultima",
                  },
                  sizes: "elementi per pagina",
                  totalItems: "elementi",
                  through: "a",
                  of: "di",
                },
                grouping: {
                  group: "Raggruppa",
                  ungroup: "Separa",
                  aggregate_count: "Agg: N. Elem.",
                  aggregate_sum: "Agg: Somma",
                  aggregate_max: "Agg: Massimo",
                  aggregate_min: "Agg: Minimo",
                  aggregate_avg: "Agg: Media",
                  aggregate_remove: "Agg: Rimuovi",
                },
                validate: {
                  error: "Errore:",
                  minLength: "Lunghezza minima pari a THRESHOLD caratteri.",
                  maxLength: "Lunghezza massima pari a THRESHOLD caratteri.",
                  required: "Necessario inserire un valore.",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("ja", {
                aggregate: { label: "項目" },
                groupPanel: {
                  description:
                    "ここに列ヘッダをドラッグアンドドロップして、その列でグループ化します。",
                },
                search: {
                  placeholder: "検索...",
                  showingItems: "表示中の項目:",
                  selectedItems: "選択した項目:",
                  totalItems: "項目の総数:",
                  size: "ページサイズ:",
                  first: "最初のページ",
                  next: "次のページ",
                  previous: "前のページ",
                  last: "前のページ",
                },
                menu: { text: "列の選択:" },
                sort: {
                  ascending: "昇順に並べ替え",
                  descending: "降順に並べ替え",
                  remove: "並べ替えの解除",
                },
                column: { hide: "列の非表示" },
                aggregation: {
                  count: "合計行数: ",
                  sum: "合計: ",
                  avg: "平均: ",
                  min: "最小: ",
                  max: "最大: ",
                },
                pinning: {
                  pinLeft: "左に固定",
                  pinRight: "右に固定",
                  unpin: "固定解除",
                },
                gridMenu: {
                  columns: "列:",
                  importerTitle: "ファイルのインポート",
                  exporterAllAsCsv: "すべてのデータをCSV形式でエクスポート",
                  exporterVisibleAsCsv: "表示中のデータをCSV形式でエクスポート",
                  exporterSelectedAsCsv:
                    "選択したデータをCSV形式でエクスポート",
                  exporterAllAsPdf: "すべてのデータをPDF形式でエクスポート",
                  exporterVisibleAsPdf: "表示中のデータをPDF形式でエクスポート",
                  exporterSelectedAsPdf:
                    "選択したデータをPDF形式でエクスポート",
                  clearAllFilters: "すべてのフィルタを清掃してください",
                },
                importer: {
                  noHeaders:
                    "列名を取得できません。ファイルにヘッダが含まれていることを確認してください。",
                  noObjects:
                    "オブジェクトを取得できません。ファイルにヘッダ以外のデータが含まれていることを確認してください。",
                  invalidCsv:
                    "ファイルを処理できません。ファイルが有効なCSV形式であることを確認してください。",
                  invalidJson:
                    "ファイルを処理できません。ファイルが有効なJSON形式であることを確認してください。",
                  jsonNotArray:
                    "インポートしたJSONファイルには配列が含まれている必要があります。処理を中止します。",
                },
                pagination: {
                  aria: {
                    pageToFirst: "最初のページ",
                    pageBack: "前のページ",
                    pageSelected: "現在のページ",
                    pageForward: "次のページ",
                    pageToLast: "最後のページ",
                  },
                  sizes: "項目/ページ",
                  totalItems: "項目",
                  through: "から",
                  of: "項目/全",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("ko", {
                aggregate: { label: "아이템" },
                groupPanel: {
                  description:
                    "컬럼으로 그룹핑하기 위해서는 컬럼 헤더를 끌어 떨어뜨려 주세요.",
                },
                search: {
                  placeholder: "검색...",
                  showingItems: "항목 보여주기:",
                  selectedItems: "선택 항목:",
                  totalItems: "전체 항목:",
                  size: "페이지 크기:",
                  first: "첫번째 페이지",
                  next: "다음 페이지",
                  previous: "이전 페이지",
                  last: "마지막 페이지",
                },
                menu: { text: "컬럼을 선택하세요:" },
                sort: {
                  ascending: "오름차순 정렬",
                  descending: "내림차순 정렬",
                  remove: "소팅 제거",
                },
                column: { hide: "컬럼 제거" },
                aggregation: {
                  count: "전체 갯수: ",
                  sum: "전체: ",
                  avg: "평균: ",
                  min: "최소: ",
                  max: "최대: ",
                },
                pinning: {
                  pinLeft: "왼쪽 핀",
                  pinRight: "오른쪽 핀",
                  unpin: "핀 제거",
                },
                gridMenu: {
                  columns: "컬럼:",
                  importerTitle: "파일 가져오기",
                  exporterAllAsCsv: "csv로 모든 데이터 내보내기",
                  exporterVisibleAsCsv: "csv로 보이는 데이터 내보내기",
                  exporterSelectedAsCsv: "csv로 선택된 데이터 내보내기",
                  exporterAllAsPdf: "pdf로 모든 데이터 내보내기",
                  exporterVisibleAsPdf: "pdf로 보이는 데이터 내보내기",
                  exporterSelectedAsPdf: "pdf로 선택 데이터 내보내기",
                  clearAllFilters: "모든 필터를 청소",
                },
                importer: {
                  noHeaders:
                    "컬럼명이 지정되어 있지 않습니다. 파일에 헤더가 명시되어 있는지 확인해 주세요.",
                  noObjects:
                    "데이터가 지정되어 있지 않습니다. 데이터가 파일에 있는지 확인해 주세요.",
                  invalidCsv:
                    "파일을 처리할 수 없습니다. 올바른 csv인지 확인해 주세요.",
                  invalidJson:
                    "파일을 처리할 수 없습니다. 올바른 json인지 확인해 주세요.",
                  jsonNotArray: "json 파일은 배열을 포함해야 합니다.",
                },
                pagination: { sizes: "페이지당 항목", totalItems: "전체 항목" },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("nl", {
                aggregate: { label: "items" },
                groupPanel: {
                  description:
                    "Sleep hier een kolomnaam heen om op te groeperen.",
                },
                search: {
                  placeholder: "Zoeken...",
                  showingItems: "Getoonde items:",
                  selectedItems: "Geselecteerde items:",
                  totalItems: "Totaal aantal items:",
                  size: "Items per pagina:",
                  first: "Eerste pagina",
                  next: "Volgende pagina",
                  previous: "Vorige pagina",
                  last: "Laatste pagina",
                },
                menu: { text: "Kies kolommen:" },
                sort: {
                  ascending: "Sorteer oplopend",
                  descending: "Sorteer aflopend",
                  remove: "Verwijder sortering",
                },
                column: { hide: "Verberg kolom" },
                aggregation: {
                  count: "Aantal rijen: ",
                  sum: "Som: ",
                  avg: "Gemiddelde: ",
                  min: "Min: ",
                  max: "Max: ",
                },
                pinning: {
                  pinLeft: "Zet links vast",
                  pinRight: "Zet rechts vast",
                  unpin: "Maak los",
                },
                gridMenu: {
                  columns: "Kolommen:",
                  importerTitle: "Importeer bestand",
                  exporterAllAsCsv: "Exporteer alle data als csv",
                  exporterVisibleAsCsv: "Exporteer zichtbare data als csv",
                  exporterSelectedAsCsv: "Exporteer geselecteerde data als csv",
                  exporterAllAsPdf: "Exporteer alle data als pdf",
                  exporterVisibleAsPdf: "Exporteer zichtbare data als pdf",
                  exporterSelectedAsPdf: "Exporteer geselecteerde data als pdf",
                  clearAllFilters: "Reinig alle filters",
                },
                importer: {
                  noHeaders:
                    "Kolomnamen kunnen niet worden afgeleid. Heeft het bestand een header?",
                  noObjects:
                    "Objecten kunnen niet worden afgeleid. Bevat het bestand data naast de headers?",
                  invalidCsv:
                    "Het bestand kan niet verwerkt worden. Is het een valide csv bestand?",
                  invalidJson:
                    "Het bestand kan niet verwerkt worden. Is het valide json?",
                  jsonNotArray:
                    "Het json bestand moet een array bevatten. De actie wordt geannuleerd.",
                },
                pagination: {
                  sizes: "items per pagina",
                  totalItems: "items",
                  of: "van de",
                },
                grouping: {
                  group: "Groepeer",
                  ungroup: "Groepering opheffen",
                  aggregate_count: "Agg: Aantal",
                  aggregate_sum: "Agg: Som",
                  aggregate_max: "Agg: Max",
                  aggregate_min: "Agg: Min",
                  aggregate_avg: "Agg: Gem",
                  aggregate_remove: "Agg: Verwijder",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("no", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Filter for column",
                    removeFilter: "Remove Filter",
                    columnMenuButtonLabel: "Column Menu",
                  },
                  priority: "Priority:",
                  filterLabel: "Filter for column: ",
                },
                aggregate: { label: "items" },
                groupPanel: {
                  description:
                    "Drag a column header here and drop it to group by that column.",
                },
                search: {
                  placeholder: "Search...",
                  showingItems: "Showing Items:",
                  selectedItems: "Selected Items:",
                  totalItems: "Total Items:",
                  size: "Page Size:",
                  first: "First Page",
                  next: "Next Page",
                  previous: "Previous Page",
                  last: "Last Page",
                },
                menu: { text: "Choose Columns:" },
                sort: {
                  ascending: "Sort Ascending",
                  descending: "Sort Descending",
                  none: "Sort None",
                  remove: "Remove Sort",
                },
                column: { hide: "Hide Column" },
                aggregation: {
                  count: "total rows: ",
                  sum: "total: ",
                  avg: "avg: ",
                  min: "min: ",
                  max: "max: ",
                },
                pinning: {
                  pinLeft: "Pin Left",
                  pinRight: "Pin Right",
                  unpin: "Unpin",
                },
                columnMenu: { close: "Close" },
                gridMenu: {
                  aria: { buttonLabel: "Grid Menu" },
                  columns: "Kolonner:",
                  importerTitle: "Importer fil",
                  exporterAllAsCsv: "Eksporter alle data som csv",
                  exporterVisibleAsCsv: "Eksporter synlige data som csv",
                  exporterSelectedAsCsv: "Eksporter utvalgte data som csv",
                  exporterAllAsPdf: "Eksporter alle data som pdf",
                  exporterVisibleAsPdf: "Eksporter synlige data som pdf",
                  exporterSelectedAsPdf: "Eksporter utvalgte data som pdf",
                  clearAllFilters: "Clear all filters",
                },
                importer: {
                  noHeaders:
                    "Column names were unable to be derived, does the file have a header?",
                  noObjects:
                    "Objects were not able to be derived, was there data in the file other than headers?",
                  invalidCsv:
                    "File was unable to be processed, is it valid CSV?",
                  invalidJson:
                    "File was unable to be processed, is it valid Json?",
                  jsonNotArray:
                    "Imported json file must contain an array, aborting.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Page to first",
                    pageBack: "Page back",
                    pageSelected: "Selected page",
                    pageForward: "Page forward",
                    pageToLast: "Page to last",
                  },
                  sizes: "items per page",
                  totalItems: "items",
                  through: "through",
                  of: "of",
                },
                grouping: {
                  group: "Group",
                  ungroup: "Ungroup",
                  aggregate_count: "Agg: Count",
                  aggregate_sum: "Agg: Sum",
                  aggregate_max: "Agg: Max",
                  aggregate_min: "Agg: Min",
                  aggregate_avg: "Agg: Avg",
                  aggregate_remove: "Agg: Remove",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("pl", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Filtr dla kolumny",
                    removeFilter: "Usuń filtr",
                    columnMenuButtonLabel: "Menu kolumny",
                  },
                  priority: "Prioritet:",
                  filterLabel: "Filtr dla kolumny: ",
                },
                aggregate: { label: "pozycji" },
                groupPanel: {
                  description:
                    "Przeciągnij nagłówek kolumny tutaj, aby pogrupować według niej.",
                },
                search: {
                  placeholder: "Szukaj...",
                  showingItems: "Widoczne pozycje:",
                  selectedItems: "Zaznaczone pozycje:",
                  totalItems: "Wszystkich pozycji:",
                  size: "Rozmiar strony:",
                  first: "Pierwsza strona",
                  next: "Następna strona",
                  previous: "Poprzednia strona",
                  last: "Ostatnia strona",
                },
                menu: { text: "Wybierz kolumny:" },
                sort: {
                  ascending: "Sortuj rosnąco",
                  descending: "Sortuj malejąco",
                  none: "Brak sortowania",
                  remove: "Wyłącz sortowanie",
                },
                column: { hide: "Ukryj kolumne" },
                aggregation: {
                  count: "Razem pozycji: ",
                  sum: "Razem: ",
                  avg: "Średnia: ",
                  min: "Min: ",
                  max: "Max: ",
                },
                pinning: {
                  pinLeft: "Przypnij do lewej",
                  pinRight: "Przypnij do prawej",
                  unpin: "Odepnij",
                },
                columnMenu: { close: "Zamknij" },
                gridMenu: {
                  aria: { buttonLabel: "Menu Grida" },
                  columns: "Kolumny:",
                  importerTitle: "Importuj plik",
                  exporterAllAsCsv: "Eksportuj wszystkie dane do csv",
                  exporterVisibleAsCsv: "Eksportuj widoczne dane do csv",
                  exporterSelectedAsCsv: "Eksportuj zaznaczone dane do csv",
                  exporterAllAsPdf: "Eksportuj wszystkie dane do pdf",
                  exporterVisibleAsPdf: "Eksportuj widoczne dane do pdf",
                  exporterSelectedAsPdf: "Eksportuj zaznaczone dane do pdf",
                  clearAllFilters: "Wyczyść filtry",
                },
                importer: {
                  noHeaders:
                    "Nie udało się wczytać nazw kolumn. Czy plik posiada nagłówek?",
                  noObjects:
                    "Nie udalo się wczytać pozycji. Czy plik zawiera dane??",
                  invalidCsv:
                    "Nie udało się przetworzyć pliku, jest to prawidlowy plik CSV??",
                  invalidJson:
                    "Nie udało się przetworzyć pliku, jest to prawidlowy plik Json?",
                  jsonNotArray:
                    "Importowany plik json musi zawierać tablicę, importowanie przerwane.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Pierwsza strona",
                    pageBack: "Poprzednia strona",
                    pageSelected: "Wybrana strona",
                    pageForward: "Następna strona",
                    pageToLast: "Ostatnia strona",
                  },
                  sizes: "pozycji na stronę",
                  totalItems: "pozycji",
                  through: "do",
                  of: "z",
                },
                grouping: {
                  group: "Grupuj",
                  ungroup: "Rozgrupuj",
                  aggregate_count: "Zbiorczo: Razem",
                  aggregate_sum: "Zbiorczo: Suma",
                  aggregate_max: "Zbiorczo: Max",
                  aggregate_min: "Zbiorczo: Min",
                  aggregate_avg: "Zbiorczo: Średnia",
                  aggregate_remove: "Zbiorczo: Usuń",
                },
                validate: {
                  error: "Błąd:",
                  minLength:
                    "Wartość powinna składać się z co najmniej THRESHOLD znaków.",
                  maxLength:
                    "Wartość powinna składać się z przynajmniej THRESHOLD znaków.",
                  required: "Wartość jest wymagana.",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("pt-br", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Filtro por coluna",
                    removeFilter: "Remover filtro",
                    columnMenuButtonLabel: "Menu coluna",
                  },
                  priority: "Prioridade:",
                  filterLabel: "Filtro por coluna: ",
                },
                aggregate: { label: "itens" },
                groupPanel: {
                  description:
                    "Arraste e solte uma coluna aqui para agrupar por essa coluna",
                },
                search: {
                  placeholder: "Procurar...",
                  showingItems: "Mostrando os Itens:",
                  selectedItems: "Items Selecionados:",
                  totalItems: "Total de Itens:",
                  size: "Tamanho da Página:",
                  first: "Primeira Página",
                  next: "Próxima Página",
                  previous: "Página Anterior",
                  last: "Última Página",
                },
                menu: { text: "Selecione as colunas:" },
                sort: {
                  ascending: "Ordenar Ascendente",
                  descending: "Ordenar Descendente",
                  none: "Nenhuma Ordem",
                  remove: "Remover Ordenação",
                },
                column: { hide: "Esconder coluna" },
                aggregation: {
                  count: "total de linhas: ",
                  sum: "total: ",
                  avg: "med: ",
                  min: "min: ",
                  max: "max: ",
                },
                pinning: {
                  pinLeft: "Fixar Esquerda",
                  pinRight: "Fixar Direita",
                  unpin: "Desprender",
                },
                columnMenu: { close: "Fechar" },
                gridMenu: {
                  aria: { buttonLabel: "Menu Grid" },
                  columns: "Colunas:",
                  importerTitle: "Importar arquivo",
                  exporterAllAsCsv: "Exportar todos os dados como csv",
                  exporterVisibleAsCsv: "Exportar dados visíveis como csv",
                  exporterSelectedAsCsv: "Exportar dados selecionados como csv",
                  exporterAllAsPdf: "Exportar todos os dados como pdf",
                  exporterVisibleAsPdf: "Exportar dados visíveis como pdf",
                  exporterSelectedAsPdf: "Exportar dados selecionados como pdf",
                  clearAllFilters: "Limpar todos os filtros",
                },
                importer: {
                  noHeaders:
                    "Nomes de colunas não puderam ser derivados. O arquivo tem um cabeçalho?",
                  noObjects:
                    "Objetos não puderam ser derivados. Havia dados no arquivo, além dos cabeçalhos?",
                  invalidCsv:
                    "Arquivo não pode ser processado. É um CSV válido?",
                  invalidJson:
                    "Arquivo não pode ser processado. É um Json válido?",
                  jsonNotArray:
                    "Arquivo json importado tem que conter um array. Abortando.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Primeira página",
                    pageBack: "Página anterior",
                    pageSelected: "Página Selecionada",
                    pageForward: "Proxima",
                    pageToLast: "Anterior",
                  },
                  sizes: "itens por página",
                  totalItems: "itens",
                  through: "através dos",
                  of: "de",
                },
                grouping: {
                  group: "Agrupar",
                  ungroup: "Desagrupar",
                  aggregate_count: "Agr: Contar",
                  aggregate_sum: "Agr: Soma",
                  aggregate_max: "Agr: Max",
                  aggregate_min: "Agr: Min",
                  aggregate_avg: "Agr: Med",
                  aggregate_remove: "Agr: Remover",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("pt", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Filtro por coluna",
                    removeFilter: "Remover filtro",
                    columnMenuButtonLabel: "Menu coluna",
                  },
                  priority: "Prioridade:",
                  filterLabel: "Filtro por coluna: ",
                },
                aggregate: { label: "itens" },
                groupPanel: {
                  description:
                    "Arraste e solte uma coluna aqui para agrupar por essa coluna",
                },
                search: {
                  placeholder: "Procurar...",
                  showingItems: "Mostrando os Itens:",
                  selectedItems: "Itens Selecionados:",
                  totalItems: "Total de Itens:",
                  size: "Tamanho da Página:",
                  first: "Primeira Página",
                  next: "Próxima Página",
                  previous: "Página Anterior",
                  last: "Última Página",
                },
                menu: { text: "Selecione as colunas:" },
                sort: {
                  ascending: "Ordenar Ascendente",
                  descending: "Ordenar Descendente",
                  none: "Nenhuma Ordem",
                  remove: "Remover Ordenação",
                },
                column: { hide: "Esconder coluna" },
                aggregation: {
                  count: "total de linhas: ",
                  sum: "total: ",
                  avg: "med: ",
                  min: "min: ",
                  max: "max: ",
                },
                pinning: {
                  pinLeft: "Fixar Esquerda",
                  pinRight: "Fixar Direita",
                  unpin: "Desprender",
                },
                columnMenu: { close: "Fechar" },
                gridMenu: {
                  aria: { buttonLabel: "Menu Grid" },
                  columns: "Colunas:",
                  importerTitle: "Importar ficheiro",
                  exporterAllAsCsv: "Exportar todos os dados como csv",
                  exporterVisibleAsCsv: "Exportar dados visíveis como csv",
                  exporterSelectedAsCsv: "Exportar dados selecionados como csv",
                  exporterAllAsPdf: "Exportar todos os dados como pdf",
                  exporterVisibleAsPdf: "Exportar dados visíveis como pdf",
                  exporterSelectedAsPdf: "Exportar dados selecionados como pdf",
                  clearAllFilters: "Limpar todos os filtros",
                },
                importer: {
                  noHeaders:
                    "Nomes de colunas não puderam ser derivados. O ficheiro tem um cabeçalho?",
                  noObjects:
                    "Objetos não puderam ser derivados. Havia dados no ficheiro, além dos cabeçalhos?",
                  invalidCsv:
                    "Ficheiro não pode ser processado. É um CSV válido?",
                  invalidJson:
                    "Ficheiro não pode ser processado. É um Json válido?",
                  jsonNotArray:
                    "Ficheiro json importado tem que conter um array. Interrompendo.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Primeira página",
                    pageBack: "Página anterior",
                    pageSelected: "Página Selecionada",
                    pageForward: "Próxima",
                    pageToLast: "Anterior",
                  },
                  sizes: "itens por página",
                  totalItems: "itens",
                  through: "através dos",
                  of: "de",
                },
                grouping: {
                  group: "Agrupar",
                  ungroup: "Desagrupar",
                  aggregate_count: "Agr: Contar",
                  aggregate_sum: "Agr: Soma",
                  aggregate_max: "Agr: Max",
                  aggregate_min: "Agr: Min",
                  aggregate_avg: "Agr: Med",
                  aggregate_remove: "Agr: Remover",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("ro", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Filtru pentru coloana",
                    removeFilter: "Sterge filtru",
                    columnMenuButtonLabel: "Column Menu",
                  },
                  priority: "Prioritate:",
                  filterLabel: "Filtru pentru coloana:",
                },
                aggregate: { label: "Elemente" },
                groupPanel: {
                  description:
                    "Trage un cap de coloana aici pentru a grupa elementele dupa coloana respectiva",
                },
                search: {
                  placeholder: "Cauta...",
                  showingItems: "Arata elementele:",
                  selectedItems: "Elementele selectate:",
                  totalItems: "Total elemente:",
                  size: "Marime pagina:",
                  first: "Prima pagina",
                  next: "Pagina urmatoare",
                  previous: "Pagina anterioara",
                  last: "Ultima pagina",
                },
                menu: { text: "Alege coloane:" },
                sort: {
                  ascending: "Ordoneaza crescator",
                  descending: "Ordoneaza descrescator",
                  none: "Fara ordonare",
                  remove: "Sterge ordonarea",
                },
                column: { hide: "Ascunde coloana" },
                aggregation: {
                  count: "total linii: ",
                  sum: "total: ",
                  avg: "medie: ",
                  min: "min: ",
                  max: "max: ",
                },
                pinning: {
                  pinLeft: "Pin la stanga",
                  pinRight: "Pin la dreapta",
                  unpin: "Sterge pinul",
                },
                columnMenu: { close: "Inchide" },
                gridMenu: {
                  aria: { buttonLabel: "Grid Menu" },
                  columns: "Coloane:",
                  importerTitle: "Incarca fisier",
                  exporterAllAsCsv: "Exporta toate datele ca csv",
                  exporterVisibleAsCsv: "Exporta datele vizibile ca csv",
                  exporterSelectedAsCsv: "Exporta datele selectate ca csv",
                  exporterAllAsPdf: "Exporta toate datele ca pdf",
                  exporterVisibleAsPdf: "Exporta datele vizibile ca pdf",
                  exporterSelectedAsPdf: "Exporta datele selectate ca csv pdf",
                  clearAllFilters: "Sterge toate filtrele",
                },
                importer: {
                  noHeaders:
                    "Numele coloanelor nu a putut fi incarcat, acest fisier are un header?",
                  noObjects:
                    "Datele nu au putut fi incarcate, exista date in fisier in afara numelor de coloane?",
                  invalidCsv:
                    "Fisierul nu a putut fi procesat, ati incarcat un CSV valid ?",
                  invalidJson:
                    "Fisierul nu a putut fi procesat, ati incarcat un Json valid?",
                  jsonNotArray:
                    "Json-ul incarcat trebuie sa contina un array, inchidere.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Prima pagina",
                    pageBack: "O pagina inapoi",
                    pageSelected: "Pagina selectata",
                    pageForward: "O pagina inainte",
                    pageToLast: "Ultima pagina",
                  },
                  sizes: "Elemente per pagina",
                  totalItems: "elemente",
                  through: "prin",
                  of: "of",
                },
                grouping: {
                  group: "Grupeaza",
                  ungroup: "Opreste gruparea",
                  aggregate_count: "Agg: Count",
                  aggregate_sum: "Agg: Sum",
                  aggregate_max: "Agg: Max",
                  aggregate_min: "Agg: Min",
                  aggregate_avg: "Agg: Avg",
                  aggregate_remove: "Agg: Remove",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("ru", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Фильтр столбца",
                    removeFilter: "Удалить фильтр",
                    columnMenuButtonLabel: "Меню столбца",
                  },
                  priority: "Приоритет:",
                  filterLabel: "Фильтр столбца: ",
                },
                aggregate: { label: "элементы" },
                groupPanel: {
                  description:
                    "Для группировки по столбцу перетащите сюда его название.",
                },
                search: {
                  placeholder: "Поиск...",
                  showingItems: "Показать элементы:",
                  selectedItems: "Выбранные элементы:",
                  totalItems: "Всего элементов:",
                  size: "Размер страницы:",
                  first: "Первая страница",
                  next: "Следующая страница",
                  previous: "Предыдущая страница",
                  last: "Последняя страница",
                },
                menu: { text: "Выбрать столбцы:" },
                sort: {
                  ascending: "По возрастанию",
                  descending: "По убыванию",
                  none: "Без сортировки",
                  remove: "Убрать сортировку",
                },
                column: { hide: "Спрятать столбец" },
                aggregation: {
                  count: "всего строк: ",
                  sum: "итого: ",
                  avg: "среднее: ",
                  min: "мин: ",
                  max: "макс: ",
                },
                pinning: {
                  pinLeft: "Закрепить слева",
                  pinRight: "Закрепить справа",
                  unpin: "Открепить",
                },
                columnMenu: { close: "Закрыть" },
                gridMenu: {
                  aria: { buttonLabel: "Меню" },
                  columns: "Столбцы:",
                  importerTitle: "Импортировать файл",
                  exporterAllAsCsv: "Экспортировать всё в CSV",
                  exporterVisibleAsCsv: "Экспортировать видимые данные в CSV",
                  exporterSelectedAsCsv:
                    "Экспортировать выбранные данные в CSV",
                  exporterAllAsPdf: "Экспортировать всё в PDF",
                  exporterVisibleAsPdf: "Экспортировать видимые данные в PDF",
                  exporterSelectedAsPdf:
                    "Экспортировать выбранные данные в PDF",
                  clearAllFilters: "Очистите все фильтры",
                },
                importer: {
                  noHeaders:
                    "Не удалось получить названия столбцов, есть ли в файле заголовок?",
                  noObjects:
                    "Не удалось получить данные, есть ли в файле строки кроме заголовка?",
                  invalidCsv:
                    "Не удалось обработать файл, это правильный CSV-файл?",
                  invalidJson:
                    "Не удалось обработать файл, это правильный JSON?",
                  jsonNotArray:
                    "Импортируемый JSON-файл должен содержать массив, операция отменена.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Первая страница",
                    pageBack: "Предыдущая страница",
                    pageSelected: "Выбранная страница",
                    pageForward: "Следующая страница",
                    pageToLast: "Последняя страница",
                  },
                  sizes: "строк на страницу",
                  totalItems: "строк",
                  through: "по",
                  of: "из",
                },
                grouping: {
                  group: "Группировать",
                  ungroup: "Разгруппировать",
                  aggregate_count: "Группировать: Count",
                  aggregate_sum: "Для группы: Сумма",
                  aggregate_max: "Для группы: Максимум",
                  aggregate_min: "Для группы: Минимум",
                  aggregate_avg: "Для группы: Среднее",
                  aggregate_remove: "Для группы: Пусто",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("sk", {
                aggregate: { label: "items" },
                groupPanel: {
                  description:
                    "Pretiahni sem názov stĺpca pre zoskupenie podľa toho stĺpca.",
                },
                search: {
                  placeholder: "Hľadaj...",
                  showingItems: "Zobrazujem položky:",
                  selectedItems: "Vybraté položky:",
                  totalItems: "Počet položiek:",
                  size: "Počet:",
                  first: "Prvá strana",
                  next: "Ďalšia strana",
                  previous: "Predchádzajúca strana",
                  last: "Posledná strana",
                },
                menu: { text: "Vyberte stĺpce:" },
                sort: {
                  ascending: "Zotriediť vzostupne",
                  descending: "Zotriediť zostupne",
                  remove: "Vymazať triedenie",
                },
                aggregation: {
                  count: "total rows: ",
                  sum: "total: ",
                  avg: "avg: ",
                  min: "min: ",
                  max: "max: ",
                },
                gridMenu: {
                  columns: "Columns:",
                  importerTitle: "Import file",
                  exporterAllAsCsv: "Export all data as csv",
                  exporterVisibleAsCsv: "Export visible data as csv",
                  exporterSelectedAsCsv: "Export selected data as csv",
                  exporterAllAsPdf: "Export all data as pdf",
                  exporterVisibleAsPdf: "Export visible data as pdf",
                  exporterSelectedAsPdf: "Export selected data as pdf",
                  clearAllFilters: "Clear all filters",
                },
                importer: {
                  noHeaders:
                    "Column names were unable to be derived, does the file have a header?",
                  noObjects:
                    "Objects were not able to be derived, was there data in the file other than headers?",
                  invalidCsv:
                    "File was unable to be processed, is it valid CSV?",
                  invalidJson:
                    "File was unable to be processed, is it valid Json?",
                  jsonNotArray:
                    "Imported json file must contain an array, aborting.",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("sv", {
                aggregate: { label: "Artiklar" },
                groupPanel: {
                  description:
                    "Dra en kolumnrubrik hit och släpp den för att gruppera efter den kolumnen.",
                },
                search: {
                  placeholder: "Sök...",
                  showingItems: "Visar artiklar:",
                  selectedItems: "Valda artiklar:",
                  totalItems: "Antal artiklar:",
                  size: "Sidstorlek:",
                  first: "Första sidan",
                  next: "Nästa sida",
                  previous: "Föregående sida",
                  last: "Sista sidan",
                },
                menu: { text: "Välj kolumner:" },
                sort: {
                  ascending: "Sortera stigande",
                  descending: "Sortera fallande",
                  remove: "Inaktivera sortering",
                },
                column: { hide: "Göm kolumn" },
                aggregation: {
                  count: "Antal rader: ",
                  sum: "Summa: ",
                  avg: "Genomsnitt: ",
                  min: "Min: ",
                  max: "Max: ",
                },
                pinning: {
                  pinLeft: "Fäst vänster",
                  pinRight: "Fäst höger",
                  unpin: "Lösgör",
                },
                gridMenu: {
                  columns: "Kolumner:",
                  importerTitle: "Importera fil",
                  exporterAllAsCsv: "Exportera all data som CSV",
                  exporterVisibleAsCsv: "Exportera synlig data som CSV",
                  exporterSelectedAsCsv: "Exportera markerad data som CSV",
                  exporterAllAsPdf: "Exportera all data som PDF",
                  exporterVisibleAsPdf: "Exportera synlig data som PDF",
                  exporterSelectedAsPdf: "Exportera markerad data som PDF",
                  clearAllFilters: "Rengör alla filter",
                },
                importer: {
                  noHeaders:
                    "Kolumnnamn kunde inte härledas. Har filen ett sidhuvud?",
                  noObjects:
                    "Objekt kunde inte härledas. Har filen data undantaget sidhuvud?",
                  invalidCsv:
                    "Filen kunde inte behandlas, är den en giltig CSV?",
                  invalidJson:
                    "Filen kunde inte behandlas, är den en giltig JSON?",
                  jsonNotArray:
                    "Importerad JSON-fil måste innehålla ett fält. Import avbruten.",
                },
                pagination: {
                  sizes: "Artiklar per sida",
                  totalItems: "Artiklar",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("ta", {
                aggregate: { label: "உருப்படிகள்" },
                groupPanel: {
                  description:
                    "ஒரு பத்தியை குழுவாக அமைக்க அப்பத்தியின் தலைப்பை இங்கே  இழுத்து வரவும் ",
                },
                search: {
                  placeholder: "தேடல் ...",
                  showingItems: "உருப்படிகளை காண்பித்தல்:",
                  selectedItems: "தேர்ந்தெடுக்கப்பட்ட  உருப்படிகள்:",
                  totalItems: "மொத்த உருப்படிகள்:",
                  size: "பக்க அளவு: ",
                  first: "முதல் பக்கம்",
                  next: "அடுத்த பக்கம்",
                  previous: "முந்தைய பக்கம் ",
                  last: "இறுதி பக்கம்",
                },
                menu: { text: "பத்திகளை தேர்ந்தெடு:" },
                sort: {
                  ascending: "மேலிருந்து கீழாக",
                  descending: "கீழிருந்து மேலாக",
                  remove: "வரிசையை நீக்கு",
                },
                column: { hide: "பத்தியை மறைத்து வை " },
                aggregation: {
                  count: "மொத்த வரிகள்:",
                  sum: "மொத்தம்: ",
                  avg: "சராசரி: ",
                  min: "குறைந்தபட்ச: ",
                  max: "அதிகபட்ச: ",
                },
                pinning: {
                  pinLeft: "இடதுபுறமாக தைக்க ",
                  pinRight: "வலதுபுறமாக தைக்க",
                  unpin: "பிரி",
                },
                gridMenu: {
                  columns: "பத்திகள்:",
                  importerTitle: "கோப்பு : படித்தல்",
                  exporterAllAsCsv: "எல்லா தரவுகளையும் கோப்பாக்கு: csv",
                  exporterVisibleAsCsv: "இருக்கும் தரவுகளை கோப்பாக்கு: csv",
                  exporterSelectedAsCsv:
                    "தேர்ந்தெடுத்த தரவுகளை கோப்பாக்கு: csv",
                  exporterAllAsPdf: "எல்லா தரவுகளையும் கோப்பாக்கு: pdf",
                  exporterVisibleAsPdf: "இருக்கும் தரவுகளை கோப்பாக்கு: pdf",
                  exporterSelectedAsPdf:
                    "தேர்ந்தெடுத்த தரவுகளை கோப்பாக்கு: pdf",
                  clearAllFilters: "Clear all filters",
                },
                importer: {
                  noHeaders:
                    "பத்தியின் தலைப்புகளை பெற இயலவில்லை, கோப்பிற்கு தலைப்பு உள்ளதா?",
                  noObjects:
                    "இலக்குகளை உருவாக்க முடியவில்லை, கோப்பில் தலைப்புகளை தவிர தரவு ஏதேனும் உள்ளதா? ",
                  invalidCsv:
                    "சரிவர நடைமுறை படுத்த இயலவில்லை, கோப்பு சரிதானா? - csv",
                  invalidJson:
                    "சரிவர நடைமுறை படுத்த இயலவில்லை, கோப்பு சரிதானா? - json",
                  jsonNotArray:
                    "படித்த கோப்பில் வரிசைகள் உள்ளது, நடைமுறை ரத்து செய் : json",
                },
                pagination: {
                  sizes: "உருப்படிகள் / பக்கம்",
                  totalItems: "உருப்படிகள் ",
                },
                grouping: {
                  group: "குழு",
                  ungroup: "பிரி",
                  aggregate_count: "மதிப்பீட்டு : எண்ணு",
                  aggregate_sum: "மதிப்பீட்டு : கூட்டல்",
                  aggregate_max: "மதிப்பீட்டு : அதிகபட்சம்",
                  aggregate_min: "மதிப்பீட்டு : குறைந்தபட்சம்",
                  aggregate_avg: "மதிப்பீட்டு : சராசரி",
                  aggregate_remove: "மதிப்பீட்டு : நீக்கு",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("tr", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Sütun için filtre",
                    removeFilter: "Filtreyi Kaldır",
                    columnMenuButtonLabel: "Sütun Menüsü",
                  },
                  priority: "Öncelik:",
                  filterLabel: "Sütun için filtre: ",
                },
                aggregate: { label: "kayıtlar" },
                groupPanel: {
                  description:
                    "Sütuna göre gruplamak için sütun başlığını buraya sürükleyin ve bırakın.",
                },
                search: {
                  placeholder: "Arama...",
                  showingItems: "Gösterilen Kayıt:",
                  selectedItems: "Seçili Kayıt:",
                  totalItems: "Toplam Kayıt:",
                  size: "Sayfa Boyutu:",
                  first: "İlk Sayfa",
                  next: "Sonraki Sayfa",
                  previous: "Önceki Sayfa",
                  last: "Son Sayfa",
                },
                menu: { text: "Sütunları Seç:" },
                sort: {
                  ascending: "Artan Sırada Sırala",
                  descending: "Azalan Sırada Sırala",
                  none: "Sıralama Yapma",
                  remove: "Sıralamayı Kaldır",
                },
                column: { hide: "Sütunu Gizle" },
                aggregation: {
                  count: "toplam satır: ",
                  sum: "toplam: ",
                  avg: "ort: ",
                  min: "min: ",
                  max: "maks: ",
                },
                pinning: {
                  pinLeft: "Sola Sabitle",
                  pinRight: "Sağa Sabitle",
                  unpin: "Sabitlemeyi Kaldır",
                },
                columnMenu: { close: "Kapat" },
                gridMenu: {
                  aria: { buttonLabel: "Tablo Menü" },
                  columns: "Sütunlar:",
                  importerTitle: "Dosya içeri aktar",
                  exporterAllAsCsv: "Bütün veriyi CSV olarak dışarı aktar",
                  exporterVisibleAsCsv:
                    "Görünen veriyi CSV olarak dışarı aktar",
                  exporterSelectedAsCsv:
                    "Seçili veriyi CSV olarak dışarı aktar",
                  exporterAllAsPdf: "Bütün veriyi PDF olarak dışarı aktar",
                  exporterVisibleAsPdf:
                    "Görünen veriyi PDF olarak dışarı aktar",
                  exporterSelectedAsPdf:
                    "Seçili veriyi PDF olarak dışarı aktar",
                  clearAllFilters: "Bütün filtreleri kaldır",
                },
                importer: {
                  noHeaders:
                    "Sütun isimleri üretilemiyor, dosyanın bir başlığı var mı?",
                  noObjects:
                    "Nesneler üretilemiyor, dosyada başlıktan başka bir veri var mı?",
                  invalidCsv: "Dosya işlenemedi, geçerli bir CSV dosyası mı?",
                  invalidJson: "Dosya işlenemedi, geçerli bir Json dosyası mı?",
                  jsonNotArray:
                    "Alınan Json dosyasında bir dizi bulunmalıdır, işlem iptal ediliyor.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "İlk sayfaya",
                    pageBack: "Geri git",
                    pageSelected: "Seçili sayfa",
                    pageForward: "İleri git",
                    pageToLast: "Sona git",
                  },
                  sizes: "Sayfadaki nesne sayısı",
                  totalItems: "kayıtlar",
                  through: "",
                  of: "",
                },
                grouping: {
                  group: "Grupla",
                  ungroup: "Gruplama",
                  aggregate_count: "Yekun: Sayı",
                  aggregate_sum: "Yekun: Toplam",
                  aggregate_max: "Yekun: Maks",
                  aggregate_min: "Yekun: Min",
                  aggregate_avg: "Yekun: Ort",
                  aggregate_remove: "Yekun: Sil",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("ua", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "Фільтр стовпчика",
                    removeFilter: "Видалити фільтр",
                    columnMenuButtonLabel: "Меню ствпчика",
                  },
                  priority: "Пріоритет:",
                  filterLabel: "Фільтр стовпчика: ",
                },
                aggregate: { label: "елементи" },
                groupPanel: {
                  description:
                    "Для групування за стовпчиком перетягніть сюди його назву.",
                },
                search: {
                  placeholder: "Пошук...",
                  showingItems: "Показати елементи:",
                  selectedItems: "Обрані елементи:",
                  totalItems: "Усього елементів:",
                  size: "Розмір сторінки:",
                  first: "Перша сторінка",
                  next: "Наступна сторінка",
                  previous: "Попередня сторінка",
                  last: "Остання сторінка",
                },
                menu: { text: "Обрати ствпчики:" },
                sort: {
                  ascending: "За зростанням",
                  descending: "За спаданням",
                  none: "Без сортування",
                  remove: "Прибрати сортування",
                },
                column: { hide: "Приховати стовпчик" },
                aggregation: {
                  count: "усього рядків: ",
                  sum: "ітого: ",
                  avg: "середнє: ",
                  min: "мін: ",
                  max: "макс: ",
                },
                pinning: {
                  pinLeft: "Закріпити ліворуч",
                  pinRight: "Закріпити праворуч",
                  unpin: "Відкріпити",
                },
                columnMenu: { close: "Закрити" },
                gridMenu: {
                  aria: { buttonLabel: "Меню" },
                  columns: "Стовпчики:",
                  importerTitle: "Імпортувати файл",
                  exporterAllAsCsv: "Експортувати все в CSV",
                  exporterVisibleAsCsv: "Експортувати видимі дані в CSV",
                  exporterSelectedAsCsv: "Експортувати обрані дані в CSV",
                  exporterAllAsPdf: "Експортувати все в PDF",
                  exporterVisibleAsPdf: "Експортувати видимі дані в PDF",
                  exporterSelectedAsPdf: "Експортувати обрані дані в PDF",
                  clearAllFilters: "Очистити всі фільтри",
                },
                importer: {
                  noHeaders:
                    "Не вдалося отримати назви стовпчиків, чи є в файлі заголовок?",
                  noObjects:
                    "Не вдалося отримати дані, чи є в файлі рядки окрім заголовка?",
                  invalidCsv:
                    "Не вдалося обробити файл, чи це коректний CSV-файл?",
                  invalidJson:
                    "Не вдалося обробити файл, чи це коректний JSON?",
                  jsonNotArray:
                    "JSON-файл що імпортується повинен містити масив, операцію скасовано.",
                },
                pagination: {
                  aria: {
                    pageToFirst: "Перша сторінка",
                    pageBack: "Попередня сторінка",
                    pageSelected: "Обрана сторінка",
                    pageForward: "Наступна сторінка",
                    pageToLast: "Остання сторінка",
                  },
                  sizes: "рядків на сторінку",
                  totalItems: "рядків",
                  through: "по",
                  of: "з",
                },
                grouping: {
                  group: "Групувати",
                  ungroup: "Розгрупувати",
                  aggregate_count: "Групувати: Кількість",
                  aggregate_sum: "Для групи: Сума",
                  aggregate_max: "Для групи: Максимум",
                  aggregate_min: "Для групи: Мінімум",
                  aggregate_avg: "Для групи: Серднє",
                  aggregate_remove: "Для групи: Пусто",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    var a = ["uiT", "uiTranslate"],
      b = ["t", "uiTranslate"],
      c = angular.module("ui.grid.i18n");
    c.constant("i18nConstants", {
      MISSING: "[MISSING]",
      UPDATE_EVENT: "$uiI18n",
      LOCALE_DIRECTIVE_ALIAS: "uiI18n",
      DEFAULT_LANG: "en",
    }),
      c.service("i18nService", [
        "$log",
        "i18nConstants",
        "$rootScope",
        function (a, b, c) {
          var d = {
              _langs: {},
              current: null,
              get: function (a) {
                return this._langs[a.toLowerCase()];
              },
              add: function (a, b) {
                var c = a.toLowerCase();
                this._langs[c] || (this._langs[c] = {}),
                  angular.extend(this._langs[c], b);
              },
              getAllLangs: function () {
                var a = [];
                if (!this._langs) return a;
                for (var b in this._langs) a.push(b);
                return a;
              },
              setCurrent: function (a) {
                this.current = a.toLowerCase();
              },
              getCurrentLang: function () {
                return this.current;
              },
            },
            e = {
              add: function (a, b) {
                "object" == typeof a
                  ? angular.forEach(a, function (a) {
                      a && d.add(a, b);
                    })
                  : d.add(a, b);
              },
              getAllLangs: function () {
                return d.getAllLangs();
              },
              get: function (a) {
                var b = a ? a : e.getCurrentLang();
                return d.get(b);
              },
              getSafeText: function (a, c) {
                var f = c ? c : e.getCurrentLang(),
                  g = d.get(f);
                if (!g) return b.MISSING;
                for (var h = a.split("."), i = g, j = 0; j < h.length; ++j) {
                  if (void 0 === i[h[j]] || null === i[h[j]]) return b.MISSING;
                  i = i[h[j]];
                }
                return i;
              },
              setCurrentLang: function (a) {
                a && (d.setCurrent(a), c.$broadcast(b.UPDATE_EVENT));
              },
              getCurrentLang: function () {
                var a = d.getCurrentLang();
                return a || ((a = b.DEFAULT_LANG), d.setCurrent(a)), a;
              },
            };
          return e;
        },
      ]);
    var d = function (a, b) {
      return {
        compile: function () {
          return {
            pre: function (c, d, e) {
              var f = b.LOCALE_DIRECTIVE_ALIAS,
                g = c.$eval(e[f]);
              g
                ? c.$watch(e[f], function () {
                    a.setCurrentLang(g);
                  })
                : e.$$observers &&
                  e.$observe(f, function () {
                    a.setCurrentLang(e[f] || b.DEFAULT_LANG);
                  });
            },
          };
        },
      };
    };
    c.directive("uiI18n", ["i18nService", "i18nConstants", d]);
    var e = function (b, c, d) {
      return {
        restrict: "EA",
        compile: function () {
          return {
            pre: function (e, f, g) {
              var l,
                h = a[0],
                i = a[1],
                j = g[h] || g[i] || f.html(),
                k = d.MISSING + j;
              if (g.$$observers) {
                var m = g[h] ? h : i;
                l = g.$observe(m, function (a) {
                  a && f.html(b(a)(c.getCurrentLang()) || k);
                });
              }
              var n = b(j),
                o = e.$on(d.UPDATE_EVENT, function (a) {
                  l ? l(g[h] || g[i]) : f.html(n(c.get()) || k);
                });
              e.$on("$destroy", o), f.html(n(c.get()) || k);
            },
          };
        },
      };
    };
    angular.forEach(a, function (a) {
      c.directive(a, ["$parse", "i18nService", "i18nConstants", e]);
    });
    var f = function (a, b, c) {
      return function (d) {
        var e = a(d);
        return e(b.get()) || c.MISSING + d;
      };
    };
    angular.forEach(b, function (a) {
      c.filter(a, ["$parse", "i18nService", "i18nConstants", f]);
    });
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("zh-cn", {
                headerCell: {
                  aria: {
                    defaultFilterLabel: "列过滤器",
                    removeFilter: "移除过滤器",
                    columnMenuButtonLabel: "列菜单",
                  },
                  priority: "优先级:",
                  filterLabel: "列过滤器: ",
                },
                aggregate: { label: "行" },
                groupPanel: { description: "拖曳表头到此处进行分组" },
                search: {
                  placeholder: "查找",
                  showingItems: "已显示行数：",
                  selectedItems: "已选择行数：",
                  totalItems: "总行数：",
                  size: "每页显示行数：",
                  first: "首页",
                  next: "下一页",
                  previous: "上一页",
                  last: "末页",
                },
                menu: { text: "选择列：" },
                sort: {
                  ascending: "升序",
                  descending: "降序",
                  none: "无序",
                  remove: "取消排序",
                },
                column: { hide: "隐藏列" },
                aggregation: {
                  count: "计数：",
                  sum: "求和：",
                  avg: "均值：",
                  min: "最小值：",
                  max: "最大值：",
                },
                pinning: {
                  pinLeft: "左侧固定",
                  pinRight: "右侧固定",
                  unpin: "取消固定",
                },
                columnMenu: { close: "关闭" },
                gridMenu: {
                  aria: { buttonLabel: "表格菜单" },
                  columns: "列：",
                  importerTitle: "导入文件",
                  exporterAllAsCsv: "导出全部数据到CSV",
                  exporterVisibleAsCsv: "导出可见数据到CSV",
                  exporterSelectedAsCsv: "导出已选数据到CSV",
                  exporterAllAsPdf: "导出全部数据到PDF",
                  exporterVisibleAsPdf: "导出可见数据到PDF",
                  exporterSelectedAsPdf: "导出已选数据到PDF",
                  clearAllFilters: "清除所有过滤器",
                },
                importer: {
                  noHeaders: "无法获取列名，确定文件包含表头？",
                  noObjects: "无法获取数据，确定文件包含数据？",
                  invalidCsv: "无法处理文件，确定是合法的CSV文件？",
                  invalidJson: "无法处理文件，确定是合法的JSON文件？",
                  jsonNotArray: "导入的文件不是JSON数组！",
                },
                pagination: {
                  aria: {
                    pageToFirst: "第一页",
                    pageBack: "上一页",
                    pageSelected: "当前页",
                    pageForward: "下一页",
                    pageToLast: "最后一页",
                  },
                  sizes: "行每页",
                  totalItems: "行",
                  through: "至",
                  of: "共",
                },
                grouping: {
                  group: "分组",
                  ungroup: "取消分组",
                  aggregate_count: "合计: 计数",
                  aggregate_sum: "合计: 求和",
                  aggregate_max: "合计: 最大",
                  aggregate_min: "合计: 最小",
                  aggregate_avg: "合计: 平均",
                  aggregate_remove: "合计: 移除",
                },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    angular.module("ui.grid").config([
      "$provide",
      function (a) {
        a.decorator("i18nService", [
          "$delegate",
          function (a) {
            return (
              a.add("zh-tw", {
                aggregate: { label: "行" },
                groupPanel: { description: "拖曳表頭到此處進行分組" },
                search: {
                  placeholder: "查找",
                  showingItems: "已顯示行數：",
                  selectedItems: "已選擇行數：",
                  totalItems: "總行數：",
                  size: "每頁顯示行數：",
                  first: "首頁",
                  next: "下壹頁",
                  previous: "上壹頁",
                  last: "末頁",
                },
                menu: { text: "選擇列：" },
                sort: {
                  ascending: "升序",
                  descending: "降序",
                  remove: "取消排序",
                },
                column: { hide: "隱藏列" },
                aggregation: {
                  count: "計數：",
                  sum: "求和：",
                  avg: "均值：",
                  min: "最小值：",
                  max: "最大值：",
                },
                pinning: {
                  pinLeft: "左側固定",
                  pinRight: "右側固定",
                  unpin: "取消固定",
                },
                gridMenu: {
                  columns: "列：",
                  importerTitle: "導入文件",
                  exporterAllAsCsv: "導出全部數據到CSV",
                  exporterVisibleAsCsv: "導出可見數據到CSV",
                  exporterSelectedAsCsv: "導出已選數據到CSV",
                  exporterAllAsPdf: "導出全部數據到PDF",
                  exporterVisibleAsPdf: "導出可見數據到PDF",
                  exporterSelectedAsPdf: "導出已選數據到PDF",
                  clearAllFilters: "清除所有过滤器",
                },
                importer: {
                  noHeaders: "無法獲取列名，確定文件包含表頭？",
                  noObjects: "無法獲取數據，確定文件包含數據？",
                  invalidCsv: "無法處理文件，確定是合法的CSV文件？",
                  invalidJson: "無法處理文件，確定是合法的JSON文件？",
                  jsonNotArray: "導入的文件不是JSON數組！",
                },
                pagination: { sizes: "行每頁", totalItems: "行" },
              }),
              a
            );
          },
        ]);
      },
    ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.autoResize", ["ui.grid"]);
    a.directive("uiGridAutoResize", [
      "$timeout",
      "gridUtil",
      function (a, b) {
        return {
          require: "uiGrid",
          scope: !1,
          link: function (a, c, d, e) {
            function h() {
              (g = b.elementHeight(c)), (f = b.elementWidth(c));
            }
            function j() {
              clearTimeout(i),
                (i = setTimeout(function () {
                  var d = b.elementHeight(c),
                    i = b.elementWidth(c);
                  d !== g || i !== f
                    ? ((e.grid.gridHeight = d),
                      (e.grid.gridWidth = i),
                      e.grid.api.core.raise.gridDimensionChanged(g, f, d, i),
                      a.$apply(function () {
                        e.grid.refresh().then(function () {
                          h(), j();
                        });
                      }))
                    : j();
                }, 250));
            }
            var f, g;
            h();
            var i;
            j(),
              a.$on("$destroy", function () {
                clearTimeout(i);
              });
          },
        };
      },
    ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.cellNav", ["ui.grid"]);
    a.constant("uiGridCellNavConstants", {
      FEATURE_NAME: "gridCellNav",
      CELL_NAV_EVENT: "cellNav",
      direction: { LEFT: 0, RIGHT: 1, UP: 2, DOWN: 3, PG_UP: 4, PG_DOWN: 5 },
      EVENT_TYPE: { KEYDOWN: 0, CLICK: 1, CLEAR: 2 },
    }),
      a.factory("uiGridCellNavFactory", [
        "gridUtil",
        "uiGridConstants",
        "uiGridCellNavConstants",
        "GridRowColumn",
        "$q",
        function (a, b, c, d, e) {
          var f = function (b, c, d, e) {
            (this.rows = b.visibleRowCache),
              (this.columns = c.visibleColumnCache),
              (this.leftColumns = d ? d.visibleColumnCache : []),
              (this.rightColumns = e ? e.visibleColumnCache : []),
              (this.bodyContainer = b);
          };
          return (
            (f.prototype.getFocusableCols = function () {
              var a = this.leftColumns.concat(this.columns, this.rightColumns);
              return a.filter(function (a) {
                return a.colDef.allowCellFocus;
              });
            }),
            (f.prototype.getFocusableRows = function () {
              return this.rows.filter(function (a) {
                return a.allowCellFocus !== !1;
              });
            }),
            (f.prototype.getNextRowCol = function (a, b, d) {
              switch (a) {
                case c.direction.LEFT:
                  return this.getRowColLeft(b, d);
                case c.direction.RIGHT:
                  return this.getRowColRight(b, d);
                case c.direction.UP:
                  return this.getRowColUp(b, d);
                case c.direction.DOWN:
                  return this.getRowColDown(b, d);
                case c.direction.PG_UP:
                  return this.getRowColPageUp(b, d);
                case c.direction.PG_DOWN:
                  return this.getRowColPageDown(b, d);
              }
            }),
            (f.prototype.initializeSelection = function () {
              var a = this.getFocusableCols(),
                b = this.getFocusableRows();
              if (0 === a.length || 0 === b.length) return null;
              return new d(b[0], a[0]);
            }),
            (f.prototype.getRowColLeft = function (a, b) {
              var c = this.getFocusableCols(),
                e = this.getFocusableRows(),
                f = c.indexOf(b),
                g = e.indexOf(a);
              f === -1 && (f = 1);
              var h = 0 === f ? c.length - 1 : f - 1;
              return h >= f
                ? 0 === g
                  ? new d(a, c[h])
                  : new d(e[g - 1], c[h])
                : new d(a, c[h]);
            }),
            (f.prototype.getRowColRight = function (a, b) {
              var c = this.getFocusableCols(),
                e = this.getFocusableRows(),
                f = c.indexOf(b),
                g = e.indexOf(a);
              f === -1 && (f = 0);
              var h = f === c.length - 1 ? 0 : f + 1;
              return h <= f
                ? g === e.length - 1
                  ? new d(a, c[h])
                  : new d(e[g + 1], c[h])
                : new d(a, c[h]);
            }),
            (f.prototype.getRowColDown = function (a, b) {
              var c = this.getFocusableCols(),
                e = this.getFocusableRows(),
                f = c.indexOf(b),
                g = e.indexOf(a);
              return (
                f === -1 && (f = 0),
                g === e.length - 1 ? new d(a, c[f]) : new d(e[g + 1], c[f])
              );
            }),
            (f.prototype.getRowColPageDown = function (a, b) {
              var c = this.getFocusableCols(),
                e = this.getFocusableRows(),
                f = c.indexOf(b),
                g = e.indexOf(a);
              f === -1 && (f = 0);
              var h = this.bodyContainer.minRowsToRender();
              return g >= e.length - h
                ? new d(e[e.length - 1], c[f])
                : new d(e[g + h], c[f]);
            }),
            (f.prototype.getRowColUp = function (a, b) {
              var c = this.getFocusableCols(),
                e = this.getFocusableRows(),
                f = c.indexOf(b),
                g = e.indexOf(a);
              return (
                f === -1 && (f = 0),
                0 === g ? new d(a, c[f]) : new d(e[g - 1], c[f])
              );
            }),
            (f.prototype.getRowColPageUp = function (a, b) {
              var c = this.getFocusableCols(),
                e = this.getFocusableRows(),
                f = c.indexOf(b),
                g = e.indexOf(a);
              f === -1 && (f = 0);
              var h = this.bodyContainer.minRowsToRender();
              return g - h < 0 ? new d(e[0], c[f]) : new d(e[g - h], c[f]);
            }),
            f
          );
        },
      ]),
      a.service("uiGridCellNavService", [
        "gridUtil",
        "uiGridConstants",
        "uiGridCellNavConstants",
        "$q",
        "uiGridCellNavFactory",
        "GridRowColumn",
        "ScrollEvent",
        function (a, b, c, d, e, f, g) {
          var h = {
            initializeGrid: function (a) {
              a.registerColumnBuilder(h.cellNavColumnBuilder),
                (a.cellNav = {}),
                (a.cellNav.lastRowCol = null),
                (a.cellNav.focusedCells = []),
                h.defaultGridOptions(a.options);
              var b = {
                events: {
                  cellNav: {
                    navigate: function (a, b) {},
                    viewPortKeyDown: function (a, b) {},
                    viewPortKeyPress: function (a, b) {},
                  },
                },
                methods: {
                  cellNav: {
                    scrollToFocus: function (b, c) {
                      return h.scrollToFocus(a, b, c);
                    },
                    getFocusedCell: function () {
                      return a.cellNav.lastRowCol;
                    },
                    getCurrentSelection: function () {
                      return a.cellNav.focusedCells;
                    },
                    rowColSelectIndex: function (b) {
                      for (
                        var c = -1, d = 0;
                        d < a.cellNav.focusedCells.length;
                        d++
                      )
                        if (
                          a.cellNav.focusedCells[d].col.uid === b.col.uid &&
                          a.cellNav.focusedCells[d].row.uid === b.row.uid
                        ) {
                          c = d;
                          break;
                        }
                      return c;
                    },
                  },
                },
              };
              a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods);
            },
            defaultGridOptions: function (a) {
              (a.modifierKeysToMultiSelectCells =
                a.modifierKeysToMultiSelectCells === !0),
                (a.keyDownOverrides = a.keyDownOverrides || []);
            },
            decorateRenderContainers: function (a) {
              var b = a.hasRightContainer() ? a.renderContainers.right : null,
                c = a.hasLeftContainer() ? a.renderContainers.left : null;
              null !== c &&
                (a.renderContainers.left.cellNav = new e(
                  a.renderContainers.body,
                  c,
                  b,
                  a.renderContainers.body
                )),
                null !== b &&
                  (a.renderContainers.right.cellNav = new e(
                    a.renderContainers.body,
                    b,
                    a.renderContainers.body,
                    c
                  )),
                (a.renderContainers.body.cellNav = new e(
                  a.renderContainers.body,
                  a.renderContainers.body,
                  c,
                  b
                ));
            },
            getDirection: function (a) {
              return a.keyCode === b.keymap.LEFT ||
                (a.keyCode === b.keymap.TAB && a.shiftKey)
                ? c.direction.LEFT
                : a.keyCode === b.keymap.RIGHT || a.keyCode === b.keymap.TAB
                ? c.direction.RIGHT
                : a.keyCode === b.keymap.UP ||
                  (a.keyCode === b.keymap.ENTER && a.shiftKey)
                ? c.direction.UP
                : a.keyCode === b.keymap.PG_UP
                ? c.direction.PG_UP
                : a.keyCode === b.keymap.DOWN ||
                  (a.keyCode === b.keymap.ENTER && !a.ctrlKey && !a.altKey)
                ? c.direction.DOWN
                : a.keyCode === b.keymap.PG_DOWN
                ? c.direction.PG_DOWN
                : null;
            },
            cellNavColumnBuilder: function (a, b, c) {
              var e = [];
              return (
                (a.allowCellFocus =
                  void 0 === a.allowCellFocus || a.allowCellFocus),
                d.all(e)
              );
            },
            scrollToFocus: function (a, b, c) {
              var d = null,
                e = null;
              return (
                "undefined" != typeof b && null !== b && (d = a.getRow(b)),
                "undefined" != typeof c &&
                  null !== c &&
                  (e = a.getColumn(c.name ? c.name : c.field)),
                a.api.core.scrollToIfNecessary(d, e).then(function () {
                  var b = { row: d, col: e };
                  null !== d && null !== e && a.cellNav.broadcastCellNav(b);
                })
              );
            },
            getLeftWidth: function (a, b) {
              var c = 0;
              if (!b) return c;
              var d = a.renderContainers.body.visibleColumnCache.indexOf(b);
              a.renderContainers.body.visibleColumnCache.forEach(function (
                a,
                b
              ) {
                b < d && (c += a.drawnWidth);
              });
              var e =
                0 === d
                  ? 0
                  : (d + 1) / a.renderContainers.body.visibleColumnCache.length;
              return (c += b.drawnWidth * e);
            },
          };
          return h;
        },
      ]),
      a.directive("uiGridCellnav", [
        "gridUtil",
        "uiGridCellNavService",
        "uiGridCellNavConstants",
        "uiGridConstants",
        "GridRowColumn",
        "$timeout",
        "$compile",
        function (a, b, c, d, e, f, g) {
          return {
            replace: !0,
            priority: -150,
            require: "^uiGrid",
            scope: !1,
            controller: function () {},
            compile: function () {
              return {
                pre: function (a, f, g, h) {
                  var i = a,
                    j = h.grid;
                  b.initializeGrid(j),
                    (h.cellNav = {}),
                    (h.cellNav.makeRowCol = function (a) {
                      return a instanceof e || (a = new e(a.row, a.col)), a;
                    }),
                    (h.cellNav.getActiveCell = function () {
                      var a = f[0].getElementsByClassName("ui-grid-cell-focus");
                      if (a.length > 0) return a[0];
                    }),
                    (h.cellNav.broadcastCellNav = j.cellNav.broadcastCellNav = function (
                      a,
                      b,
                      d
                    ) {
                      (b = !(void 0 === b || !b)),
                        (a = h.cellNav.makeRowCol(a)),
                        h.cellNav.broadcastFocus(a, b, d),
                        i.$broadcast(c.CELL_NAV_EVENT, a, b, d);
                    }),
                    (h.cellNav.clearFocus = j.cellNav.clearFocus = function () {
                      (j.cellNav.focusedCells = []),
                        i.$broadcast(c.CELL_NAV_EVENT);
                    }),
                    (h.cellNav.broadcastFocus = function (a, b, c) {
                      (b = !(void 0 === b || !b)),
                        (a = h.cellNav.makeRowCol(a));
                      var d = a.row,
                        f = a.col,
                        g = h.grid.api.cellNav.rowColSelectIndex(a);
                      if (null === j.cellNav.lastRowCol || g === -1) {
                        var i = new e(d, f);
                        (null !== j.cellNav.lastRowCol &&
                          j.cellNav.lastRowCol.row === i.row &&
                          j.cellNav.lastRowCol.col === i.col) ||
                          (j.api.cellNav.raise.navigate(
                            i,
                            j.cellNav.lastRowCol,
                            c
                          ),
                          (j.cellNav.lastRowCol = i)),
                          h.grid.options.modifierKeysToMultiSelectCells && b
                            ? j.cellNav.focusedCells.push(a)
                            : (j.cellNav.focusedCells = [a]);
                      } else
                        j.options.modifierKeysToMultiSelectCells &&
                          b &&
                          g >= 0 &&
                          j.cellNav.focusedCells.splice(g, 1);
                    }),
                    (h.cellNav.handleKeyDown = function (a) {
                      var e = b.getDirection(a);
                      if (null === e) return null;
                      var f = "body";
                      a.uiGridTargetRenderContainerId &&
                        (f = a.uiGridTargetRenderContainerId);
                      var g = h.grid.api.cellNav.getFocusedCell();
                      if (g) {
                        var i = h.grid.renderContainers[
                            f
                          ].cellNav.getNextRowCol(e, g.row, g.col),
                          k = h.grid.renderContainers[
                            f
                          ].cellNav.getFocusableCols(),
                          l = h.grid.api.cellNav.rowColSelectIndex(i);
                        return e === c.direction.LEFT &&
                          i.col === k[k.length - 1] &&
                          i.row === g.row &&
                          a.keyCode === d.keymap.TAB &&
                          a.shiftKey
                          ? (j.cellNav.focusedCells.splice(l, 1),
                            h.cellNav.clearFocus(),
                            !0)
                          : e !== c.direction.RIGHT ||
                            i.col !== k[0] ||
                            i.row !== g.row ||
                            a.keyCode !== d.keymap.TAB ||
                            a.shiftKey
                          ? (j
                              .scrollToIfNecessary(i.row, i.col)
                              .then(function () {
                                h.cellNav.broadcastCellNav(i, null, a);
                              }),
                            a.stopPropagation(),
                            a.preventDefault(),
                            !1)
                          : (j.cellNav.focusedCells.splice(l, 1),
                            h.cellNav.clearFocus(),
                            !0);
                      }
                    });
                },
                post: function (a, b, d, e) {
                  function i() {
                    var d =
                        '<div id="' +
                        h.id +
                        '-aria-speakable" class="ui-grid-a11y-ariascreenreader-speakable ui-grid-offscreen" aria-live="assertive" role="region" aria-atomic="true" aria-hidden="false" aria-relevant="additions" >&nbsp;</div>',
                      e = g(d)(a);
                    b.prepend(e),
                      a.$on(c.CELL_NAV_EVENT, function (a, b, c, d) {
                        function f(a) {
                          a !== e.text() &&
                            ((e[0].style.clip = "rect(0px,0px,0px,0px)"),
                            (e[0].innerHTML = ""),
                            (e[0].style.visibility = "hidden"),
                            (e[0].style.visibility = "visible"),
                            "" !== a &&
                              ((e[0].style.clip = "auto"),
                              e[0].appendChild(
                                document.createTextNode(a + " ")
                              ),
                              (e[0].style.visibility = "hidden"),
                              (e[0].style.visibility = "visible")));
                        }
                        if (!d || "focus" !== d.type) {
                          for (
                            var g = [],
                              i = h.api.cellNav.getCurrentSelection(),
                              j = 0;
                            j < i.length;
                            j++
                          )
                            g.push(h.getCellDisplayValue(i[j].row, i[j].col));
                          var k = g.toString();
                          f(k);
                        }
                      });
                  }
                  var h = e.grid;
                  i();
                },
              };
            },
          };
        },
      ]),
      a.directive("uiGridRenderContainer", [
        "$timeout",
        "$document",
        "gridUtil",
        "uiGridConstants",
        "uiGridCellNavService",
        "$compile",
        "uiGridCellNavConstants",
        function (a, b, c, d, e, f, g) {
          return {
            replace: !0,
            priority: -99999,
            require: ["^uiGrid", "uiGridRenderContainer", "?^uiGridCellnav"],
            scope: !1,
            compile: function () {
              return {
                post: function (b, d, h, i) {
                  var j = i[0],
                    k = i[1],
                    l = i[2];
                  if (j.grid.api.cellNav) {
                    var m = k.containerId,
                      n = j.grid;
                    if ((e.decorateRenderContainers(n), "body" === m)) {
                      j.grid.options.modifierKeysToMultiSelectCells
                        ? d.attr("aria-multiselectable", !0)
                        : d.attr("aria-multiselectable", !1);
                      var o = f(
                        '<div class="ui-grid-focuser" role="region" aria-live="assertive" aria-atomic="false" tabindex="0" aria-controls="' +
                          n.id +
                          "-aria-speakable " +
                          n.id +
                          '-grid-container" aria-owns="' +
                          n.id +
                          '-grid-container"></div>'
                      )(b);
                      d.append(o),
                        o.on("focus", function (a) {
                          a.uiGridTargetRenderContainerId = m;
                          var b = j.grid.api.cellNav.getFocusedCell();
                          null === b &&
                            ((b = j.grid.renderContainers[
                              m
                            ].cellNav.getNextRowCol(
                              g.direction.DOWN,
                              null,
                              null
                            )),
                            b.row && b.col && j.cellNav.broadcastCellNav(b));
                        }),
                        (l.setAriaActivedescendant = function (a) {
                          d.attr("aria-activedescendant", a);
                        }),
                        (l.removeAriaActivedescendant = function (a) {
                          d.attr("aria-activedescendant") === a &&
                            d.attr("aria-activedescendant", "");
                        }),
                        (j.focus = function () {
                          c.focus.byElement(o[0]);
                        });
                      var p = null;
                      o.on("keydown", function (a) {
                        a.uiGridTargetRenderContainerId = m;
                        var b = j.grid.api.cellNav.getFocusedCell(),
                          c = j.grid.options.keyDownOverrides.some(function (
                            b
                          ) {
                            return Object.keys(b).every(function (c) {
                              return b[c] === a[c];
                            });
                          }),
                          d = c ? null : j.cellNav.handleKeyDown(a);
                        null === d &&
                          (j.grid.api.cellNav.raise.viewPortKeyDown(a, b),
                          (p = b));
                      }),
                        o.on("keypress", function (b) {
                          p &&
                            (a(function () {
                              j.grid.api.cellNav.raise.viewPortKeyPress(b, p);
                            }, 4),
                            (p = null));
                        }),
                        b.$on("$destroy", function () {
                          o.off();
                        });
                    }
                  }
                },
              };
            },
          };
        },
      ]),
      a.directive("uiGridViewport", [
        "$timeout",
        "$document",
        "gridUtil",
        "uiGridConstants",
        "uiGridCellNavService",
        "uiGridCellNavConstants",
        "$log",
        "$compile",
        function (a, b, c, d, e, f, g, h) {
          return {
            replace: !0,
            priority: -99999,
            require: ["^uiGrid", "^uiGridRenderContainer", "?^uiGridCellnav"],
            scope: !1,
            compile: function () {
              return {
                pre: function (a, b, c, d) {},
                post: function (a, b, c, d) {
                  var e = d[0],
                    f = d[1];
                  if (e.grid.api.cellNav) {
                    var g = f.containerId;
                    if ("body" === g) {
                      var h = e.grid;
                      h.api.core.on.scrollBegin(a, function (a) {
                        var b = e.grid.api.cellNav.getFocusedCell();
                        null !== b &&
                          f.colContainer.containsColumn(b.col) &&
                          e.cellNav.clearFocus();
                      }),
                        h.api.core.on.scrollEnd(a, function (a) {
                          var b = e.grid.api.cellNav.getFocusedCell();
                          null !== b &&
                            f.colContainer.containsColumn(b.col) &&
                            e.cellNav.broadcastCellNav(b);
                        }),
                        h.api.cellNav.on.navigate(a, function () {
                          e.focus();
                        });
                    }
                  }
                },
              };
            },
          };
        },
      ]),
      a.directive("uiGridCell", [
        "$timeout",
        "$document",
        "uiGridCellNavService",
        "gridUtil",
        "uiGridCellNavConstants",
        "uiGridConstants",
        "GridRowColumn",
        function (a, b, c, d, e, f, g) {
          return {
            priority: -150,
            restrict: "A",
            require: ["^uiGrid", "?^uiGridCellnav"],
            scope: !1,
            link: function (b, c, d, h) {
              function l(a) {
                a.preventDefault();
              }
              function n() {
                var a = k.cellNav.focusedCells.some(function (a, c) {
                  return a.row === b.row && a.col === b.col;
                });
                a ? o() : p();
              }
              function o() {
                if (!b.focused) {
                  var a = c.find("div");
                  a.addClass("ui-grid-cell-focus"),
                    c.attr("aria-selected", !0),
                    j.setAriaActivedescendant(c.attr("id")),
                    (b.focused = !0);
                }
              }
              function p() {
                if (b.focused) {
                  var a = c.find("div");
                  a.removeClass("ui-grid-cell-focus"),
                    c.attr("aria-selected", !1),
                    j.removeAriaActivedescendant(c.attr("id")),
                    (b.focused = !1);
                }
              }
              var i = h[0],
                j = h[1];
              if (i.grid.api.cellNav && b.col.colDef.allowCellFocus) {
                var k = i.grid;
                (b.focused = !1),
                  c.attr("tabindex", -1),
                  c.find("div").on("click", function (a) {
                    i.cellNav.broadcastCellNav(
                      new g(b.row, b.col),
                      a.ctrlKey || a.metaKey,
                      a
                    ),
                      a.stopPropagation(),
                      b.$apply();
                  }),
                  c.on("mousedown", l),
                  i.grid.api.edit &&
                    (i.grid.api.edit.on.beginCellEdit(b, function () {
                      c.off("mousedown", l);
                    }),
                    i.grid.api.edit.on.afterCellEdit(b, function () {
                      c.on("mousedown", l);
                    }),
                    i.grid.api.edit.on.cancelCellEdit(b, function () {
                      c.on("mousedown", l);
                    })),
                  n(),
                  c.on("focus", function (a) {
                    i.cellNav.broadcastCellNav(new g(b.row, b.col), !1, a),
                      a.stopPropagation(),
                      b.$apply();
                  }),
                  b.$on(e.CELL_NAV_EVENT, n);
                var m = i.grid.registerDataChangeCallback(
                  function (b) {
                    p(), a(n);
                  },
                  [f.dataChange.ROW]
                );
                b.$on("$destroy", function () {
                  m(), c.find("div").off(), c.off();
                });
              }
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.edit", ["ui.grid"]);
    a.constant("uiGridEditConstants", {
      EDITABLE_CELL_TEMPLATE: /EDITABLE_CELL_TEMPLATE/g,
      EDITABLE_CELL_DIRECTIVE: /editable_cell_directive/g,
      events: {
        BEGIN_CELL_EDIT: "uiGridEventBeginCellEdit",
        END_CELL_EDIT: "uiGridEventEndCellEdit",
        CANCEL_CELL_EDIT: "uiGridEventCancelCellEdit",
      },
    }),
      a.service("uiGridEditService", [
        "$q",
        "uiGridConstants",
        "gridUtil",
        function (a, b, c) {
          var d = {
            initializeGrid: function (a) {
              d.defaultGridOptions(a.options),
                a.registerColumnBuilder(d.editColumnBuilder),
                (a.edit = {});
              var b = {
                events: {
                  edit: {
                    afterCellEdit: function (a, b, c, d) {},
                    beginCellEdit: function (a, b, c) {},
                    cancelCellEdit: function (a, b) {},
                  },
                },
                methods: { edit: {} },
              };
              a.api.registerEventsFromObject(b.events);
            },
            defaultGridOptions: function (a) {
              (a.cellEditableCondition =
                void 0 === a.cellEditableCondition || a.cellEditableCondition),
                (a.enableCellEditOnFocus =
                  void 0 !== a.enableCellEditOnFocus &&
                  a.enableCellEditOnFocus);
            },
            editColumnBuilder: function (b, d, e) {
              var f = [];
              return (
                (b.enableCellEdit =
                  void 0 === b.enableCellEdit
                    ? void 0 === e.enableCellEdit
                      ? "object" !== b.type
                      : e.enableCellEdit
                    : b.enableCellEdit),
                (b.cellEditableCondition =
                  void 0 === b.cellEditableCondition
                    ? e.cellEditableCondition
                    : b.cellEditableCondition),
                b.enableCellEdit &&
                  ((b.editableCellTemplate =
                    b.editableCellTemplate ||
                    e.editableCellTemplate ||
                    "ui-grid/cellEditor"),
                  f.push(
                    c.getTemplate(b.editableCellTemplate).then(
                      function (a) {
                        d.editableCellTemplate = a;
                      },
                      function (a) {
                        throw new Error(
                          "Couldn't fetch/use colDef.editableCellTemplate '" +
                            b.editableCellTemplate +
                            "'"
                        );
                      }
                    )
                  )),
                (b.enableCellEditOnFocus =
                  void 0 === b.enableCellEditOnFocus
                    ? e.enableCellEditOnFocus
                    : b.enableCellEditOnFocus),
                a.all(f)
              );
            },
            isStartEditKey: function (a) {
              return !(
                a.metaKey ||
                a.keyCode === b.keymap.ESC ||
                a.keyCode === b.keymap.SHIFT ||
                a.keyCode === b.keymap.CTRL ||
                a.keyCode === b.keymap.ALT ||
                a.keyCode === b.keymap.WIN ||
                a.keyCode === b.keymap.CAPSLOCK ||
                a.keyCode === b.keymap.LEFT ||
                (a.keyCode === b.keymap.TAB && a.shiftKey) ||
                a.keyCode === b.keymap.RIGHT ||
                a.keyCode === b.keymap.TAB ||
                a.keyCode === b.keymap.UP ||
                (a.keyCode === b.keymap.ENTER && a.shiftKey) ||
                a.keyCode === b.keymap.DOWN ||
                a.keyCode === b.keymap.ENTER
              );
            },
          };
          return d;
        },
      ]),
      a.directive("uiGridEdit", [
        "gridUtil",
        "uiGridEditService",
        function (a, b) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (a, c, d, e) {
                  b.initializeGrid(e.grid);
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]),
      a.directive("uiGridViewport", [
        "uiGridEditConstants",
        function (a) {
          return {
            replace: !0,
            priority: -99998,
            require: ["^uiGrid", "^uiGridRenderContainer"],
            scope: !1,
            compile: function () {
              return {
                post: function (b, c, d, e) {
                  var f = e[0];
                  if (f.grid.api.edit && f.grid.api.cellNav) {
                    var g = e[1].containerId;
                    "body" === g &&
                      (b.$on(a.events.CANCEL_CELL_EDIT, function () {
                        f.focus();
                      }),
                      b.$on(a.events.END_CELL_EDIT, function () {
                        f.focus();
                      }));
                  }
                },
              };
            },
          };
        },
      ]),
      a.directive("uiGridCell", [
        "$compile",
        "$injector",
        "$timeout",
        "uiGridConstants",
        "uiGridEditConstants",
        "gridUtil",
        "$parse",
        "uiGridEditService",
        "$rootScope",
        "$q",
        function (a, b, c, d, e, f, g, h, i, j) {
          var k = 500;
          if (b.has("uiGridCellNavService")) {
            b.get("uiGridCellNavService");
          }
          return {
            priority: -100,
            restrict: "A",
            scope: !1,
            require: "?^uiGrid",
            link: function (b, l, m, n) {
              function y() {
                l.on("dblclick", E),
                  l.on("touchstart", z),
                  n &&
                    n.grid.api.cellNav &&
                    ((v = n.grid.api.cellNav.on.viewPortKeyDown(b, function (
                      a,
                      c
                    ) {
                      null !== c &&
                        (c.row !== b.row ||
                          c.col !== b.col ||
                          b.col.colDef.enableCellEditOnFocus ||
                          C(a));
                    })),
                    (u = n.grid.api.cellNav.on.navigate(b, function (a, d, e) {
                      b.col.colDef.enableCellEditOnFocus &&
                        ((d && a.row === d.row && a.col === d.col) ||
                          a.row !== b.row ||
                          a.col !== b.col ||
                          c(function () {
                            E(e);
                          }));
                    }))),
                  (b.beginEditEventsWired = !0);
              }
              function z(a) {
                "undefined" != typeof a.originalEvent &&
                  void 0 !== a.originalEvent &&
                  (a = a.originalEvent),
                  l.on("touchend", A),
                  (s = c(function () {}, k)),
                  s.then(function () {
                    setTimeout(E, 0), l.off("touchend", A);
                  });
              }
              function A(a) {
                c.cancel(s), l.off("touchend", A);
              }
              function B() {
                l.off("dblclick", E),
                  l.off("keydown", C),
                  l.off("touchstart", z),
                  u(),
                  v(),
                  (b.beginEditEventsWired = !1);
              }
              function C(a) {
                h.isStartEditKey(a) && E(a);
              }
              function D(a, c) {
                return (
                  !c.isSaving &&
                  (angular.isFunction(a.colDef.cellEditableCondition)
                    ? a.colDef.cellEditableCondition(b)
                    : a.colDef.cellEditableCondition)
                );
              }
              function E(a) {
                b.grid.api.core
                  .scrollToIfNecessary(b.row, b.col)
                  .then(function () {
                    F(a);
                  });
              }
              function F(h) {
                if (!q && D(b.col, b.row)) {
                  var k = b.row.getQualifiedColField(b.col);
                  b.col.colDef.editModelField &&
                    (k = f.preEval(
                      "row.entity." + b.col.colDef.editModelField
                    )),
                    (r = g(k)),
                    (p = r(b)),
                    (o = b.col.editableCellTemplate),
                    (o = o.replace(d.MODEL_COL_FIELD, k)),
                    (o = o.replace(d.COL_FIELD, "grid.getCellValue(row, col)"));
                  var m = b.col.colDef.editDropdownFilter
                    ? "|" + b.col.colDef.editDropdownFilter
                    : "";
                  o = o.replace(d.CUSTOM_FILTERS, m);
                  var n = "text";
                  switch (b.col.colDef.type) {
                    case "boolean":
                      n = "checkbox";
                      break;
                    case "number":
                      n = "number";
                      break;
                    case "date":
                      n = "date";
                  }
                  o = o.replace("INPUT_TYPE", n);
                  var s = b.col.colDef.editDropdownOptionsFunction;
                  if (s)
                    j.when(s(b.row.entity, b.col.colDef)).then(function (a) {
                      b.editDropdownOptionsArray = a;
                    });
                  else {
                    var u = b.col.colDef.editDropdownRowEntityOptionsArrayPath;
                    u
                      ? (b.editDropdownOptionsArray = I(b.row.entity, u))
                      : (b.editDropdownOptionsArray =
                          b.col.colDef.editDropdownOptionsArray);
                  }
                  (b.editDropdownIdLabel = b.col.colDef.editDropdownIdLabel
                    ? b.col.colDef.editDropdownIdLabel
                    : "id"),
                    (b.editDropdownValueLabel = b.col.colDef
                      .editDropdownValueLabel
                      ? b.col.colDef.editDropdownValueLabel
                      : "value");
                  var w = function () {
                    (q = !0), B();
                    var c = angular.element(o);
                    l.append(c), (t = b.$new()), a(c)(t);
                    var d = angular.element(l.children()[0]);
                    d.addClass("ui-grid-cell-contents-hidden");
                  };
                  i.$$phase ? w() : b.$apply(w);
                  var x = b.col.grid.api.core.on.scrollBegin(b, function () {
                      b.grid.disableScrolling ||
                        (G(),
                        b.grid.api.edit.raise.afterCellEdit(
                          b.row.entity,
                          b.col.colDef,
                          r(b),
                          p
                        ),
                        x(),
                        y(),
                        z());
                    }),
                    y = b.$on(e.events.END_CELL_EDIT, function () {
                      G(),
                        b.grid.api.edit.raise.afterCellEdit(
                          b.row.entity,
                          b.col.colDef,
                          r(b),
                          p
                        ),
                        y(),
                        x(),
                        z();
                    }),
                    z = b.$on(e.events.CANCEL_CELL_EDIT, function () {
                      H(), z(), x(), y();
                    });
                  b.$broadcast(e.events.BEGIN_CELL_EDIT, h),
                    c(function () {
                      b.grid.api.edit.raise.beginCellEdit(
                        b.row.entity,
                        b.col.colDef,
                        h
                      );
                    });
                }
              }
              function G() {
                if (((b.grid.disableScrolling = !1), q)) {
                  n && n.grid.api.cellNav && n.focus();
                  var a = angular.element(l.children()[0]);
                  t.$destroy();
                  for (var c = l.children(), e = 1; e < c.length; e++)
                    angular.element(c[e]).remove();
                  a.removeClass("ui-grid-cell-contents-hidden"),
                    (q = !1),
                    y(),
                    b.grid.api.core.notifyDataChange(d.dataChange.EDIT);
                }
              }
              function H() {
                (b.grid.disableScrolling = !1),
                  q &&
                    (r.assign(b, p),
                    b.$apply(),
                    b.grid.api.edit.raise.cancelCellEdit(
                      b.row.entity,
                      b.col.colDef
                    ),
                    G());
              }
              function I(a, b) {
                (b = b.replace(/\[(\w+)\]/g, ".$1")),
                  (b = b.replace(/^\./, ""));
                for (var c = b.split("."); c.length; ) {
                  var d = c.shift();
                  if (!(d in a)) return;
                  a = a[d];
                }
                return a;
              }
              var o,
                p,
                r,
                s,
                t,
                q = !1;
              if (b.col.colDef.enableCellEdit) {
                var u = function () {},
                  v = function () {},
                  w = function () {
                    b.col.colDef.enableCellEdit && b.row.enableCellEdit !== !1
                      ? b.beginEditEventsWired || y()
                      : b.beginEditEventsWired && B();
                  };
                w();
                var x = b.$watch("row", function (a, b) {
                  a !== b && w();
                });
                b.$on("$destroy", function () {
                  x(), l.off();
                });
              }
            },
          };
        },
      ]),
      a.directive("uiGridEditor", [
        "gridUtil",
        "uiGridConstants",
        "uiGridEditConstants",
        "$timeout",
        "uiGridEditService",
        function (a, b, c, d, e) {
          return {
            scope: !0,
            require: ["?^uiGrid", "?^uiGridRenderContainer", "ngModel"],
            compile: function () {
              return {
                pre: function (a, b, c) {},
                post: function (a, f, g, h) {
                  var i, j, k;
                  h[0] && (i = h[0]),
                    h[1] && (j = h[1]),
                    h[2] && (k = h[2]),
                    a.$on(c.events.BEGIN_CELL_EDIT, function (b, c) {
                      if (
                        (d(function () {
                          if (
                            (f[0].focus(),
                            !f[0].select ||
                              (!a.col.colDef.enableCellEditOnFocus &&
                                i &&
                                i.grid.api.cellNav))
                          )
                            try {
                              f[0].setSelectionRange(
                                f[0].value.length,
                                f[0].value.length
                              );
                            } catch (a) {}
                          else f[0].select();
                        }),
                        i && i.grid.api.cellNav)
                      )
                        var g = i.grid.api.cellNav.on.viewPortKeyPress(
                          a,
                          function (a, b) {
                            e.isStartEditKey(a) &&
                              (k.$setViewValue(
                                String.fromCharCode(
                                  "number" == typeof a.which
                                    ? a.which
                                    : a.keyCode
                                ),
                                a
                              ),
                              k.$render()),
                              g();
                          }
                        );
                      f.on("mousedown", function (b) {
                        "checkbox" === f[0].type &&
                          (f.off("blur", a.stopEdit),
                          d(function () {
                            f.focus(), f.on("blur", a.stopEdit);
                          }));
                      }),
                        f.on("blur", a.stopEdit);
                    }),
                    (a.deepEdit = !1),
                    (a.stopEdit = function (b) {
                      a.inputForm && !a.inputForm.$valid
                        ? (b.stopPropagation(),
                          a.$emit(c.events.CANCEL_CELL_EDIT))
                        : a.$emit(c.events.END_CELL_EDIT),
                        (a.deepEdit = !1);
                    }),
                    f.on("click", function (b) {
                      "checkbox" !== f[0].type &&
                        ((a.deepEdit = !0),
                        d(function () {
                          a.grid.disableScrolling = !0;
                        }));
                    }),
                    f.on("keydown", function (d) {
                      switch (d.keyCode) {
                        case b.keymap.ESC:
                          d.stopPropagation(),
                            a.$emit(c.events.CANCEL_CELL_EDIT);
                      }
                      if (
                        !a.deepEdit ||
                        (d.keyCode !== b.keymap.LEFT &&
                          d.keyCode !== b.keymap.RIGHT &&
                          d.keyCode !== b.keymap.UP &&
                          d.keyCode !== b.keymap.DOWN)
                      )
                        if (i && i.grid.api.cellNav)
                          (d.uiGridTargetRenderContainerId = j.containerId),
                            null !== i.cellNav.handleKeyDown(d) &&
                              a.stopEdit(d);
                        else
                          switch (d.keyCode) {
                            case b.keymap.ENTER:
                            case b.keymap.TAB:
                              d.stopPropagation(),
                                d.preventDefault(),
                                a.stopEdit(d);
                          }
                      else d.stopPropagation();
                      return !0;
                    }),
                    a.$on("$destroy", function () {
                      f.off();
                    });
                },
              };
            },
          };
        },
      ]),
      a.directive("uiGridEditor", [
        "$filter",
        function (a) {
          function b(a) {
            if ("undefined" == typeof a || "" === a) return null;
            var b = a.split("-");
            if (3 !== b.length) return null;
            var c = parseInt(b[0], 10),
              d = parseInt(b[1], 10),
              e = parseInt(b[2], 10);
            return d < 1 || c < 1 || e < 1 ? null : new Date(c, d - 1, e);
          }
          return {
            priority: -100,
            require: "?ngModel",
            link: function (c, d, e, f) {
              2 === angular.version.minor &&
                e.type &&
                "date" === e.type &&
                f &&
                (f.$formatters.push(function (b) {
                  return (
                    f.$setValidity(null, !b || !isNaN(b.getTime())),
                    a("date")(b, "yyyy-MM-dd")
                  );
                }),
                f.$parsers.push(function (a) {
                  if (a && a.length > 0) {
                    var c = b(a);
                    return f.$setValidity(null, c && !isNaN(c.getTime())), c;
                  }
                  return f.$setValidity(null, !0), null;
                }));
            },
          };
        },
      ]),
      a.directive("uiGridEditDropdown", [
        "uiGridConstants",
        "uiGridEditConstants",
        "$timeout",
        function (a, b, c) {
          return {
            require: ["?^uiGrid", "?^uiGridRenderContainer"],
            scope: !0,
            compile: function () {
              return {
                pre: function (a, b, c) {},
                post: function (d, e, f, g) {
                  var h = g[0],
                    i = g[1];
                  d.$on(b.events.BEGIN_CELL_EDIT, function () {
                    c(function () {
                      e[0].focus();
                    }),
                      (e[0].style.width =
                        e[0].parentElement.offsetWidth - 1 + "px"),
                      e.on("blur", function (a) {
                        d.stopEdit(a);
                      });
                  }),
                    (d.stopEdit = function (a) {
                      d.$emit(b.events.END_CELL_EDIT);
                    }),
                    e.on("keydown", function (c) {
                      switch (c.keyCode) {
                        case a.keymap.ESC:
                          c.stopPropagation(),
                            d.$emit(b.events.CANCEL_CELL_EDIT);
                      }
                      if (h && h.grid.api.cellNav)
                        (c.uiGridTargetRenderContainerId = i.containerId),
                          null !== h.cellNav.handleKeyDown(c) && d.stopEdit(c);
                      else
                        switch (c.keyCode) {
                          case a.keymap.ENTER:
                          case a.keymap.TAB:
                            c.stopPropagation(),
                              c.preventDefault(),
                              d.stopEdit(c);
                        }
                      return !0;
                    }),
                    d.$on("$destroy", function () {
                      e.off();
                    });
                },
              };
            },
          };
        },
      ]),
      a.directive("uiGridEditFileChooser", [
        "gridUtil",
        "uiGridConstants",
        "uiGridEditConstants",
        "$timeout",
        function (a, b, c, d) {
          return {
            scope: !0,
            require: ["?^uiGrid", "?^uiGridRenderContainer"],
            compile: function () {
              return {
                pre: function (a, b, c) {},
                post: function (b, d, e, f) {
                  var g, h;
                  f[0] && (g = f[0]), f[1] && (h = f[1]);
                  var j =
                    (g.grid,
                    function (d) {
                      var e = d.srcElement || d.target;
                      e && e.files && e.files.length > 0
                        ? ("function" ==
                          typeof b.col.colDef.editFileChooserCallback
                            ? b.col.colDef.editFileChooserCallback(
                                b.row,
                                b.col,
                                e.files
                              )
                            : a.logError(
                                "You need to set colDef.editFileChooserCallback to use the file chooser"
                              ),
                          e.form.reset(),
                          b.$emit(c.events.END_CELL_EDIT))
                        : b.$emit(c.events.CANCEL_CELL_EDIT);
                    });
                  d[0].addEventListener("change", j, !1),
                    b.$on(c.events.BEGIN_CELL_EDIT, function () {
                      d[0].focus(),
                        d[0].select(),
                        d.on("blur", function (a) {
                          b.$emit(c.events.END_CELL_EDIT);
                        });
                    }),
                    b.$on("$destroy", function () {
                      d.off(), d[0].removeEventListener("change", j, !1);
                    });
                },
              };
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.emptyBaseLayer", ["ui.grid"]);
    a.service("uiGridBaseLayerService", [
      "gridUtil",
      "$compile",
      function (a, b) {
        var c = {
          initializeGrid: function (a, b) {
            (a.baseLayer = { emptyRows: [] }),
              a.options.enableEmptyGridBaseLayer !== !1 &&
                (a.options.enableEmptyGridBaseLayer = !b);
          },
          setNumberOfEmptyRows: function (a, b) {
            var c = b.options.rowHeight,
              d = Math.ceil(a / c);
            if (d > 0) {
              b.baseLayer.emptyRows = [];
              for (var e = 0; e < d; e++) b.baseLayer.emptyRows.push({});
            }
          },
        };
        return c;
      },
    ]),
      a.directive("uiGridEmptyBaseLayer", [
        "gridUtil",
        "uiGridBaseLayerService",
        "$parse",
        function (a, b, c) {
          return {
            require: "^uiGrid",
            scope: !1,
            compile: function (a, d) {
              return {
                pre: function (a, d, e, f) {
                  var g = c(e.uiGridEmptyBaseLayer)(a) === !1;
                  b.initializeGrid(f.grid, g);
                },
                post: function (a, c, d, e) {
                  function h() {
                    var a = f.getViewportHeight();
                    return a !== g && ((g = a), !0);
                  }
                  function i(a) {
                    return (
                      ".grid" +
                      e.grid.id +
                      " .ui-grid-render-container .ui-grid-empty-base-layer-container.ui-grid-canvas { height: " +
                      a +
                      "px; }"
                    );
                  }
                  if (e.grid.options.enableEmptyGridBaseLayer) {
                    var f = e.grid.renderContainers.body,
                      g = f.getViewportHeight();
                    e.grid.registerStyleComputation({
                      func: function () {
                        return h() && b.setNumberOfEmptyRows(g, e.grid), i(g);
                      },
                    });
                  }
                },
              };
            },
          };
        },
      ]),
      a.directive("uiGridViewport", [
        "$compile",
        "gridUtil",
        "$templateCache",
        function (a, b, c) {
          return {
            priority: -200,
            scope: !1,
            compile: function (a, b) {
              var d = c.get("ui-grid/emptyBaseLayerContainer");
              return (
                a.prepend(d),
                {
                  pre: function (a, b, c, d) {},
                  post: function (a, b, c, d) {},
                }
              );
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.expandable", ["ui.grid"]);
    a.service("uiGridExpandableService", [
      "gridUtil",
      "$compile",
      function (a, b) {
        var c = {
          initializeGrid: function (b) {
            (b.expandable = {}),
              (b.expandable.expandedAll = !1),
              (b.options.enableExpandable = b.options.enableExpandable !== !1),
              (b.options.expandableRowHeight =
                b.options.expandableRowHeight || 150),
              (b.options.expandableRowHeaderWidth =
                b.options.expandableRowHeaderWidth || 40),
              b.options.enableExpandable &&
                !b.options.expandableRowTemplate &&
                (a.logError(
                  "You have not set the expandableRowTemplate, disabling expandable module"
                ),
                (b.options.enableExpandable = !1));
            var d = {
              events: {
                expandable: {
                  rowExpandedBeforeStateChanged: function (a, b) {},
                  rowExpandedStateChanged: function (a, b) {},
                },
              },
              methods: {
                expandable: {
                  toggleRowExpansion: function (a) {
                    var d = b.getRow(a);
                    null !== d && c.toggleRowExpansion(b, d);
                  },
                  expandAllRows: function () {
                    c.expandAllRows(b);
                  },
                  collapseAllRows: function () {
                    c.collapseAllRows(b);
                  },
                  toggleAllRows: function () {
                    c.toggleAllRows(b);
                  },
                  expandRow: function (a) {
                    var d = b.getRow(a);
                    null === d || d.isExpanded || c.toggleRowExpansion(b, d);
                  },
                  collapseRow: function (a) {
                    var d = b.getRow(a);
                    null !== d && d.isExpanded && c.toggleRowExpansion(b, d);
                  },
                  getExpandedRows: function () {
                    return c.getExpandedRows(b).map(function (a) {
                      return a.entity;
                    });
                  },
                },
              },
            };
            b.api.registerEventsFromObject(d.events),
              b.api.registerMethodsFromObject(d.methods);
          },
          toggleRowExpansion: function (a, b) {
            a.api.expandable.raise.rowExpandedBeforeStateChanged(b),
              (b.isExpanded = !b.isExpanded),
              angular.isUndefined(b.expandedRowHeight) &&
                (b.expandedRowHeight = a.options.expandableRowHeight),
              b.isExpanded
                ? (b.height = b.grid.options.rowHeight + b.expandedRowHeight)
                : ((b.height = b.grid.options.rowHeight),
                  (a.expandable.expandedAll = !1)),
              a.api.expandable.raise.rowExpandedStateChanged(b);
          },
          expandAllRows: function (a, b) {
            a.renderContainers.body.visibleRowCache.forEach(function (b) {
              b.isExpanded || c.toggleRowExpansion(a, b);
            }),
              (a.expandable.expandedAll = !0),
              a.queueGridRefresh();
          },
          collapseAllRows: function (a) {
            a.renderContainers.body.visibleRowCache.forEach(function (b) {
              b.isExpanded && c.toggleRowExpansion(a, b);
            }),
              (a.expandable.expandedAll = !1),
              a.queueGridRefresh();
          },
          toggleAllRows: function (a) {
            a.expandable.expandedAll
              ? c.collapseAllRows(a)
              : c.expandAllRows(a);
          },
          getExpandedRows: function (a) {
            return a.rows.filter(function (a) {
              return a.isExpanded;
            });
          },
        };
        return c;
      },
    ]),
      a.directive("uiGridExpandable", [
        "uiGridExpandableService",
        "$templateCache",
        function (a, b) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (c, d, e, f) {
                  if (
                    (a.initializeGrid(f.grid),
                    f.grid.options.enableExpandable &&
                      f.grid.options.enableExpandableRowHeader !== !1)
                  ) {
                    var g = {
                      name: "expandableButtons",
                      displayName: "",
                      exporterSuppressExport: !0,
                      enableColumnResizing: !1,
                      enableColumnMenu: !1,
                      width: f.grid.options.expandableRowHeaderWidth || 40,
                    };
                    (g.cellTemplate = b.get("ui-grid/expandableRowHeader")),
                      (g.headerCellTemplate = b.get(
                        "ui-grid/expandableTopRowHeader"
                      )),
                      f.grid.addRowHeaderColumn(g, -90);
                  }
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]),
      a.directive("uiGrid", [
        "uiGridExpandableService",
        "$templateCache",
        function (a, b) {
          return {
            replace: !0,
            priority: 599,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (a, b, c, d) {
                  d.grid.api.core.on.renderingComplete(a, function () {
                    a.row &&
                      a.row.grid &&
                      a.row.grid.options &&
                      a.row.grid.options.enableExpandable &&
                      (d.grid.parentRow = a.row);
                  });
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]),
      a.directive("uiGridExpandableRow", [
        "uiGridExpandableService",
        "$timeout",
        "$compile",
        "uiGridConstants",
        "gridUtil",
        "$interval",
        "$log",
        function (a, b, c, d, e, f, g) {
          return {
            replace: !1,
            priority: 0,
            scope: !1,
            compile: function () {
              return {
                pre: function (a, b, d, f) {
                  e.getTemplate(a.grid.options.expandableRowTemplate).then(
                    function (d) {
                      if (a.grid.options.expandableRowScope) {
                        var e = a.grid.options.expandableRowScope;
                        for (var f in e) e.hasOwnProperty(f) && (a[f] = e[f]);
                      }
                      var g = angular.element(d);
                      b.append(g), (g = c(g)(a)), (a.row.expandedRendered = !0);
                    }
                  );
                },
                post: function (a, b, c, d) {
                  a.$on("$destroy", function () {
                    a.row.expandedRendered = !1;
                  });
                },
              };
            },
          };
        },
      ]),
      a.directive("uiGridRow", [
        "$compile",
        "gridUtil",
        "$templateCache",
        function (a, b, c) {
          return {
            priority: -200,
            scope: !1,
            compile: function (a, b) {
              return {
                pre: function (a, b, c, d) {
                  a.grid.options.enableExpandable &&
                    ((a.expandableRow = {}),
                    (a.expandableRow.shouldRenderExpand = function () {
                      var b =
                        "body" === a.colContainer.name &&
                        a.grid.options.enableExpandable !== !1 &&
                        a.row.isExpanded &&
                        (!a.grid.isScrollingVertically ||
                          a.row.expandedRendered);
                      return b;
                    }),
                    (a.expandableRow.shouldRenderFiller = function () {
                      var b =
                        a.row.isExpanded &&
                        ("body" !== a.colContainer.name ||
                          (a.grid.isScrollingVertically &&
                            !a.row.expandedRendered));
                      return b;
                    }));
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]),
      a.directive("uiGridViewport", [
        "$compile",
        "gridUtil",
        "$templateCache",
        function (a, b, c) {
          return {
            priority: -200,
            scope: !1,
            compile: function (a, b) {
              var d = angular.element(a.children().children()[0]),
                e = c.get("ui-grid/expandableScrollFiller"),
                f = c.get("ui-grid/expandableRow");
              return (
                d.append(f),
                d.append(e),
                {
                  pre: function (a, b, c, d) {},
                  post: function (a, b, c, d) {},
                }
              );
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.exporter", ["ui.grid"]);
    a.constant("uiGridExporterConstants", {
      featureName: "exporter",
      ALL: "all",
      VISIBLE: "visible",
      SELECTED: "selected",
      CSV_CONTENT: "CSV_CONTENT",
      BUTTON_LABEL: "BUTTON_LABEL",
      FILE_NAME: "FILE_NAME",
    }),
      a.service("uiGridExporterService", [
        "$q",
        "uiGridExporterConstants",
        "gridUtil",
        "$compile",
        "$interval",
        "i18nService",
        function (a, b, c, d, e, f) {
          var g = {
            delay: 100,
            initializeGrid: function (a) {
              (a.exporter = {}), this.defaultGridOptions(a.options);
              var b = {
                events: { exporter: {} },
                methods: {
                  exporter: {
                    csvExport: function (b, c) {
                      g.csvExport(a, b, c);
                    },
                    pdfExport: function (b, c) {
                      g.pdfExport(a, b, c);
                    },
                  },
                },
              };
              a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods),
                a.api.core.addToGridMenu
                  ? g.addToMenu(a)
                  : e(
                      function () {
                        a.api.core.addToGridMenu && g.addToMenu(a);
                      },
                      this.delay,
                      1
                    );
            },
            defaultGridOptions: function (a) {
              (a.exporterSuppressMenu = a.exporterSuppressMenu === !0),
                (a.exporterMenuLabel = a.exporterMenuLabel
                  ? a.exporterMenuLabel
                  : "Export"),
                (a.exporterSuppressColumns = a.exporterSuppressColumns
                  ? a.exporterSuppressColumns
                  : []),
                (a.exporterCsvColumnSeparator = a.exporterCsvColumnSeparator
                  ? a.exporterCsvColumnSeparator
                  : ","),
                (a.exporterCsvFilename = a.exporterCsvFilename
                  ? a.exporterCsvFilename
                  : "download.csv"),
                (a.exporterPdfFilename = a.exporterPdfFilename
                  ? a.exporterPdfFilename
                  : "download.pdf"),
                (a.exporterOlderExcelCompatibility =
                  a.exporterOlderExcelCompatibility === !0),
                (a.exporterIsExcelCompatible =
                  a.exporterIsExcelCompatible === !0),
                (a.exporterMenuItemOrder = a.exporterMenuItemOrder
                  ? a.exporterMenuItemOrder
                  : 200),
                (a.exporterPdfDefaultStyle = a.exporterPdfDefaultStyle
                  ? a.exporterPdfDefaultStyle
                  : { fontSize: 11 }),
                (a.exporterPdfTableStyle = a.exporterPdfTableStyle
                  ? a.exporterPdfTableStyle
                  : { margin: [0, 5, 0, 15] }),
                (a.exporterPdfTableHeaderStyle = a.exporterPdfTableHeaderStyle
                  ? a.exporterPdfTableHeaderStyle
                  : { bold: !0, fontSize: 12, color: "black" }),
                (a.exporterPdfHeader = a.exporterPdfHeader
                  ? a.exporterPdfHeader
                  : null),
                (a.exporterPdfFooter = a.exporterPdfFooter
                  ? a.exporterPdfFooter
                  : null),
                (a.exporterPdfOrientation = a.exporterPdfOrientation
                  ? a.exporterPdfOrientation
                  : "landscape"),
                (a.exporterPdfPageSize = a.exporterPdfPageSize
                  ? a.exporterPdfPageSize
                  : "A4"),
                (a.exporterPdfMaxGridWidth = a.exporterPdfMaxGridWidth
                  ? a.exporterPdfMaxGridWidth
                  : 720),
                (a.exporterMenuAllData =
                  void 0 === a.exporterMenuAllData || a.exporterMenuAllData),
                (a.exporterMenuVisibleData =
                  void 0 === a.exporterMenuVisibleData ||
                  a.exporterMenuVisibleData),
                (a.exporterMenuSelectedData =
                  void 0 === a.exporterMenuSelectedData ||
                  a.exporterMenuSelectedData),
                (a.exporterMenuCsv =
                  void 0 === a.exporterMenuCsv || a.exporterMenuCsv),
                (a.exporterMenuPdf =
                  void 0 === a.exporterMenuPdf || a.exporterMenuPdf),
                (a.exporterPdfCustomFormatter =
                  a.exporterPdfCustomFormatter &&
                  "function" == typeof a.exporterPdfCustomFormatter
                    ? a.exporterPdfCustomFormatter
                    : function (a) {
                        return a;
                      }),
                (a.exporterHeaderFilterUseName =
                  a.exporterHeaderFilterUseName === !0),
                (a.exporterFieldCallback = a.exporterFieldCallback
                  ? a.exporterFieldCallback
                  : function (a, b, c, d) {
                      return d;
                    }),
                (a.exporterAllDataFn = a.exporterAllDataFn
                  ? a.exporterAllDataFn
                  : null),
                null == a.exporterAllDataFn &&
                  a.exporterAllDataPromise &&
                  (a.exporterAllDataFn = a.exporterAllDataPromise);
            },
            addToMenu: function (a) {
              a.api.core.addToGridMenu(a, [
                {
                  title: f.getSafeText("gridMenu.exporterAllAsCsv"),
                  action: function (a) {
                    this.grid.api.exporter.csvExport(b.ALL, b.ALL);
                  },
                  shown: function () {
                    return (
                      this.grid.options.exporterMenuCsv &&
                      this.grid.options.exporterMenuAllData
                    );
                  },
                  order: a.options.exporterMenuItemOrder,
                },
                {
                  title: f.getSafeText("gridMenu.exporterVisibleAsCsv"),
                  action: function (a) {
                    this.grid.api.exporter.csvExport(b.VISIBLE, b.VISIBLE);
                  },
                  shown: function () {
                    return (
                      this.grid.options.exporterMenuCsv &&
                      this.grid.options.exporterMenuVisibleData
                    );
                  },
                  order: a.options.exporterMenuItemOrder + 1,
                },
                {
                  title: f.getSafeText("gridMenu.exporterSelectedAsCsv"),
                  action: function (a) {
                    this.grid.api.exporter.csvExport(b.SELECTED, b.VISIBLE);
                  },
                  shown: function () {
                    return (
                      this.grid.options.exporterMenuCsv &&
                      this.grid.options.exporterMenuSelectedData &&
                      this.grid.api.selection &&
                      this.grid.api.selection.getSelectedRows().length > 0
                    );
                  },
                  order: a.options.exporterMenuItemOrder + 2,
                },
                {
                  title: f.getSafeText("gridMenu.exporterAllAsPdf"),
                  action: function (a) {
                    this.grid.api.exporter.pdfExport(b.ALL, b.ALL);
                  },
                  shown: function () {
                    return (
                      this.grid.options.exporterMenuPdf &&
                      this.grid.options.exporterMenuAllData
                    );
                  },
                  order: a.options.exporterMenuItemOrder + 3,
                },
                {
                  title: f.getSafeText("gridMenu.exporterVisibleAsPdf"),
                  action: function (a) {
                    this.grid.api.exporter.pdfExport(b.VISIBLE, b.VISIBLE);
                  },
                  shown: function () {
                    return (
                      this.grid.options.exporterMenuPdf &&
                      this.grid.options.exporterMenuVisibleData
                    );
                  },
                  order: a.options.exporterMenuItemOrder + 4,
                },
                {
                  title: f.getSafeText("gridMenu.exporterSelectedAsPdf"),
                  action: function (a) {
                    this.grid.api.exporter.pdfExport(b.SELECTED, b.VISIBLE);
                  },
                  shown: function () {
                    return (
                      this.grid.options.exporterMenuPdf &&
                      this.grid.options.exporterMenuSelectedData &&
                      this.grid.api.selection &&
                      this.grid.api.selection.getSelectedRows().length > 0
                    );
                  },
                  order: a.options.exporterMenuItemOrder + 5,
                },
              ]);
            },
            csvExport: function (a, b, c) {
              var d = this;
              this.loadAllDataIfNeeded(a, b, c).then(function () {
                var e = a.options.showHeader ? d.getColumnHeaders(a, c) : [],
                  f = d.getData(a, b, c),
                  g = d.formatAsCsv(e, f, a.options.exporterCsvColumnSeparator);
                d.downloadFile(
                  a.options.exporterCsvFilename,
                  g,
                  a.options.exporterCsvColumnSeparator,
                  a.options.exporterOlderExcelCompatibility,
                  a.options.exporterIsExcelCompatible
                );
              });
            },
            loadAllDataIfNeeded: function (c, d, e) {
              if (
                d === b.ALL &&
                c.rows.length !== c.options.totalItems &&
                c.options.exporterAllDataFn
              )
                return c.options.exporterAllDataFn().then(function () {
                  c.modifyRows(c.options.data);
                });
              var f = a.defer();
              return f.resolve(), f.promise;
            },
            getColumnHeaders: function (a, c) {
              var e,
                d = [];
              if (c === b.ALL) e = a.columns;
              else {
                var f = a.renderContainers.left
                    ? a.renderContainers.left.visibleColumnCache.filter(
                        function (a) {
                          return a.visible;
                        }
                      )
                    : [],
                  g = a.renderContainers.body
                    ? a.renderContainers.body.visibleColumnCache.filter(
                        function (a) {
                          return a.visible;
                        }
                      )
                    : [],
                  h = a.renderContainers.right
                    ? a.renderContainers.right.visibleColumnCache.filter(
                        function (a) {
                          return a.visible;
                        }
                      )
                    : [];
                e = f.concat(g, h);
              }
              return (
                e.forEach(function (b, c) {
                  b.colDef.exporterSuppressExport !== !0 &&
                    a.options.exporterSuppressColumns.indexOf(b.name) === -1 &&
                    d.push({
                      name: b.field,
                      displayName: a.options.exporterHeaderFilter
                        ? a.options.exporterHeaderFilterUseName
                          ? a.options.exporterHeaderFilter(b.name)
                          : a.options.exporterHeaderFilter(b.displayName)
                        : b.displayName,
                      width: b.drawnWidth ? b.drawnWidth : b.width,
                      align: "number" === b.colDef.type ? "right" : "left",
                    });
                }),
                d
              );
            },
            getData: function (a, d, e, f) {
              var h,
                i,
                g = [];
              switch (d) {
                case b.ALL:
                  h = a.rows;
                  break;
                case b.VISIBLE:
                  h = a.getVisibleRows();
                  break;
                case b.SELECTED:
                  a.api.selection
                    ? (h = a.api.selection.getSelectedGridRows())
                    : c.logError(
                        "selection feature must be enabled to allow selected rows to be exported"
                      );
              }
              if (e === b.ALL) i = a.columns;
              else {
                var j = a.renderContainers.left
                    ? a.renderContainers.left.visibleColumnCache.filter(
                        function (a) {
                          return a.visible;
                        }
                      )
                    : [],
                  k = a.renderContainers.body
                    ? a.renderContainers.body.visibleColumnCache.filter(
                        function (a) {
                          return a.visible;
                        }
                      )
                    : [],
                  l = a.renderContainers.right
                    ? a.renderContainers.right.visibleColumnCache.filter(
                        function (a) {
                          return a.visible;
                        }
                      )
                    : [];
                i = j.concat(k, l);
              }
              return (
                h.forEach(function (c, d) {
                  if (c.exporterEnableExporting !== !1) {
                    var h = [];
                    i.forEach(function (d, g) {
                      if (
                        (d.visible || e === b.ALL) &&
                        d.colDef.exporterSuppressExport !== !0 &&
                        a.options.exporterSuppressColumns.indexOf(d.name) === -1
                      ) {
                        var i = f
                            ? a.getCellDisplayValue(c, d)
                            : a.getCellValue(c, d),
                          j = {
                            value: a.options.exporterFieldCallback(a, c, d, i),
                          };
                        d.colDef.exporterPdfAlign &&
                          (j.alignment = d.colDef.exporterPdfAlign),
                          h.push(j);
                      }
                    }),
                      g.push(h);
                  }
                }),
                g
              );
            },
            formatAsCsv: function (a, b, c) {
              var d = this,
                e = a.map(function (a) {
                  return { value: a.displayName };
                }),
                f = e.length > 0 ? d.formatRowAsCsv(this, c)(e) + "\n" : "";
              return (f += b.map(this.formatRowAsCsv(this, c)).join("\n"));
            },
            formatRowAsCsv: function (a, b) {
              return function (c) {
                return c.map(a.formatFieldAsCsv).join(b);
              };
            },
            formatFieldAsCsv: function (a) {
              return null == a.value
                ? ""
                : "number" == typeof a.value
                ? a.value
                : "boolean" == typeof a.value
                ? a.value
                  ? "TRUE"
                  : "FALSE"
                : "string" == typeof a.value
                ? '"' + a.value.replace(/"/g, '""') + '"'
                : JSON.stringify(a.value);
            },
            isIE: function () {
              var a = navigator.userAgent.search(
                  /(?:Edge|MSIE|Trident\/.*; rv:)/
                ),
                b = !1;
              return a !== -1 && (b = !0), b;
            },
            downloadFile: function (a, b, c, d, e) {
              var i,
                f = document,
                g = f.createElement("a"),
                h = "application/octet-stream;charset=utf-8",
                j = this.isIE();
              if ((e && (b = "sep=" + c + "\r\n" + b), navigator.msSaveBlob))
                return navigator.msSaveOrOpenBlob(
                  new Blob([d ? "\ufeff" : "", b], { type: h }),
                  a
                );
              if (j) {
                var k = f.createElement("iframe");
                return (
                  document.body.appendChild(k),
                  k.contentWindow.document.open("text/html", "replace"),
                  k.contentWindow.document.write(b),
                  k.contentWindow.document.close(),
                  k.contentWindow.focus(),
                  k.contentWindow.document.execCommand("SaveAs", !0, a),
                  document.body.removeChild(k),
                  !0
                );
              }
              if ("download" in g) {
                var l = new Blob([d ? "\ufeff" : "", b], { type: h });
                (i = URL.createObjectURL(l)), g.setAttribute("download", a);
              } else
                (i = "data:" + h + "," + encodeURIComponent(b)),
                  g.setAttribute("target", "_blank");
              (g.href = i),
                g.setAttribute("style", "display:none;"),
                f.body.appendChild(g),
                setTimeout(function () {
                  if (g.click) g.click();
                  else if (document.createEvent) {
                    var a = document.createEvent("MouseEvents");
                    a.initEvent("click", !0, !0), g.dispatchEvent(a);
                  }
                  f.body.removeChild(g);
                }, this.delay);
            },
            pdfExport: function (a, b, c) {
              var d = this;
              this.loadAllDataIfNeeded(a, b, c).then(function () {
                var e = d.getColumnHeaders(a, c),
                  f = d.getData(a, b, c),
                  g = d.prepareAsPdf(a, e, f);
                d.isIE() || navigator.appVersion.indexOf("Edge") !== -1
                  ? d.downloadPDF(a.options.exporterPdfFilename, g)
                  : pdfMake.createPdf(g).open();
              });
            },
            downloadPDF: function (a, b) {
              var g,
                c = document;
              c.createElement("a");
              g = this.isIE();
              var i,
                h = pdfMake.createPdf(b);
              h.getBuffer(function (b) {
                if (((i = new Blob([b])), navigator.msSaveBlob))
                  return navigator.msSaveBlob(i, a);
                if (g) {
                  var d = c.createElement("iframe");
                  return (
                    document.body.appendChild(d),
                    d.contentWindow.document.open("text/html", "replace"),
                    d.contentWindow.document.write(i),
                    d.contentWindow.document.close(),
                    d.contentWindow.focus(),
                    d.contentWindow.document.execCommand("SaveAs", !0, a),
                    document.body.removeChild(d),
                    !0
                  );
                }
              });
            },
            prepareAsPdf: function (a, b, c) {
              var d = this.calculatePdfHeaderWidths(a, b),
                e = b.map(function (a) {
                  return { text: a.displayName, style: "tableHeader" };
                }),
                f = c.map(this.formatRowAsPdf(this)),
                g = [e].concat(f),
                h = {
                  pageOrientation: a.options.exporterPdfOrientation,
                  pageSize: a.options.exporterPdfPageSize,
                  content: [
                    {
                      style: "tableStyle",
                      table: { headerRows: 1, widths: d, body: g },
                    },
                  ],
                  styles: {
                    tableStyle: a.options.exporterPdfTableStyle,
                    tableHeader: a.options.exporterPdfTableHeaderStyle,
                  },
                  defaultStyle: a.options.exporterPdfDefaultStyle,
                };
              return (
                a.options.exporterPdfLayout &&
                  (h.layout = a.options.exporterPdfLayout),
                a.options.exporterPdfHeader &&
                  (h.header = a.options.exporterPdfHeader),
                a.options.exporterPdfFooter &&
                  (h.footer = a.options.exporterPdfFooter),
                a.options.exporterPdfCustomFormatter &&
                  (h = a.options.exporterPdfCustomFormatter(h)),
                h
              );
            },
            calculatePdfHeaderWidths: function (a, b) {
              var c = 0;
              b.forEach(function (a) {
                "number" == typeof a.width && (c += a.width);
              });
              var d = 0;
              b.forEach(function (a) {
                if (
                  ("*" === a.width && (d += 100),
                  "string" == typeof a.width && a.width.match(/(\d)*%/))
                ) {
                  var b = parseInt(a.width.match(/(\d)*%/)[0]);
                  (a.width = (c * b) / 100), (d += a.width);
                }
              });
              var e = c + d;
              return b.map(function (b) {
                return "*" === b.width
                  ? b.width
                  : (b.width * a.options.exporterPdfMaxGridWidth) / e;
              });
            },
            formatRowAsPdf: function (a) {
              return function (b) {
                return b.map(a.formatFieldAsPdfString);
              };
            },
            formatFieldAsPdfString: function (a) {
              var b;
              return (
                (b =
                  null == a.value
                    ? ""
                    : "number" == typeof a.value
                    ? a.value.toString()
                    : "boolean" == typeof a.value
                    ? a.value
                      ? "TRUE"
                      : "FALSE"
                    : "string" == typeof a.value
                    ? a.value.replace(/"/g, '""')
                    : JSON.stringify(a.value)
                        .replace(/^"/, "")
                        .replace(/"$/, "")),
                a.alignment &&
                  "string" == typeof a.alignment &&
                  (b = { text: b, alignment: a.alignment }),
                b
              );
            },
          };
          return g;
        },
      ]),
      a.directive("uiGridExporter", [
        "uiGridExporterConstants",
        "uiGridExporterService",
        "gridUtil",
        "$compile",
        function (a, b, c, d) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            link: function (a, c, d, e) {
              b.initializeGrid(e.grid), (e.grid.exporter.$scope = a);
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.grouping", ["ui.grid", "ui.grid.treeBase"]);
    a.constant("uiGridGroupingConstants", {
      featureName: "grouping",
      rowHeaderColName: "treeBaseRowHeaderCol",
      EXPANDED: "expanded",
      COLLAPSED: "collapsed",
      aggregation: {
        COUNT: "count",
        SUM: "sum",
        MAX: "max",
        MIN: "min",
        AVG: "avg",
      },
    }),
      a.service("uiGridGroupingService", [
        "$q",
        "uiGridGroupingConstants",
        "gridUtil",
        "rowSorter",
        "GridRow",
        "gridClassFactory",
        "i18nService",
        "uiGridConstants",
        "uiGridTreeBaseService",
        function (a, b, c, d, e, f, g, h, i) {
          var j = {
            initializeGrid: function (a, b) {
              i.initializeGrid(a, b),
                (a.grouping = {}),
                (a.grouping.groupHeaderCache = {}),
                j.defaultGridOptions(a.options),
                a.registerRowsProcessor(j.groupRows, 400),
                a.registerColumnBuilder(j.groupingColumnBuilder),
                a.registerColumnsProcessor(j.groupingColumnProcessor, 400);
              var c = {
                events: {
                  grouping: { aggregationChanged: {}, groupingChanged: {} },
                },
                methods: {
                  grouping: {
                    getGrouping: function (b) {
                      var c = j.getGrouping(a);
                      return (
                        c.grouping.forEach(function (a) {
                          (a.colName = a.col.name), delete a.col;
                        }),
                        c.aggregations.forEach(function (a) {
                          (a.colName = a.col.name), delete a.col;
                        }),
                        (c.aggregations = c.aggregations.filter(function (a) {
                          return (
                            !a.aggregation.source ||
                            "grouping" !== a.aggregation.source
                          );
                        })),
                        b &&
                          (c.rowExpandedStates = j.getRowExpandedStates(
                            a.grouping.groupingHeaderCache
                          )),
                        c
                      );
                    },
                    setGrouping: function (b) {
                      j.setGrouping(a, b);
                    },
                    groupColumn: function (b) {
                      var c = a.getColumn(b);
                      j.groupColumn(a, c);
                    },
                    ungroupColumn: function (b) {
                      var c = a.getColumn(b);
                      j.ungroupColumn(a, c);
                    },
                    clearGrouping: function () {
                      j.clearGrouping(a);
                    },
                    aggregateColumn: function (b, c, d) {
                      var e = a.getColumn(b);
                      j.aggregateColumn(a, e, c, d);
                    },
                  },
                },
              };
              a.api.registerEventsFromObject(c.events),
                a.api.registerMethodsFromObject(c.methods),
                a.api.core.on.sortChanged(b, j.tidyPriorities);
            },
            defaultGridOptions: function (a) {
              (a.enableGrouping = a.enableGrouping !== !1),
                (a.groupingShowCounts = a.groupingShowCounts !== !1),
                (a.groupingNullLabel =
                  "undefined" == typeof a.groupingNullLabel
                    ? "Null"
                    : a.groupingNullLabel),
                (a.enableGroupHeaderSelection =
                  a.enableGroupHeaderSelection === !0);
            },
            groupingColumnBuilder: function (a, d, e) {
              if (a.enableGrouping !== !1) {
                "undefined" == typeof d.grouping &&
                "undefined" != typeof a.grouping
                  ? ((d.grouping = angular.copy(a.grouping)),
                    "undefined" != typeof d.grouping.groupPriority &&
                      d.grouping.groupPriority > -1 &&
                      ((d.treeAggregationFn = i.nativeAggregations()[
                        b.aggregation.COUNT
                      ].aggregationFn),
                      (d.treeAggregationFinalizerFn = j.groupedFinalizerFn)))
                  : "undefined" == typeof d.grouping && (d.grouping = {}),
                  "undefined" != typeof d.grouping &&
                    "undefined" != typeof d.grouping.groupPriority &&
                    d.grouping.groupPriority >= 0 &&
                    (d.suppressRemoveSort = !0);
                var f = {
                    name: "ui.grid.grouping.group",
                    title: g.get().grouping.group,
                    icon: "ui-grid-icon-indent-right",
                    shown: function () {
                      return (
                        "undefined" == typeof this.context.col.grouping ||
                        "undefined" ==
                          typeof this.context.col.grouping.groupPriority ||
                        this.context.col.grouping.groupPriority < 0
                      );
                    },
                    action: function () {
                      j.groupColumn(this.context.col.grid, this.context.col);
                    },
                  },
                  h = {
                    name: "ui.grid.grouping.ungroup",
                    title: g.get().grouping.ungroup,
                    icon: "ui-grid-icon-indent-left",
                    shown: function () {
                      return (
                        "undefined" != typeof this.context.col.grouping &&
                        "undefined" !=
                          typeof this.context.col.grouping.groupPriority &&
                        this.context.col.grouping.groupPriority >= 0
                      );
                    },
                    action: function () {
                      j.ungroupColumn(this.context.col.grid, this.context.col);
                    },
                  },
                  k = {
                    name: "ui.grid.grouping.aggregateRemove",
                    title: g.get().grouping.aggregate_remove,
                    shown: function () {
                      return (
                        "undefined" != typeof this.context.col.treeAggregationFn
                      );
                    },
                    action: function () {
                      j.aggregateColumn(
                        this.context.col.grid,
                        this.context.col,
                        null
                      );
                    },
                  },
                  l = function (a, b) {
                    b = b || g.get().grouping["aggregate_" + a] || a;
                    var e = {
                      name: "ui.grid.grouping.aggregate" + a,
                      title: b,
                      shown: function () {
                        return (
                          "undefined" ==
                            typeof this.context.col.treeAggregation ||
                          "undefined" ==
                            typeof this.context.col.treeAggregation.type ||
                          this.context.col.treeAggregation.type !== a
                        );
                      },
                      action: function () {
                        j.aggregateColumn(
                          this.context.col.grid,
                          this.context.col,
                          a
                        );
                      },
                    };
                    c.arrayContainsObjectWithProperty(
                      d.menuItems,
                      "name",
                      "ui.grid.grouping.aggregate" + a
                    ) || d.menuItems.push(e);
                  };
                d.colDef.groupingShowGroupingMenu !== !1 &&
                  (c.arrayContainsObjectWithProperty(
                    d.menuItems,
                    "name",
                    "ui.grid.grouping.group"
                  ) || d.menuItems.push(f),
                  c.arrayContainsObjectWithProperty(
                    d.menuItems,
                    "name",
                    "ui.grid.grouping.ungroup"
                  ) || d.menuItems.push(h)),
                  d.colDef.groupingShowAggregationMenu !== !1 &&
                    (angular.forEach(i.nativeAggregations(), function (a, b) {
                      l(b);
                    }),
                    angular.forEach(e.treeCustomAggregations, function (a, b) {
                      l(b, a.menuTitle);
                    }),
                    c.arrayContainsObjectWithProperty(
                      d.menuItems,
                      "name",
                      "ui.grid.grouping.aggregateRemove"
                    ) || d.menuItems.push(k));
              }
            },
            groupingColumnProcessor: function (a, b) {
              return (a = j.moveGroupColumns(this, a, b));
            },
            groupedFinalizerFn: function (a) {
              var b = this;
              "undefined" != typeof a.groupVal
                ? ((a.rendered = a.groupVal),
                  b.grid.options.groupingShowCounts &&
                    "date" !== b.colDef.type &&
                    "object" !== b.colDef.type &&
                    (a.rendered += " (" + a.value + ")"))
                : (a.rendered = null);
            },
            moveGroupColumns: function (a, b, c) {
              return a.options.moveGroupColumns === !1
                ? b
                : (b.forEach(function (a, b) {
                    a.groupingPosition = b;
                  }),
                  b.sort(function (a, b) {
                    var c, d;
                    return (
                      (c = a.isRowHeader
                        ? a.headerPriority
                        : "undefined" == typeof a.grouping ||
                          "undefined" == typeof a.grouping.groupPriority ||
                          a.grouping.groupPriority < 0
                        ? null
                        : a.grouping.groupPriority),
                      (d = b.isRowHeader
                        ? b.headerPriority
                        : "undefined" == typeof b.grouping ||
                          "undefined" == typeof b.grouping.groupPriority ||
                          b.grouping.groupPriority < 0
                        ? null
                        : b.grouping.groupPriority),
                      null !== c && null === d
                        ? -1
                        : null !== d && null === c
                        ? 1
                        : null !== c && null !== d
                        ? c - d
                        : a.groupingPosition - b.groupingPosition
                    );
                  }),
                  b.forEach(function (a, b) {
                    delete a.groupingPosition;
                  }),
                  b);
            },
            groupColumn: function (a, c) {
              "undefined" == typeof c.grouping && (c.grouping = {});
              var d = j.getGrouping(a);
              (c.grouping.groupPriority = d.grouping.length),
                (c.previousSort = angular.copy(c.sort)),
                c.sort
                  ? ("undefined" != typeof c.sort.direction &&
                      null !== c.sort.direction) ||
                    (c.sort.direction = h.ASC)
                  : (c.sort = { direction: h.ASC }),
                (c.treeAggregation = {
                  type: b.aggregation.COUNT,
                  source: "grouping",
                }),
                (c.treeAggregationFn = i.nativeAggregations()[
                  b.aggregation.COUNT
                ].aggregationFn),
                (c.treeAggregationFinalizerFn = j.groupedFinalizerFn),
                a.api.grouping.raise.groupingChanged(c),
                a.api.core.raise.sortChanged(a, a.getColumnSorting()),
                a.queueGridRefresh();
            },
            ungroupColumn: function (a, b) {
              "undefined" != typeof b.grouping &&
                (delete b.grouping.groupPriority,
                delete b.treeAggregation,
                delete b.customTreeAggregationFinalizer,
                b.previousSort &&
                  ((b.sort = b.previousSort), delete b.previousSort),
                j.tidyPriorities(a),
                a.api.grouping.raise.groupingChanged(b),
                a.api.core.raise.sortChanged(a, a.getColumnSorting()),
                a.queueGridRefresh());
            },
            aggregateColumn: function (a, b, c) {
              "undefined" != typeof b.grouping &&
                "undefined" != typeof b.grouping.groupPriority &&
                b.grouping.groupPriority >= 0 &&
                j.ungroupColumn(a, b);
              var d = {};
              "undefined" != typeof a.options.treeCustomAggregations[c]
                ? (d = a.options.treeCustomAggregations[c])
                : "undefined" != typeof i.nativeAggregations()[c] &&
                  (d = i.nativeAggregations()[c]),
                (b.treeAggregation = {
                  type: c,
                  label: g.get().aggregation[d.label] || d.label,
                }),
                (b.treeAggregationFn = d.aggregationFn),
                (b.treeAggregationFinalizerFn = d.finalizerFn),
                a.api.grouping.raise.aggregationChanged(b),
                a.queueGridRefresh();
            },
            setGrouping: function (a, b) {
              "undefined" != typeof b &&
                (j.clearGrouping(a),
                b.grouping &&
                  b.grouping.length &&
                  b.grouping.length > 0 &&
                  b.grouping.forEach(function (b) {
                    var c = a.getColumn(b.colName);
                    c && j.groupColumn(a, c);
                  }),
                b.aggregations &&
                  b.aggregations.length &&
                  b.aggregations.forEach(function (b) {
                    var c = a.getColumn(b.colName);
                    c && j.aggregateColumn(a, c, b.aggregation.type);
                  }),
                b.rowExpandedStates &&
                  j.applyRowExpandedStates(
                    a.grouping.groupingHeaderCache,
                    b.rowExpandedStates
                  ));
            },
            clearGrouping: function (a) {
              var b = j.getGrouping(a);
              b.grouping.length > 0 &&
                b.grouping.forEach(function (b) {
                  b.col || (b.col = a.getColumn(b.colName)),
                    j.ungroupColumn(a, b.col);
                }),
                b.aggregations.length > 0 &&
                  b.aggregations.forEach(function (b) {
                    b.col || (b.col = a.getColumn(b.colName)),
                      j.aggregateColumn(a, b.col, null);
                  });
            },
            tidyPriorities: function (a) {
              ("undefined" != typeof a && "undefined" == typeof a.grid) ||
                "undefined" == typeof this.grid ||
                (a = this.grid);
              var b = [],
                c = [];
              a.columns.forEach(function (a, d) {
                "undefined" != typeof a.grouping &&
                "undefined" != typeof a.grouping.groupPriority &&
                a.grouping.groupPriority >= 0
                  ? b.push(a)
                  : "undefined" != typeof a.sort &&
                    "undefined" != typeof a.sort.priority &&
                    a.sort.priority >= 0 &&
                    c.push(a);
              }),
                b.sort(function (a, b) {
                  return a.grouping.groupPriority - b.grouping.groupPriority;
                }),
                b.forEach(function (a, b) {
                  (a.grouping.groupPriority = b),
                    (a.suppressRemoveSort = !0),
                    "undefined" == typeof a.sort && (a.sort = {}),
                    (a.sort.priority = b);
                });
              var d = b.length;
              c.sort(function (a, b) {
                return a.sort.priority - b.sort.priority;
              }),
                c.forEach(function (a, b) {
                  (a.sort.priority = d),
                    (a.suppressRemoveSort = a.colDef.suppressRemoveSort),
                    d++;
                });
            },
            groupRows: function (a) {
              if (0 === a.length) return a;
              var b = this;
              (b.grouping.oldGroupingHeaderCache =
                b.grouping.groupingHeaderCache || {}),
                (b.grouping.groupingHeaderCache = {});
              for (
                var c = j.initialiseProcessingState(b),
                  e = function (e, h) {
                    var i = b.getCellValue(g, e.col);
                    (e.initialised &&
                      0 === d.getSortFn(b, e.col, a)(i, e.currentValue)) ||
                      (j.insertGroupHeader(b, a, f, c, h), f++);
                  },
                  f = 0;
                f < a.length;
                f++
              ) {
                var g = a[f];
                g.visible && c.forEach(e);
              }
              return delete b.grouping.oldGroupingHeaderCache, a;
            },
            initialiseProcessingState: function (a) {
              var b = [],
                c = j.getGrouping(a);
              return (
                c.grouping.forEach(function (a, c) {
                  b.push({
                    fieldName: a.field,
                    col: a.col,
                    initialised: !1,
                    currentValue: null,
                    currentRow: null,
                  });
                }),
                b
              );
            },
            getGrouping: function (a) {
              var b = [],
                c = [];
              return (
                a.columns.forEach(function (a, d) {
                  a.grouping &&
                    "undefined" != typeof a.grouping.groupPriority &&
                    a.grouping.groupPriority >= 0 &&
                    b.push({
                      field: a.field,
                      col: a,
                      groupPriority: a.grouping.groupPriority,
                      grouping: a.grouping,
                    }),
                    a.treeAggregation &&
                      a.treeAggregation.type &&
                      c.push({
                        field: a.field,
                        col: a,
                        aggregation: a.treeAggregation,
                      });
                }),
                b.sort(function (a, b) {
                  return a.groupPriority - b.groupPriority;
                }),
                b.forEach(function (a, b) {
                  (a.grouping.groupPriority = b),
                    (a.groupPriority = b),
                    delete a.grouping;
                }),
                { grouping: b, aggregations: c }
              );
            },
            insertGroupHeader: function (a, b, c, d, g) {
              var i = (d[g].fieldName, d[g].col),
                k = a.getCellValue(b[c], i),
                l = k;
              ("undefined" != typeof k && null !== k) ||
                (l = a.options.groupingNullLabel);
              for (
                var m = function (a) {
                    return angular.isObject(a) ? JSON.stringify(a) : a;
                  },
                  n = a.grouping.oldGroupingHeaderCache,
                  o = 0;
                o < g;
                o++
              )
                n &&
                  n[m(d[o].currentValue)] &&
                  (n = n[m(d[o].currentValue)].children);
              var p;
              for (
                n && n[m(k)]
                  ? ((p = n[m(k)].row), (p.entity = {}))
                  : ((p = new e({}, null, a)),
                    f.rowTemplateAssigner.call(a, p)),
                  p.entity["$$" + d[g].col.uid] = { groupVal: l },
                  p.treeLevel = g,
                  p.groupHeader = !0,
                  p.internalRow = !0,
                  p.enableCellEdit = !1,
                  p.enableSelection = a.options.enableGroupHeaderSelection,
                  d[g].initialised = !0,
                  d[g].currentValue = k,
                  d[g].currentRow = p,
                  j.finaliseProcessingState(d, g + 1),
                  b.splice(c, 0, p),
                  n = a.grouping.groupingHeaderCache,
                  o = 0;
                o < g;
                o++
              )
                n = n[m(d[o].currentValue)].children;
              n[m(k)] = { row: p, children: {} };
            },
            finaliseProcessingState: function (a, b) {
              for (var c = b; c < a.length; c++)
                (a[c].initialised = !1),
                  (a[c].currentRow = null),
                  (a[c].currentValue = null);
            },
            getRowExpandedStates: function (a) {
              if ("undefined" == typeof a) return {};
              var b = {};
              return (
                angular.forEach(a, function (a, c) {
                  (b[c] = { state: a.row.treeNode.state }),
                    a.children
                      ? (b[c].children = j.getRowExpandedStates(a.children))
                      : (b[c].children = {});
                }),
                b
              );
            },
            applyRowExpandedStates: function (a, b) {
              "undefined" != typeof b &&
                angular.forEach(b, function (b, c) {
                  a[c] &&
                    ((a[c].row.treeNode.state = b.state),
                    b.children &&
                      a[c].children &&
                      j.applyRowExpandedStates(a[c].children, b.children));
                });
            },
          };
          return j;
        },
      ]),
      a.directive("uiGridGrouping", [
        "uiGridGroupingConstants",
        "uiGridGroupingService",
        "$templateCache",
        function (a, b, c) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (a, c, d, e) {
                  e.grid.options.enableGrouping !== !1 &&
                    b.initializeGrid(e.grid, a);
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.importer", ["ui.grid"]);
    a.constant("uiGridImporterConstants", { featureName: "importer" }),
      a.service("uiGridImporterService", [
        "$q",
        "uiGridConstants",
        "uiGridImporterConstants",
        "gridUtil",
        "$compile",
        "$interval",
        "i18nService",
        "$window",
        function (a, b, c, d, e, f, g, h) {
          var i = {
            initializeGrid: function (a, b) {
              (b.importer = { $scope: a }), this.defaultGridOptions(b.options);
              var c = {
                events: { importer: {} },
                methods: {
                  importer: {
                    importFile: function (a) {
                      i.importThisFile(b, a);
                    },
                  },
                },
              };
              b.api.registerEventsFromObject(c.events),
                b.api.registerMethodsFromObject(c.methods),
                b.options.enableImporter &&
                  b.options.importerShowMenu &&
                  (b.api.core.addToGridMenu
                    ? i.addToMenu(b)
                    : f(
                        function () {
                          b.api.core.addToGridMenu && i.addToMenu(b);
                        },
                        100,
                        1
                      ));
            },
            defaultGridOptions: function (a) {
              a.enableImporter || void 0 === a.enableImporter
                ? h.hasOwnProperty("File") &&
                  h.hasOwnProperty("FileReader") &&
                  h.hasOwnProperty("FileList") &&
                  h.hasOwnProperty("Blob")
                  ? (a.enableImporter = !0)
                  : (d.logError(
                      "The File APIs are not fully supported in this browser, grid importer cannot be used."
                    ),
                    (a.enableImporter = !1))
                : (a.enableImporter = !1),
                (a.importerProcessHeaders =
                  a.importerProcessHeaders || i.processHeaders),
                (a.importerHeaderFilter =
                  a.importerHeaderFilter ||
                  function (a) {
                    return a;
                  }),
                (a.importerErrorCallback &&
                  "function" == typeof a.importerErrorCallback) ||
                  delete a.importerErrorCallback,
                a.enableImporter !== !0 ||
                  a.importerDataAddCallback ||
                  (d.logError(
                    "You have not set an importerDataAddCallback, importer is disabled"
                  ),
                  (a.enableImporter = !1)),
                (a.importerShowMenu = a.importerShowMenu !== !1),
                (a.importerObjectCallback =
                  a.importerObjectCallback ||
                  function (a, b) {
                    return b;
                  });
            },
            addToMenu: function (a) {
              a.api.core.addToGridMenu(a, [
                { title: g.getSafeText("gridMenu.importerTitle"), order: 150 },
                {
                  templateUrl: "ui-grid/importerMenuItemContainer",
                  action: function (b) {
                    this.grid.api.importer.importAFile(a);
                  },
                  order: 151,
                },
              ]);
            },
            importThisFile: function (a, b) {
              if (!b)
                return void d.logError(
                  "No file object provided to importThisFile, should be impossible, aborting"
                );
              var c = new FileReader();
              switch (b.type) {
                case "application/json":
                  c.onload = i.importJsonClosure(a);
                  break;
                default:
                  c.onload = i.importCsvClosure(a);
              }
              c.readAsText(b);
            },
            importJsonClosure: function (a) {
              return function (b) {
                var d,
                  c = [],
                  e = i.parseJson(a, b);
                null !== e &&
                  (e.forEach(function (b, e) {
                    (d = i.newObject(a)),
                      angular.extend(d, b),
                      (d = a.options.importerObjectCallback(a, d)),
                      c.push(d);
                  }),
                  i.addObjects(a, c));
              };
            },
            parseJson: function (a, b) {
              var c;
              try {
                c = JSON.parse(b.target.result);
              } catch (c) {
                return void i.alertError(
                  a,
                  "importer.invalidJson",
                  "File could not be processed, is it valid json? Content was: ",
                  b.target.result
                );
              }
              return Array.isArray(c)
                ? c
                : (i.alertError(
                    a,
                    "importer.jsonNotarray",
                    "Import failed, file is not an array, file was: ",
                    b.target.result
                  ),
                  []);
            },
            importCsvClosure: function (a) {
              return function (b) {
                var c = i.parseCsv(b);
                if (!c || c.length < 1)
                  return void i.alertError(
                    a,
                    "importer.invalidCsv",
                    "File could not be processed, is it valid csv? Content was: ",
                    b.target.result
                  );
                var d = i.createCsvObjects(a, c);
                return d && 0 !== d.length
                  ? void i.addObjects(a, d)
                  : void i.alertError(
                      a,
                      "importer.noObjects",
                      "Objects were not able to be derived, content was: ",
                      b.target.result
                    );
              };
            },
            parseCsv: function (a) {
              var b = a.target.result;
              return CSV.parse(b);
            },
            createCsvObjects: function (a, b) {
              var c = a.options.importerProcessHeaders(a, b.shift());
              if (!c || 0 === c.length)
                return (
                  i.alertError(
                    a,
                    "importer.noHeaders",
                    "Column names could not be derived, content was: ",
                    b
                  ),
                  []
                );
              var e,
                d = [];
              return (
                b.forEach(function (b, f) {
                  (e = i.newObject(a)),
                    null !== b &&
                      b.forEach(function (a, b) {
                        null !== c[b] && (e[c[b]] = a);
                      }),
                    (e = a.options.importerObjectCallback(a, e)),
                    d.push(e);
                }),
                d
              );
            },
            processHeaders: function (a, b) {
              var c = [];
              if (a.options.columnDefs && 0 !== a.options.columnDefs.length) {
                var d = i.flattenColumnDefs(a, a.options.columnDefs);
                return (
                  b.forEach(function (a, b) {
                    d[a]
                      ? c.push(d[a])
                      : d[a.toLowerCase()]
                      ? c.push(d[a.toLowerCase()])
                      : c.push(null);
                  }),
                  c
                );
              }
              return (
                b.forEach(function (a, b) {
                  c.push(a.replace(/[^0-9a-zA-Z\-_]/g, "_"));
                }),
                c
              );
            },
            flattenColumnDefs: function (a, b) {
              var c = {};
              return (
                b.forEach(function (b, d) {
                  b.name &&
                    ((c[b.name] = b.field || b.name),
                    (c[b.name.toLowerCase()] = b.field || b.name)),
                    b.field &&
                      ((c[b.field] = b.field || b.name),
                      (c[b.field.toLowerCase()] = b.field || b.name)),
                    b.displayName &&
                      ((c[b.displayName] = b.field || b.name),
                      (c[b.displayName.toLowerCase()] = b.field || b.name)),
                    b.displayName &&
                      a.options.importerHeaderFilter &&
                      ((c[a.options.importerHeaderFilter(b.displayName)] =
                        b.field || b.name),
                      (c[
                        a.options
                          .importerHeaderFilter(b.displayName)
                          .toLowerCase()
                      ] = b.field || b.name));
                }),
                c
              );
            },
            addObjects: function (a, c, d) {
              if (a.api.rowEdit) {
                var e = a.registerDataChangeCallback(
                  function () {
                    a.api.rowEdit.setRowsDirty(c), e();
                  },
                  [b.dataChange.ROW]
                );
                a.importer.$scope.$on("$destroy", e);
              }
              a.importer.$scope.$apply(a.options.importerDataAddCallback(a, c));
            },
            newObject: function (a) {
              return "undefined" != typeof a.options &&
                "undefined" != typeof a.options.importerNewObject
                ? new a.options.importerNewObject()
                : {};
            },
            alertError: function (a, b, c, e) {
              a.options.importerErrorCallback
                ? a.options.importerErrorCallback(a, b, c, e)
                : (h.alert(g.getSafeText(b)), d.logError(c + e));
            },
          };
          return i;
        },
      ]),
      a.directive("uiGridImporter", [
        "uiGridImporterConstants",
        "uiGridImporterService",
        "gridUtil",
        "$compile",
        function (a, b, c, d) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            link: function (a, c, d, e) {
              b.initializeGrid(a, e.grid);
            },
          };
        },
      ]),
      a.directive("uiGridImporterMenuItem", [
        "uiGridImporterConstants",
        "uiGridImporterService",
        "gridUtil",
        "$compile",
        function (a, b, c, d) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            templateUrl: "ui-grid/importerMenuItem",
            link: function (a, d, e, f) {
              var g = function (a) {
                  var c = a.srcElement || a.target;
                  if (c && c.files && 1 === c.files.length) {
                    var d = c.files[0];
                    b.importThisFile(i, d), c.form.reset();
                  }
                },
                h = d[0].querySelectorAll(".ui-grid-importer-file-chooser"),
                i = f.grid;
              1 !== h.length
                ? c.logError(
                    "Found > 1 or < 1 file choosers within the menu item, error, cannot continue"
                  )
                : h[0].addEventListener("change", g, !1);
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.infiniteScroll", ["ui.grid"]);
    a.service("uiGridInfiniteScrollService", [
      "gridUtil",
      "$compile",
      "$timeout",
      "uiGridConstants",
      "ScrollEvent",
      "$q",
      function (a, b, c, d, e, f) {
        var g = {
          initializeGrid: function (a, b) {
            if (
              (g.defaultGridOptions(a.options), a.options.enableInfiniteScroll)
            ) {
              (a.infiniteScroll = { dataLoading: !1 }),
                g.setScrollDirections(
                  a,
                  a.options.infiniteScrollUp,
                  a.options.infiniteScrollDown
                ),
                a.api.core.on.scrollEnd(b, g.handleScroll);
              var c = {
                events: {
                  infiniteScroll: {
                    needLoadMoreData: function (a, b) {},
                    needLoadMoreDataTop: function (a, b) {},
                  },
                },
                methods: {
                  infiniteScroll: {
                    dataLoaded: function (b, c) {
                      g.setScrollDirections(a, b, c);
                      var d = g.adjustScroll(a).then(function () {
                        a.infiniteScroll.dataLoading = !1;
                      });
                      return d;
                    },
                    resetScroll: function (b, c) {
                      g.setScrollDirections(a, b, c),
                        g.adjustInfiniteScrollPosition(a, 0);
                    },
                    saveScrollPercentage: function () {
                      (a.infiniteScroll.prevScrollTop =
                        a.renderContainers.body.prevScrollTop),
                        (a.infiniteScroll.previousVisibleRows = a.getVisibleRowCount());
                    },
                    dataRemovedTop: function (b, c) {
                      g.dataRemovedTop(a, b, c);
                    },
                    dataRemovedBottom: function (b, c) {
                      g.dataRemovedBottom(a, b, c);
                    },
                    setScrollDirections: function (b, c) {
                      g.setScrollDirections(a, b, c);
                    },
                  },
                },
              };
              a.api.registerEventsFromObject(c.events),
                a.api.registerMethodsFromObject(c.methods);
            }
          },
          defaultGridOptions: function (a) {
            (a.enableInfiniteScroll = a.enableInfiniteScroll !== !1),
              (a.infiniteScrollRowsFromEnd = a.infiniteScrollRowsFromEnd || 20),
              (a.infiniteScrollUp = a.infiniteScrollUp === !0),
              (a.infiniteScrollDown = a.infiniteScrollDown !== !1);
          },
          setScrollDirections: function (a, b, c) {
            (a.infiniteScroll.scrollUp = b === !0),
              (a.suppressParentScrollUp = b === !0),
              (a.infiniteScroll.scrollDown = c !== !1),
              (a.suppressParentScrollDown = c !== !1);
          },
          handleScroll: function (a) {
            if (
              !(
                (a.grid.infiniteScroll && a.grid.infiniteScroll.dataLoading) ||
                "ui.grid.adjustInfiniteScrollPosition" === a.source
              ) &&
              a.y
            )
              if (0 === a.y.percentage)
                (a.grid.scrollDirection = d.scrollDirection.UP),
                  g.loadData(a.grid);
              else if (1 === a.y.percentage)
                (a.grid.scrollDirection = d.scrollDirection.DOWN),
                  g.loadData(a.grid);
              else {
                var b,
                  c =
                    a.grid.options.infiniteScrollRowsFromEnd /
                    a.grid.renderContainers.body.visibleRowCache.length;
                a.grid.scrollDirection === d.scrollDirection.UP
                  ? ((b = a.y.percentage), b <= c && g.loadData(a.grid))
                  : a.grid.scrollDirection === d.scrollDirection.DOWN &&
                    ((b = 1 - a.y.percentage), b <= c && g.loadData(a.grid));
              }
          },
          loadData: function (a) {
            (a.infiniteScroll.previousVisibleRows =
              a.renderContainers.body.visibleRowCache.length),
              (a.infiniteScroll.direction = a.scrollDirection),
              delete a.infiniteScroll.prevScrollTop,
              a.scrollDirection === d.scrollDirection.UP &&
              a.infiniteScroll.scrollUp
                ? ((a.infiniteScroll.dataLoading = !0),
                  a.api.infiniteScroll.raise.needLoadMoreDataTop())
                : a.scrollDirection === d.scrollDirection.DOWN &&
                  a.infiniteScroll.scrollDown &&
                  ((a.infiniteScroll.dataLoading = !0),
                  a.api.infiniteScroll.raise.needLoadMoreData());
          },
          adjustScroll: function (a) {
            var b = f.defer();
            return (
              c(function () {
                var f, h, i, j, k;
                (f =
                  a.getViewportHeight() +
                  a.headerHeight -
                  a.renderContainers.body.headerHeight -
                  a.scrollbarHeight),
                  (h = a.options.rowHeight),
                  void 0 === a.infiniteScroll.direction &&
                    g.adjustInfiniteScrollPosition(a, 0),
                  (i = a.getVisibleRowCount());
                var l = h * i;
                a.infiniteScroll.scrollDown &&
                  f > l &&
                  a.api.infiniteScroll.raise.needLoadMoreData(),
                  a.infiniteScroll.direction === d.scrollDirection.UP &&
                    ((j = a.infiniteScroll.prevScrollTop || 0),
                    (k = j + (i - a.infiniteScroll.previousVisibleRows) * h),
                    g.adjustInfiniteScrollPosition(a, k),
                    c(function () {
                      b.resolve();
                    })),
                  a.infiniteScroll.direction === d.scrollDirection.DOWN &&
                    ((k =
                      a.infiniteScroll.prevScrollTop ||
                      a.infiniteScroll.previousVisibleRows * h - f),
                    g.adjustInfiniteScrollPosition(a, k),
                    c(function () {
                      b.resolve();
                    }));
              }, 0),
              b.promise
            );
          },
          adjustInfiniteScrollPosition: function (a, b) {
            var c = new e(
                a,
                null,
                null,
                "ui.grid.adjustInfiniteScrollPosition"
              ),
              d = a.getVisibleRowCount(),
              f =
                a.getViewportHeight() +
                a.headerHeight -
                a.renderContainers.body.headerHeight -
                a.scrollbarHeight,
              g = a.options.rowHeight,
              h = d * g - f;
            0 === b && a.infiniteScroll.scrollUp
              ? (c.y = { percentage: 1 / h })
              : (c.y = { percentage: b / h }),
              a.scrollContainers("", c);
          },
          dataRemovedTop: function (a, b, c) {
            var d, e, f, h;
            g.setScrollDirections(a, b, c),
              (d = a.renderContainers.body.visibleRowCache.length),
              (e = a.infiniteScroll.prevScrollTop),
              (h = a.options.rowHeight),
              (f = e - (a.infiniteScroll.previousVisibleRows - d) * h),
              g.adjustInfiniteScrollPosition(a, f);
          },
          dataRemovedBottom: function (a, b, c) {
            var d;
            g.setScrollDirections(a, b, c),
              (d = a.infiniteScroll.prevScrollTop),
              g.adjustInfiniteScrollPosition(a, d);
          },
        };
        return g;
      },
    ]),
      a.directive("uiGridInfiniteScroll", [
        "uiGridInfiniteScrollService",
        function (a) {
          return {
            priority: -200,
            scope: !1,
            require: "^uiGrid",
            compile: function (b, c, d) {
              return {
                pre: function (b, c, d, e) {
                  a.initializeGrid(e.grid, b);
                },
                post: function (a, b, c) {},
              };
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.moveColumns", ["ui.grid"]);
    a.service("uiGridMoveColumnService", [
      "$q",
      "$timeout",
      "$log",
      "ScrollEvent",
      "uiGridConstants",
      "gridUtil",
      function (a, b, c, d, e, f) {
        var g = {
          initializeGrid: function (a) {
            var b = this;
            this.registerPublicApi(a),
              this.defaultGridOptions(a.options),
              (a.moveColumns = { orderCache: [] }),
              a.registerColumnBuilder(b.movableColumnBuilder),
              a.registerDataChangeCallback(b.verifyColumnOrder, [
                e.dataChange.COLUMN,
              ]);
          },
          registerPublicApi: function (a) {
            var b = this,
              c = {
                events: {
                  colMovable: { columnPositionChanged: function (a, b, c) {} },
                },
                methods: {
                  colMovable: {
                    moveColumn: function (c, d) {
                      var e = a.columns;
                      if (!angular.isNumber(c) || !angular.isNumber(d))
                        return void f.logError(
                          "MoveColumn: Please provide valid values for originalPosition and finalPosition"
                        );
                      for (var g = 0, h = 0; h < e.length; h++)
                        ((angular.isDefined(e[h].colDef.visible) &&
                          e[h].colDef.visible === !1) ||
                          e[h].isRowHeader === !0) &&
                          g++;
                      if (c >= e.length - g || d >= e.length - g)
                        return void f.logError(
                          "MoveColumn: Invalid values for originalPosition, finalPosition"
                        );
                      var i = function (a) {
                        for (var b = a, c = 0; c <= b; c++)
                          angular.isDefined(e[c]) &&
                            ((angular.isDefined(e[c].colDef.visible) &&
                              e[c].colDef.visible === !1) ||
                              e[c].isRowHeader === !0) &&
                            b++;
                        return b;
                      };
                      b.redrawColumnAtPosition(a, i(c), i(d));
                    },
                  },
                },
              };
            a.api.registerEventsFromObject(c.events),
              a.api.registerMethodsFromObject(c.methods);
          },
          defaultGridOptions: function (a) {
            a.enableColumnMoving = a.enableColumnMoving !== !1;
          },
          movableColumnBuilder: function (b, c, d) {
            var e = [];
            return (
              (b.enableColumnMoving =
                void 0 === b.enableColumnMoving
                  ? d.enableColumnMoving
                  : b.enableColumnMoving),
              a.all(e)
            );
          },
          updateColumnCache: function (a) {
            a.moveColumns.orderCache = a.getOnlyDataColumns();
          },
          verifyColumnOrder: function (a) {
            var c,
              b = a.rowHeaderColumns.length;
            angular.forEach(a.moveColumns.orderCache, function (d, e) {
              if (((c = a.columns.indexOf(d)), c !== -1 && c - b !== e)) {
                var f = a.columns.splice(c, 1)[0];
                a.columns.splice(e + b, 0, f);
              }
            });
          },
          redrawColumnAtPosition: function (a, c, d) {
            var f = a.columns;
            if (c !== d) {
              var h = c < d ? c + 1 : c - 1,
                i = Math.min(h, d);
              for (i; i <= Math.max(h, d) && !f[i].visible; i++);
              if (!(i > Math.max(h, d))) {
                var j = f[c];
                if (j.colDef.enableColumnMoving) {
                  if (c > d) for (var k = c; k > d; k--) f[k] = f[k - 1];
                  else if (d > c) for (var l = c; l < d; l++) f[l] = f[l + 1];
                  (f[d] = j),
                    g.updateColumnCache(a),
                    a.queueGridRefresh(),
                    b(function () {
                      a.api.core.notifyDataChange(e.dataChange.COLUMN),
                        a.api.colMovable.raise.columnPositionChanged(
                          j.colDef,
                          c,
                          d
                        );
                    });
                }
              }
            }
          },
        };
        return g;
      },
    ]),
      a.directive("uiGridMoveColumns", [
        "uiGridMoveColumnService",
        function (a) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (b, c, d, e) {
                  a.initializeGrid(e.grid);
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]),
      a.directive("uiGridHeaderCell", [
        "$q",
        "gridUtil",
        "uiGridMoveColumnService",
        "$document",
        "$log",
        "uiGridConstants",
        "ScrollEvent",
        function (a, b, c, d, e, f, g) {
          return {
            priority: -10,
            require: "^uiGrid",
            compile: function () {
              return {
                post: function (a, b, e, f) {
                  if (a.col.colDef.enableColumnMoving) {
                    var i,
                      j,
                      k,
                      l,
                      n,
                      o,
                      q,
                      r,
                      h = angular.element(
                        b[0].querySelectorAll(".ui-grid-cell-contents")
                      ),
                      m = !1,
                      p = !1,
                      s = function (b) {
                        (i = a.grid.element[0].getBoundingClientRect().left),
                          a.grid.hasLeftContainer() &&
                            (i += a.grid.renderContainers.left.header[0].getBoundingClientRect()
                              .width),
                          (j =
                            b.pageX ||
                            (b.originalEvent ? b.originalEvent.pageX : 0)),
                          (k = 0),
                          (l = i + a.grid.getViewportWidth()),
                          (q = 0),
                          (r = j - i),
                          "mousedown" === b.type
                            ? (d.on("mousemove", t), d.on("mouseup", v))
                            : "touchstart" === b.type &&
                              (d.on("touchmove", t), d.on("touchend", v));
                      },
                      t = function (a) {
                        var b =
                            a.pageX ||
                            (a.originalEvent ? a.originalEvent.pageX : 0),
                          c = b - j;
                        0 !== c &&
                          ((document.onselectstart = function () {
                            return !1;
                          }),
                          (p = !0),
                          m ? m && (z(c), (j = b)) : y());
                      },
                      u = function () {
                        var a = b[0].parentElement.querySelectorAll(
                            ".borderRightColumn"
                          ),
                          c = b[0].parentElement.querySelectorAll(
                            ".borderLeftColumn"
                          ),
                          d = a.length,
                          e = c.length;
                        if (d > 0)
                          for (var f = 0; f < d; f++)
                            $(a[f]).removeClass("borderRightColumn");
                        if (e > 0)
                          for (var g = 0; g < e; g++)
                            $(c[g]).removeClass("borderLeftColumn");
                      },
                      v = function (b) {
                        if (
                          ((document.onselectstart = null),
                          n && (n.remove(), (m = !1)),
                          x(),
                          w(),
                          p)
                        ) {
                          for (
                            var d = a.grid.columns, e = 0, f = 0;
                            f < d.length &&
                            d[f].colDef.name !== a.col.colDef.name;
                            f++
                          )
                            e++;
                          var g;
                          if (k < 0) {
                            var i,
                              h = 0;
                            if (a.grid.isRTL()) {
                              for (i = e + 1; i < d.length; i++)
                                if (
                                  (angular.isUndefined(d[i].colDef.visible) ||
                                    d[i].colDef.visible === !0) &&
                                  ((h +=
                                    d[i].drawnWidth ||
                                    d[i].width ||
                                    d[i].colDef.width),
                                  h > Math.abs(k))
                                ) {
                                  c.redrawColumnAtPosition(a.grid, e, i - 1);
                                  break;
                                }
                            } else
                              for (i = e - 1; i >= 0; i--)
                                if (
                                  (angular.isUndefined(d[i].colDef.visible) ||
                                    d[i].colDef.visible === !0) &&
                                  ((h +=
                                    d[i].drawnWidth ||
                                    d[i].width ||
                                    d[i].colDef.width),
                                  h > Math.abs(k))
                                ) {
                                  c.redrawColumnAtPosition(a.grid, e, i + 1);
                                  break;
                                }
                            h < Math.abs(k) &&
                              ((g = 0),
                              a.grid.isRTL() && (g = d.length - 1),
                              c.redrawColumnAtPosition(a.grid, e, g));
                          } else if (k > 0) {
                            var l,
                              j = 0;
                            if (a.grid.isRTL()) {
                              for (l = e - 1; l > 0; l--)
                                if (
                                  (angular.isUndefined(d[l].colDef.visible) ||
                                    d[l].colDef.visible === !0) &&
                                  ((j +=
                                    d[l].drawnWidth ||
                                    d[l].width ||
                                    d[l].colDef.width),
                                  j > k)
                                ) {
                                  c.redrawColumnAtPosition(a.grid, e, l);
                                  break;
                                }
                            } else
                              for (l = e + 1; l < d.length; l++)
                                if (
                                  (angular.isUndefined(d[l].colDef.visible) ||
                                    d[l].colDef.visible === !0) &&
                                  ((j +=
                                    d[l].drawnWidth ||
                                    d[l].width ||
                                    d[l].colDef.width),
                                  j > k)
                                ) {
                                  c.redrawColumnAtPosition(a.grid, e, l - 1);
                                  break;
                                }
                            j < k &&
                              ((g = d.length - 1),
                              a.grid.isRTL() && (g = 0),
                              c.redrawColumnAtPosition(a.grid, e, g));
                          }
                          u();
                        }
                      },
                      w = function () {
                        h.on("touchstart", s), h.on("mousedown", s);
                      },
                      x = function () {
                        h.off("touchstart", s),
                          h.off("mousedown", s),
                          d.off("mousemove", t),
                          d.off("touchmove", t),
                          d.off("mouseup", v),
                          d.off("touchend", v);
                      };
                    w();
                    var y = function () {
                        (m = !0),
                          (n = b.clone()),
                          b.parent().append(n),
                          n.addClass("movingColumn");
                        var c = {};
                        c.left = b[0].offsetLeft + "px";
                        var d = a.grid.element[0].getBoundingClientRect().right,
                          e = b[0].getBoundingClientRect().right;
                        e > d &&
                          ((o = a.col.drawnWidth + (d - e)),
                          (c.width = o + "px")),
                          n.css(c);
                      },
                      z = function (c) {
                        var d = !1;
                        k <= -r && q < -r && (d = !0);
                        for (
                          var e = a.grid.columns, h = 0, j = 0;
                          j < e.length;
                          j++
                        )
                          (angular.isUndefined(e[j].colDef.visible) ||
                            e[j].colDef.visible === !0) &&
                            (h +=
                              e[j].drawnWidth ||
                              e[j].width ||
                              e[j].colDef.width);
                        var s,
                          m = n[0].getBoundingClientRect().left - 1,
                          p = n[0].getBoundingClientRect().right;
                        if (
                          ((s = m - i + c),
                          d && (s = 0),
                          (s = s < l ? s : l),
                          (m >= i || c > 0) && (p <= l || c < 0))
                        )
                          d
                            ? n.css({ visibility: "visible", left: "0px" })
                            : n.css({
                                visibility: "visible",
                                left:
                                  n[0].offsetLeft + (s < l ? c : l - m) + "px",
                              });
                        else if (h > Math.ceil(f.grid.gridWidth)) {
                          c *= 8;
                          var t = new g(
                            a.col.grid,
                            null,
                            null,
                            "uiGridHeaderCell.moveElement"
                          );
                          (t.x = { pixels: c }), t.grid.scrollContainers("", t);
                        }
                        for (var u = 0, v = 0; v < e.length; v++)
                          if (
                            angular.isUndefined(e[v].colDef.visible) ||
                            e[v].colDef.visible === !0
                          ) {
                            if (e[v].colDef.name === a.col.colDef.name) break;
                            u +=
                              e[v].drawnWidth ||
                              e[v].width ||
                              e[v].colDef.width;
                          }
                        void 0 === a.newScrollLeft
                          ? ((k += c), (q += c), (k = d ? -r : q))
                          : (k = a.newScrollLeft + s - u),
                          o < a.col.drawnWidth &&
                            ((o += Math.abs(c)), n.css({ width: o + "px" }));
                        for (
                          var w = a.grid.columns, x = [], y = [], z = 0, A = 0;
                          A < w.length;
                          A++
                        )
                          w[A].colDef.enableColumnMoving === !0 &&
                            w[A].visible === !0 &&
                            ((z =
                              w[A].drawnWidth ||
                              w[A].width ||
                              w[A].colDef.width),
                            y.push(z),
                            x.push(w[A]));
                        var C = (b[0].parentElement, b.index()),
                          D = C;
                        y[D];
                        if (k < 0) {
                          u = 0;
                          for (var F = C - 1; F >= 0; F--)
                            if (
                              (angular.isUndefined(x[F].colDef.visible) ||
                                x[F].colDef.visible === !0) &&
                              ((u +=
                                x[F].drawnWidth ||
                                x[F].width ||
                                x[F].colDef.width),
                              u > Math.abs(k))
                            ) {
                              $(b[0].parentElement.children[F]).removeClass(
                                "borderLeftColumn"
                              ),
                                $(
                                  b[0].parentElement.children[F + 2]
                                ).removeClass("borderLeftColumn"),
                                $(
                                  b[0].parentElement.children[F - 1]
                                ).removeClass("borderRightColumn"),
                                $(
                                  b[0].parentElement.children[F + 1]
                                ).removeClass("borderRightColumn"),
                                $(b[0].parentElement.children[F + 1]).addClass(
                                  "borderLeftColumn"
                                ),
                                $(b[0].parentElement.children[F]).addClass(
                                  "borderRightColumn"
                                ),
                                $(b[0].parentElement.children[0]).removeClass(
                                  "borderLeftColumn"
                                );
                              break;
                            }
                          u < Math.abs(k) &&
                            ($(b[0].parentElement.children[1]).removeClass(
                              "borderLeftColumn"
                            ),
                            $(b[0].parentElement.children[0]).addClass(
                              "borderLeftColumn"
                            ),
                            $(b[0].parentElement.children[0]).removeClass(
                              "borderRightColumn"
                            ));
                        } else if (k > 0) {
                          for (var G = 0, H = C + 1; H < x.length; H++)
                            if (
                              (angular.isUndefined(x[H].colDef.visible) ||
                                x[H].colDef.visible === !0) &&
                              ((G +=
                                x[H].drawnWidth ||
                                x[H].width ||
                                x[H].colDef.width),
                              G > k)
                            ) {
                              $(b[0].parentElement.children[H]).removeClass(
                                "borderRightColumn"
                              ),
                                $(
                                  b[0].parentElement.children[H - 2]
                                ).removeClass("borderRightColumn"),
                                $(
                                  b[0].parentElement.children[H + 1]
                                ).removeClass("borderLeftColumn"),
                                $(
                                  b[0].parentElement.children[H - 1]
                                ).removeClass("borderLeftColumn"),
                                $(b[0].parentElement.children[H - 1]).addClass(
                                  "borderRightColumn"
                                ),
                                $(b[0].parentElement.children[H]).addClass(
                                  "borderLeftColumn"
                                );
                              break;
                            }
                          G < k &&
                            $(b[0].parentElement.children[x - 2]).removeClass(
                              "borderLeftColumn"
                            );
                        }
                      };
                    a.$on("$destroy", x);
                  }
                },
              };
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.pagination", ["ng", "ui.grid"]);
    a.service("uiGridPaginationService", [
      "gridUtil",
      function (a) {
        var b = {
          initializeGrid: function (a) {
            b.defaultGridOptions(a.options);
            var c = {
              events: { pagination: { paginationChanged: function (a, b) {} } },
              methods: {
                pagination: {
                  getPage: function () {
                    return a.options.enablePagination
                      ? a.options.paginationCurrentPage
                      : null;
                  },
                  getFirstRowIndex: function () {
                    return a.options.useCustomPagination
                      ? a.options.paginationPageSizes.reduce(function (
                          b,
                          c,
                          d
                        ) {
                          return d < a.options.paginationCurrentPage - 1
                            ? b + c
                            : b;
                        },
                        0)
                      : (a.options.paginationCurrentPage - 1) *
                          a.options.paginationPageSize;
                  },
                  getLastRowIndex: function () {
                    return a.options.useCustomPagination
                      ? c.methods.pagination.getFirstRowIndex() +
                          a.options.paginationPageSizes[
                            a.options.paginationCurrentPage - 1
                          ]
                      : Math.min(
                          a.options.paginationCurrentPage *
                            a.options.paginationPageSize,
                          a.options.totalItems
                        );
                  },
                  getTotalPages: function () {
                    return a.options.enablePagination
                      ? a.options.useCustomPagination
                        ? a.options.paginationPageSizes.length
                        : 0 === a.options.totalItems
                        ? 1
                        : Math.ceil(
                            a.options.totalItems / a.options.paginationPageSize
                          )
                      : null;
                  },
                  nextPage: function () {
                    a.options.enablePagination &&
                      (a.options.totalItems > 0
                        ? (a.options.paginationCurrentPage = Math.min(
                            a.options.paginationCurrentPage + 1,
                            c.methods.pagination.getTotalPages()
                          ))
                        : a.options.paginationCurrentPage++);
                  },
                  previousPage: function () {
                    a.options.enablePagination &&
                      (a.options.paginationCurrentPage = Math.max(
                        a.options.paginationCurrentPage - 1,
                        1
                      ));
                  },
                  seek: function (b) {
                    if (a.options.enablePagination) {
                      if (!angular.isNumber(b) || b < 1)
                        throw "Invalid page number: " + b;
                      a.options.paginationCurrentPage = Math.min(
                        b,
                        c.methods.pagination.getTotalPages()
                      );
                    }
                  },
                },
              },
            };
            a.api.registerEventsFromObject(c.events),
              a.api.registerMethodsFromObject(c.methods);
            var d = function (b) {
              if (
                a.options.useExternalPagination ||
                !a.options.enablePagination
              )
                return b;
              var d = parseInt(a.options.paginationPageSize, 10),
                e = parseInt(a.options.paginationCurrentPage, 10),
                f = b.filter(function (a) {
                  return a.visible;
                });
              a.options.totalItems = f.length;
              var g = c.methods.pagination.getFirstRowIndex(),
                h = c.methods.pagination.getLastRowIndex();
              return (
                g > f.length &&
                  ((e = a.options.paginationCurrentPage = 1),
                  (g = (e - 1) * d)),
                f.slice(g, h)
              );
            };
            a.registerRowsProcessor(d, 900);
          },
          defaultGridOptions: function (b) {
            (b.enablePagination = b.enablePagination !== !1),
              (b.enablePaginationControls = b.enablePaginationControls !== !1),
              (b.useExternalPagination = b.useExternalPagination === !0),
              (b.useCustomPagination = b.useCustomPagination === !0),
              a.isNullOrUndefined(b.totalItems) && (b.totalItems = 0),
              a.isNullOrUndefined(b.paginationPageSizes) &&
                (b.paginationPageSizes = [250, 500, 1e3]),
              a.isNullOrUndefined(b.paginationPageSize) &&
                (b.paginationPageSizes.length > 0
                  ? (b.paginationPageSize = b.paginationPageSizes[0])
                  : (b.paginationPageSize = 0)),
              a.isNullOrUndefined(b.paginationCurrentPage) &&
                (b.paginationCurrentPage = 1),
              a.isNullOrUndefined(b.paginationTemplate) &&
                (b.paginationTemplate = "ui-grid/pagination");
          },
          onPaginationChanged: function (a, b, c) {
            a.api.pagination.raise.paginationChanged(b, c),
              a.options.useExternalPagination || a.queueGridRefresh();
          },
        };
        return b;
      },
    ]),
      a.directive("uiGridPagination", [
        "gridUtil",
        "uiGridPaginationService",
        function (a, b) {
          return {
            priority: -200,
            scope: !1,
            require: "uiGrid",
            link: {
              pre: function (c, d, e, f) {
                b.initializeGrid(f.grid),
                  a
                    .getTemplate(f.grid.options.paginationTemplate)
                    .then(function (a) {
                      var b = angular.element(a);
                      d.append(b), f.innerCompile(b);
                    });
              },
            },
          };
        },
      ]),
      a.directive("uiGridPager", [
        "uiGridPaginationService",
        "uiGridConstants",
        "gridUtil",
        "i18nService",
        function (a, b, c, d) {
          return {
            priority: -200,
            scope: !0,
            require: "^uiGrid",
            link: function (e, f, g, h) {
              var i = ".ui-grid-pager-control-input";
              (e.aria = d.getSafeText("pagination.aria")),
                (e.paginationApi = h.grid.api.pagination),
                (e.sizesLabel = d.getSafeText("pagination.sizes")),
                (e.totalItemsLabel = d.getSafeText("pagination.totalItems")),
                (e.paginationOf = d.getSafeText("pagination.of")),
                (e.paginationThrough = d.getSafeText("pagination.through"));
              var j = h.grid.options;
              h.grid.renderContainers.body.registerViewportAdjuster(function (
                a
              ) {
                return (a.height = a.height - c.elementHeight(f, "padding")), a;
              });
              var k = h.grid.registerDataChangeCallback(
                function (a) {
                  a.options.useExternalPagination ||
                    (a.options.totalItems = a.rows.length);
                },
                [b.dataChange.ROW]
              );
              e.$on("$destroy", k);
              var l = e.$watch(
                "grid.options.paginationCurrentPage + grid.options.paginationPageSize",
                function (b, c) {
                  if (b !== c && void 0 !== c)
                    return !angular.isNumber(j.paginationCurrentPage) ||
                      j.paginationCurrentPage < 1
                      ? void (j.paginationCurrentPage = 1)
                      : j.totalItems > 0 &&
                        j.paginationCurrentPage >
                          e.paginationApi.getTotalPages()
                      ? void (j.paginationCurrentPage = e.paginationApi.getTotalPages())
                      : void a.onPaginationChanged(
                          e.grid,
                          j.paginationCurrentPage,
                          j.paginationPageSize
                        );
                }
              );
              e.$on("$destroy", function () {
                l();
              }),
                (e.cantPageForward = function () {
                  return e.paginationApi.getTotalPages()
                    ? e.cantPageToLast()
                    : j.data.length < 1;
                }),
                (e.cantPageToLast = function () {
                  var a = e.paginationApi.getTotalPages();
                  return !a || j.paginationCurrentPage >= a;
                }),
                (e.cantPageBackward = function () {
                  return j.paginationCurrentPage <= 1;
                });
              var m = function (a) {
                a && c.focus.bySelector(f, i);
              };
              (e.pageFirstPageClick = function () {
                e.paginationApi.seek(1), m(e.cantPageBackward());
              }),
                (e.pagePreviousPageClick = function () {
                  e.paginationApi.previousPage(), m(e.cantPageBackward());
                }),
                (e.pageNextPageClick = function () {
                  e.paginationApi.nextPage(), m(e.cantPageForward());
                }),
                (e.pageLastPageClick = function () {
                  e.paginationApi.seek(e.paginationApi.getTotalPages()),
                    m(e.cantPageToLast());
                });
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.pinning", ["ui.grid"]);
    a.constant("uiGridPinningConstants", {
      container: { LEFT: "left", RIGHT: "right", NONE: "" },
    }),
      a.service("uiGridPinningService", [
        "gridUtil",
        "GridRenderContainer",
        "i18nService",
        "uiGridPinningConstants",
        function (a, b, c, d) {
          var e = {
            initializeGrid: function (a) {
              e.defaultGridOptions(a.options),
                a.registerColumnBuilder(e.pinningColumnBuilder);
              var b = {
                events: { pinning: { columnPinned: function (a, b) {} } },
                methods: {
                  pinning: {
                    pinColumn: function (b, c) {
                      e.pinColumn(a, b, c);
                    },
                  },
                },
              };
              a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods);
            },
            defaultGridOptions: function (a) {
              a.enablePinning = a.enablePinning !== !1;
            },
            pinningColumnBuilder: function (b, f, g) {
              if (
                ((b.enablePinning =
                  void 0 === b.enablePinning
                    ? g.enablePinning
                    : b.enablePinning),
                b.pinnedLeft
                  ? ((f.renderContainer = "left"), f.grid.createLeftContainer())
                  : b.pinnedRight &&
                    ((f.renderContainer = "right"),
                    f.grid.createRightContainer()),
                b.enablePinning)
              ) {
                var h = {
                    name: "ui.grid.pinning.pinLeft",
                    title: c.get().pinning.pinLeft,
                    icon: "ui-grid-icon-left-open",
                    shown: function () {
                      return (
                        "undefined" ==
                          typeof this.context.col.renderContainer ||
                        !this.context.col.renderContainer ||
                        "left" !== this.context.col.renderContainer
                      );
                    },
                    action: function () {
                      e.pinColumn(
                        this.context.col.grid,
                        this.context.col,
                        d.container.LEFT
                      );
                    },
                  },
                  i = {
                    name: "ui.grid.pinning.pinRight",
                    title: c.get().pinning.pinRight,
                    icon: "ui-grid-icon-right-open",
                    shown: function () {
                      return (
                        "undefined" ==
                          typeof this.context.col.renderContainer ||
                        !this.context.col.renderContainer ||
                        "right" !== this.context.col.renderContainer
                      );
                    },
                    action: function () {
                      e.pinColumn(
                        this.context.col.grid,
                        this.context.col,
                        d.container.RIGHT
                      );
                    },
                  },
                  j = {
                    name: "ui.grid.pinning.unpin",
                    title: c.get().pinning.unpin,
                    icon: "ui-grid-icon-cancel",
                    shown: function () {
                      return (
                        "undefined" !=
                          typeof this.context.col.renderContainer &&
                        null !== this.context.col.renderContainer &&
                        "body" !== this.context.col.renderContainer
                      );
                    },
                    action: function () {
                      e.pinColumn(
                        this.context.col.grid,
                        this.context.col,
                        d.container.NONE
                      );
                    },
                  };
                a.arrayContainsObjectWithProperty(
                  f.menuItems,
                  "name",
                  "ui.grid.pinning.pinLeft"
                ) || f.menuItems.push(h),
                  a.arrayContainsObjectWithProperty(
                    f.menuItems,
                    "name",
                    "ui.grid.pinning.pinRight"
                  ) || f.menuItems.push(i),
                  a.arrayContainsObjectWithProperty(
                    f.menuItems,
                    "name",
                    "ui.grid.pinning.unpin"
                  ) || f.menuItems.push(j);
              }
            },
            pinColumn: function (a, b, c) {
              c === d.container.NONE
                ? ((b.renderContainer = null),
                  (b.colDef.pinnedLeft = b.colDef.pinnedRight = !1))
                : ((b.renderContainer = c),
                  c === d.container.LEFT
                    ? a.createLeftContainer()
                    : c === d.container.RIGHT && a.createRightContainer()),
                a.refresh().then(function () {
                  a.api.pinning.raise.columnPinned(b.colDef, c);
                });
            },
          };
          return e;
        },
      ]),
      a.directive("uiGridPinning", [
        "gridUtil",
        "uiGridPinningService",
        function (a, b) {
          return {
            require: "uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (a, c, d, e) {
                  b.initializeGrid(e.grid);
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.resizeColumns", ["ui.grid"]);
    a.service("uiGridResizeColumnsService", [
      "gridUtil",
      "$q",
      "$timeout",
      function (a, b, c) {
        var d = {
          defaultGridOptions: function (a) {
            (a.enableColumnResizing = a.enableColumnResizing !== !1),
              a.enableColumnResize === !1 && (a.enableColumnResizing = !1);
          },
          colResizerColumnBuilder: function (a, c, d) {
            var e = [];
            return (
              (a.enableColumnResizing =
                void 0 === a.enableColumnResizing
                  ? d.enableColumnResizing
                  : a.enableColumnResizing),
              a.enableColumnResize === !1 && (a.enableColumnResizing = !1),
              b.all(e)
            );
          },
          registerPublicApi: function (a) {
            var b = {
              events: {
                colResizable: { columnSizeChanged: function (a, b) {} },
              },
            };
            a.api.registerEventsFromObject(b.events);
          },
          fireColumnSizeChanged: function (b, d, e) {
            c(function () {
              b.api.colResizable
                ? b.api.colResizable.raise.columnSizeChanged(d, e)
                : a.logError(
                    "The resizeable api is not registered, this may indicate that you've included the module but not added the 'ui-grid-resize-columns' directive to your grid definition.  Cannot raise any events."
                  );
            });
          },
          findTargetCol: function (a, b, c) {
            var d = a.getRenderContainer();
            if ("left" === b) {
              var e = d.visibleColumnCache.indexOf(a);
              return d.visibleColumnCache[e - 1 * c];
            }
            return a;
          },
        };
        return d;
      },
    ]),
      a.directive("uiGridResizeColumns", [
        "gridUtil",
        "uiGridResizeColumnsService",
        function (a, b) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (a, c, d, e) {
                  b.defaultGridOptions(e.grid.options),
                    e.grid.registerColumnBuilder(b.colResizerColumnBuilder),
                    b.registerPublicApi(e.grid);
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]),
      a.directive("uiGridHeaderCell", [
        "gridUtil",
        "$templateCache",
        "$compile",
        "$q",
        "uiGridResizeColumnsService",
        "uiGridConstants",
        "$timeout",
        function (a, b, c, d, e, f, g) {
          return {
            priority: -10,
            require: "^uiGrid",
            compile: function () {
              return {
                post: function (a, d, h, i) {
                  var j = i.grid;
                  if (j.options.enableColumnResizing) {
                    var k = b.get("ui-grid/columnResizer"),
                      l = 1;
                    j.isRTL() && ((a.position = "left"), (l = -1));
                    var m = function () {
                      for (
                        var b = d[0].getElementsByClassName(
                            "ui-grid-column-resizer"
                          ),
                          f = 0;
                        f < b.length;
                        f++
                      )
                        angular.element(b[f]).remove();
                      var g = e.findTargetCol(a.col, "left", l),
                        h = a.col.getRenderContainer();
                      if (
                        g &&
                        0 !== h.visibleColumnCache.indexOf(a.col) &&
                        g.colDef.enableColumnResizing !== !1
                      ) {
                        var i = angular.element(k).clone();
                        i.attr("position", "left"), d.prepend(i), c(i)(a);
                      }
                      if (a.col.colDef.enableColumnResizing !== !1) {
                        var j = angular.element(k).clone();
                        j.attr("position", "right"), d.append(j), c(j)(a);
                      }
                    };
                    m();
                    var n = function () {
                        g(m);
                      },
                      o = j.registerDataChangeCallback(n, [
                        f.dataChange.COLUMN,
                      ]);
                    a.$on("$destroy", o);
                  }
                },
              };
            },
          };
        },
      ]),
      a.directive("uiGridColumnResizer", [
        "$document",
        "gridUtil",
        "uiGridConstants",
        "uiGridResizeColumnsService",
        function (a, b, c, d) {
          var e = angular.element('<div class="ui-grid-resize-overlay"></div>'),
            f = {
              priority: 0,
              scope: { col: "=", position: "@", renderIndex: "=" },
              require: "?^uiGrid",
              link: function (f, g, h, i) {
                function n(a) {
                  i.grid.refreshCanvas(!0).then(function () {
                    i.grid.queueGridRefresh();
                  });
                }
                function o(a, b) {
                  var c = b;
                  return (
                    a.minWidth && c < a.minWidth
                      ? (c = a.minWidth)
                      : a.maxWidth && c > a.maxWidth && (c = a.maxWidth),
                    c
                  );
                }
                function p(a, b) {
                  a.originalEvent && (a = a.originalEvent),
                    a.preventDefault(),
                    (k =
                      (a.targetTouches ? a.targetTouches[0] : a).clientX - l),
                    k < 0
                      ? (k = 0)
                      : k > i.grid.gridWidth && (k = i.grid.gridWidth);
                  var g = d.findTargetCol(f.col, f.position, m);
                  if (g.colDef.enableColumnResizing !== !1) {
                    i.grid.element.hasClass("column-resizing") ||
                      i.grid.element.addClass("column-resizing");
                    var h = k - j,
                      n = parseInt(g.drawnWidth + h * m, 10);
                    (k += (o(g, n) - n) * m),
                      e.css({ left: k + "px" }),
                      i.fireEvent(c.events.ITEM_DRAGGING);
                  }
                }
                function q(a, b) {
                  a.originalEvent && (a = a.originalEvent),
                    a.preventDefault(),
                    i.grid.element.removeClass("column-resizing"),
                    e.remove(),
                    (k =
                      (a.changedTouches ? a.changedTouches[0] : a).clientX - l);
                  var c = k - j;
                  if (0 === c) return t(), void s();
                  var g = d.findTargetCol(f.col, f.position, m);
                  if (g.colDef.enableColumnResizing !== !1) {
                    var h = parseInt(g.drawnWidth + c * m, 10);
                    (g.width = o(g, h)),
                      (g.hasCustomWidth = !0),
                      n(c),
                      d.fireColumnSizeChanged(i.grid, g.colDef, c),
                      t(),
                      s();
                  }
                }
                var j = 0,
                  k = 0,
                  l = 0,
                  m = 1;
                i.grid.isRTL() && ((f.position = "left"), (m = -1)),
                  "left" === f.position
                    ? g.addClass("left")
                    : "right" === f.position && g.addClass("right");
                var r = function (b, c) {
                    b.originalEvent && (b = b.originalEvent),
                      b.stopPropagation(),
                      (l = i.grid.element[0].getBoundingClientRect().left),
                      (j =
                        (b.targetTouches ? b.targetTouches[0] : b).clientX - l),
                      i.grid.element.append(e),
                      e.css({ left: j }),
                      "touchstart" === b.type
                        ? (a.on("touchend", q),
                          a.on("touchmove", p),
                          g.off("mousedown", r))
                        : (a.on("mouseup", q),
                          a.on("mousemove", p),
                          g.off("touchstart", r));
                  },
                  s = function () {
                    g.on("mousedown", r), g.on("touchstart", r);
                  },
                  t = function () {
                    a.off("mouseup", q),
                      a.off("touchend", q),
                      a.off("mousemove", p),
                      a.off("touchmove", p),
                      g.off("mousedown", r),
                      g.off("touchstart", r);
                  };
                s();
                var u = function (a, e) {
                  a.stopPropagation();
                  var h = d.findTargetCol(f.col, f.position, m);
                  if (h.colDef.enableColumnResizing !== !1) {
                    var j = 0,
                      k = 0,
                      l = b.closestElm(g, ".ui-grid-render-container"),
                      p = l.querySelectorAll(
                        "." +
                          c.COL_CLASS_PREFIX +
                          h.uid +
                          " .ui-grid-cell-contents"
                      );
                    Array.prototype.forEach.call(p, function (a) {
                      var c;
                      angular
                        .element(a)
                        .parent()
                        .hasClass("ui-grid-header-cell") &&
                        (c = angular
                          .element(a)
                          .parent()[0]
                          .querySelectorAll(".ui-grid-column-menu-button")),
                        b.fakeElement(a, {}, function (a) {
                          var d = angular.element(a);
                          d.attr("style", "float: left");
                          var e = b.elementWidth(d);
                          if (c) {
                            var f = b.elementWidth(c);
                            e += f;
                          }
                          e > j && ((j = e), (k = j - e));
                        });
                    }),
                      (h.width = o(h, j)),
                      (h.hasCustomWidth = !0),
                      n(k),
                      d.fireColumnSizeChanged(i.grid, h.colDef, k);
                  }
                };
                g.on("dblclick", u),
                  g.on("$destroy", function () {
                    g.off("dblclick", u), t();
                  });
              },
            };
          return f;
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.rowEdit", [
      "ui.grid",
      "ui.grid.edit",
      "ui.grid.cellNav",
    ]);
    a.constant("uiGridRowEditConstants", {}),
      a.service("uiGridRowEditService", [
        "$interval",
        "$q",
        "uiGridConstants",
        "uiGridRowEditConstants",
        "gridUtil",
        function (a, b, c, d, e) {
          var f = {
            initializeGrid: function (a, b) {
              b.rowEdit = {};
              var c = {
                events: { rowEdit: { saveRow: function (a) {} } },
                methods: {
                  rowEdit: {
                    setSavePromise: function (a, c) {
                      f.setSavePromise(b, a, c);
                    },
                    getDirtyRows: function () {
                      return b.rowEdit.dirtyRows ? b.rowEdit.dirtyRows : [];
                    },
                    getErrorRows: function () {
                      return b.rowEdit.errorRows ? b.rowEdit.errorRows : [];
                    },
                    flushDirtyRows: function () {
                      return f.flushDirtyRows(b);
                    },
                    setRowsDirty: function (a) {
                      f.setRowsDirty(b, a);
                    },
                    setRowsClean: function (a) {
                      f.setRowsClean(b, a);
                    },
                  },
                },
              };
              b.api.registerEventsFromObject(c.events),
                b.api.registerMethodsFromObject(c.methods),
                b.api.core.on.renderingComplete(a, function (c) {
                  b.api.edit.on.afterCellEdit(a, f.endEditCell),
                    b.api.edit.on.beginCellEdit(a, f.beginEditCell),
                    b.api.edit.on.cancelCellEdit(a, f.cancelEditCell),
                    b.api.cellNav && b.api.cellNav.on.navigate(a, f.navigate);
                });
            },
            defaultGridOptions: function (a) {},
            saveRow: function (a, b) {
              var c = this;
              return function () {
                if (((b.isSaving = !0), b.rowEditSavePromise))
                  return b.rowEditSavePromise;
                var d = a.api.rowEdit.raise.saveRow(b.entity);
                return (
                  b.rowEditSavePromise
                    ? b.rowEditSavePromise.then(
                        c.processSuccessPromise(a, b),
                        c.processErrorPromise(a, b)
                      )
                    : e.logError(
                        "A promise was not returned when saveRow event was raised, either nobody is listening to event, or event handler did not return a promise"
                      ),
                  d
                );
              };
            },
            setSavePromise: function (a, b, c) {
              var d = a.getRow(b);
              d.rowEditSavePromise = c;
            },
            processSuccessPromise: function (a, b) {
              var c = this;
              return function () {
                delete b.isSaving,
                  delete b.isDirty,
                  delete b.isError,
                  delete b.rowEditSaveTimer,
                  delete b.rowEditSavePromise,
                  c.removeRow(a.rowEdit.errorRows, b),
                  c.removeRow(a.rowEdit.dirtyRows, b);
              };
            },
            processErrorPromise: function (a, b) {
              return function () {
                delete b.isSaving,
                  delete b.rowEditSaveTimer,
                  delete b.rowEditSavePromise,
                  (b.isError = !0),
                  a.rowEdit.errorRows || (a.rowEdit.errorRows = []),
                  f.isRowPresent(a.rowEdit.errorRows, b) ||
                    a.rowEdit.errorRows.push(b);
              };
            },
            removeRow: function (a, b) {
              "undefined" != typeof a &&
                null !== a &&
                a.forEach(function (c, d) {
                  c.uid === b.uid && a.splice(d, 1);
                });
            },
            isRowPresent: function (a, b) {
              var c = !1;
              return (
                a.forEach(function (a, d) {
                  a.uid === b.uid && (c = !0);
                }),
                c
              );
            },
            flushDirtyRows: function (a) {
              var c = [];
              return (
                a.api.rowEdit.getDirtyRows().forEach(function (b) {
                  f.saveRow(a, b)(), c.push(b.rowEditSavePromise);
                }),
                b.all(c)
              );
            },
            endEditCell: function (a, b, c, d) {
              var g = this.grid,
                h = g.getRow(a);
              return h
                ? void (
                    (c !== d || h.isDirty) &&
                    (g.rowEdit.dirtyRows || (g.rowEdit.dirtyRows = []),
                    h.isDirty ||
                      ((h.isDirty = !0), g.rowEdit.dirtyRows.push(h)),
                    delete h.isError,
                    f.considerSetTimer(g, h))
                  )
                : void e.logError(
                    "Unable to find rowEntity in grid data, dirty flag cannot be set"
                  );
            },
            beginEditCell: function (a, b) {
              var c = this.grid,
                d = c.getRow(a);
              return d
                ? void f.cancelTimer(c, d)
                : void e.logError(
                    "Unable to find rowEntity in grid data, timer cannot be cancelled"
                  );
            },
            cancelEditCell: function (a, b) {
              var c = this.grid,
                d = c.getRow(a);
              return d
                ? void f.considerSetTimer(c, d)
                : void e.logError(
                    "Unable to find rowEntity in grid data, timer cannot be set"
                  );
            },
            navigate: function (a, b) {
              var c = this.grid;
              a.row.rowEditSaveTimer && f.cancelTimer(c, a.row),
                b && b.row && b.row !== a.row && f.considerSetTimer(c, b.row);
            },
            considerSetTimer: function (b, c) {
              if (
                (f.cancelTimer(b, c),
                c.isDirty &&
                  !c.isSaving &&
                  b.options.rowEditWaitInterval !== -1)
              ) {
                var d = b.options.rowEditWaitInterval
                  ? b.options.rowEditWaitInterval
                  : 2e3;
                c.rowEditSaveTimer = a(f.saveRow(b, c), d, 1);
              }
            },
            cancelTimer: function (b, c) {
              c.rowEditSaveTimer &&
                !c.isSaving &&
                (a.cancel(c.rowEditSaveTimer), delete c.rowEditSaveTimer);
            },
            setRowsDirty: function (a, b) {
              var c;
              b.forEach(function (b, d) {
                (c = a.getRow(b)),
                  c
                    ? (a.rowEdit.dirtyRows || (a.rowEdit.dirtyRows = []),
                      c.isDirty ||
                        ((c.isDirty = !0), a.rowEdit.dirtyRows.push(c)),
                      delete c.isError,
                      f.considerSetTimer(a, c))
                    : e.logError(
                        "requested row not found in rowEdit.setRowsDirty, row was: " +
                          b
                      );
              });
            },
            setRowsClean: function (a, b) {
              var c;
              b.forEach(function (b, d) {
                (c = a.getRow(b)),
                  c
                    ? (delete c.isDirty,
                      f.removeRow(a.rowEdit.dirtyRows, c),
                      f.cancelTimer(a, c),
                      delete c.isError,
                      f.removeRow(a.rowEdit.errorRows, c))
                    : e.logError(
                        "requested row not found in rowEdit.setRowsClean, row was: " +
                          b
                      );
              });
            },
          };
          return f;
        },
      ]),
      a.directive("uiGridRowEdit", [
        "gridUtil",
        "uiGridRowEditService",
        "uiGridEditConstants",
        function (a, b, c) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (a, c, d, e) {
                  b.initializeGrid(a, e.grid);
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]),
      a.directive("uiGridViewport", [
        "$compile",
        "uiGridConstants",
        "gridUtil",
        "$parse",
        function (a, b, c, d) {
          return {
            priority: -200,
            scope: !1,
            compile: function (a, b) {
              var c = angular.element(a.children().children()[0]),
                d = c.attr("ng-class"),
                e = "";
              return (
                (e = d
                  ? d.slice(0, -1) +
                    ", 'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}"
                  : "{'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}"),
                c.attr("ng-class", e),
                {
                  pre: function (a, b, c, d) {},
                  post: function (a, b, c, d) {},
                }
              );
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.saveState", [
      "ui.grid",
      "ui.grid.selection",
      "ui.grid.cellNav",
      "ui.grid.grouping",
      "ui.grid.pinning",
      "ui.grid.treeView",
    ]);
    a.constant("uiGridSaveStateConstants", { featureName: "saveState" }),
      a.service("uiGridSaveStateService", [
        "$q",
        "uiGridSaveStateConstants",
        "gridUtil",
        "$compile",
        "$interval",
        "uiGridConstants",
        function (a, b, c, d, e, f) {
          var g = {
            initializeGrid: function (a) {
              (a.saveState = {}), this.defaultGridOptions(a.options);
              var b = {
                events: { saveState: {} },
                methods: {
                  saveState: {
                    save: function () {
                      return g.save(a);
                    },
                    restore: function (b, c) {
                      g.restore(a, b, c);
                    },
                  },
                },
              };
              a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods);
            },
            defaultGridOptions: function (a) {
              (a.saveWidths = a.saveWidths !== !1),
                (a.saveOrder = a.saveOrder !== !1),
                (a.saveScroll = a.saveScroll === !0),
                (a.saveFocus = a.saveScroll !== !0 && a.saveFocus !== !1),
                (a.saveVisible = a.saveVisible !== !1),
                (a.saveSort = a.saveSort !== !1),
                (a.saveFilter = a.saveFilter !== !1),
                (a.saveSelection = a.saveSelection !== !1),
                (a.saveGrouping = a.saveGrouping !== !1),
                (a.saveGroupingExpandedStates =
                  a.saveGroupingExpandedStates === !0),
                (a.savePinning = a.savePinning !== !1),
                (a.saveTreeView = a.saveTreeView !== !1);
            },
            save: function (a) {
              var b = {};
              return (
                (b.columns = g.saveColumns(a)),
                (b.scrollFocus = g.saveScrollFocus(a)),
                (b.selection = g.saveSelection(a)),
                (b.grouping = g.saveGrouping(a)),
                (b.treeView = g.saveTreeView(a)),
                (b.pagination = g.savePagination(a)),
                b
              );
            },
            restore: function (a, b, c) {
              c.columns && g.restoreColumns(a, c.columns),
                c.scrollFocus && g.restoreScrollFocus(a, b, c.scrollFocus),
                c.selection && g.restoreSelection(a, c.selection),
                c.grouping && g.restoreGrouping(a, c.grouping),
                c.treeView && g.restoreTreeView(a, c.treeView),
                c.pagination && g.restorePagination(a, c.pagination),
                a.refresh();
            },
            saveColumns: function (a) {
              var b = [];
              return (
                a.getOnlyDataColumns().forEach(function (c) {
                  var d = {};
                  (d.name = c.name),
                    a.options.saveVisible && (d.visible = c.visible),
                    a.options.saveWidths && (d.width = c.width),
                    a.options.saveSort && (d.sort = angular.copy(c.sort)),
                    a.options.saveFilter &&
                      ((d.filters = []),
                      c.filters.forEach(function (a) {
                        var b = {};
                        angular.forEach(a, function (a, c) {
                          "condition" !== c &&
                            "$$hashKey" !== c &&
                            "placeholder" !== c &&
                            (b[c] = a);
                        }),
                          d.filters.push(b);
                      })),
                    a.api.pinning &&
                      a.options.savePinning &&
                      (d.pinned = c.renderContainer ? c.renderContainer : ""),
                    b.push(d);
                }),
                b
              );
            },
            saveScrollFocus: function (a) {
              if (!a.api.cellNav) return {};
              var b = {};
              if (a.options.saveFocus) {
                b.focus = !0;
                var c = a.api.cellNav.getFocusedCell();
                null !== c &&
                  (null !== c.col && (b.colName = c.col.colDef.name),
                  null !== c.row && (b.rowVal = g.getRowVal(a, c.row)));
              }
              return (
                (a.options.saveScroll ||
                  (a.options.saveFocus && !b.colName && !b.rowVal)) &&
                  ((b.focus = !1),
                  a.renderContainers.body.prevRowScrollIndex &&
                    (b.rowVal = g.getRowVal(
                      a,
                      a.renderContainers.body.visibleRowCache[
                        a.renderContainers.body.prevRowScrollIndex
                      ]
                    )),
                  a.renderContainers.body.prevColScrollIndex &&
                    (b.colName =
                      a.renderContainers.body.visibleColumnCache[
                        a.renderContainers.body.prevColScrollIndex
                      ].name)),
                b
              );
            },
            saveSelection: function (a) {
              if (!a.api.selection || !a.options.saveSelection) return [];
              var b = a.api.selection.getSelectedGridRows().map(function (b) {
                return g.getRowVal(a, b);
              });
              return b;
            },
            saveGrouping: function (a) {
              return a.api.grouping && a.options.saveGrouping
                ? a.api.grouping.getGrouping(
                    a.options.saveGroupingExpandedStates
                  )
                : {};
            },
            savePagination: function (a) {
              return a.api.pagination && a.options.paginationPageSize
                ? {
                    paginationCurrentPage: a.options.paginationCurrentPage,
                    paginationPageSize: a.options.paginationPageSize,
                  }
                : {};
            },
            saveTreeView: function (a) {
              return a.api.treeView && a.options.saveTreeView
                ? a.api.treeView.getTreeView()
                : {};
            },
            getRowVal: function (a, b) {
              if (!b) return null;
              var c = {};
              return (
                a.options.saveRowIdentity
                  ? ((c.identity = !0),
                    (c.row = a.options.saveRowIdentity(b.entity)))
                  : ((c.identity = !1),
                    (c.row = a.renderContainers.body.visibleRowCache.indexOf(
                      b
                    ))),
                c
              );
            },
            restoreColumns: function (a, b) {
              var c = !1;
              b.forEach(function (b, d) {
                var e = a.getColumn(b.name);
                if (e && !a.isRowHeaderColumn(e)) {
                  !a.options.saveVisible ||
                    (e.visible === b.visible &&
                      e.colDef.visible === b.visible) ||
                    ((e.visible = b.visible),
                    (e.colDef.visible = b.visible),
                    a.api.core.raise.columnVisibilityChanged(e)),
                    a.options.saveWidths &&
                      e.width !== b.width &&
                      ((e.width = b.width), (e.hasCustomWidth = !0)),
                    !a.options.saveSort ||
                      angular.equals(e.sort, b.sort) ||
                      (void 0 === e.sort && angular.isEmpty(b.sort)) ||
                      ((e.sort = angular.copy(b.sort)), (c = !0)),
                    a.options.saveFilter &&
                      !angular.equals(e.filters, b.filters) &&
                      (b.filters.forEach(function (a, b) {
                        angular.extend(e.filters[b], a),
                          ("undefined" != typeof a.term && null !== a.term) ||
                            delete e.filters[b].term;
                      }),
                      a.api.core.raise.filterChanged()),
                    a.api.pinning &&
                      a.options.savePinning &&
                      e.renderContainer !== b.pinned &&
                      a.api.pinning.pinColumn(e, b.pinned);
                  var f = a.getOnlyDataColumns().indexOf(e);
                  if (f !== -1 && a.options.saveOrder && f !== d) {
                    var g = a.columns.splice(
                      f + a.rowHeaderColumns.length,
                      1
                    )[0];
                    a.columns.splice(d + a.rowHeaderColumns.length, 0, g);
                  }
                }
              }),
                c && a.api.core.raise.sortChanged(a, a.getColumnSorting());
            },
            restoreScrollFocus: function (a, b, c) {
              if (a.api.cellNav) {
                var d, e;
                if (c.colName) {
                  var f = a.options.columnDefs.filter(function (a) {
                    return a.name === c.colName;
                  });
                  f.length > 0 && (d = f[0]);
                }
                c.rowVal &&
                  c.rowVal.row &&
                  (e = c.rowVal.identity
                    ? g.findRowByIdentity(a, c.rowVal)
                    : a.renderContainers.body.visibleRowCache[c.rowVal.row]);
                var h = e && e.entity ? e.entity : null;
                (d || h) &&
                  (c.focus
                    ? a.api.cellNav.scrollToFocus(h, d)
                    : a.scrollTo(h, d));
              }
            },
            restoreSelection: function (a, b) {
              a.api.selection &&
                (a.api.selection.clearSelectedRows(),
                b.forEach(function (b) {
                  if (b.identity) {
                    var c = g.findRowByIdentity(a, b);
                    c && a.api.selection.selectRow(c.entity);
                  } else a.api.selection.selectRowByVisibleIndex(b.row);
                }));
            },
            restoreGrouping: function (a, b) {
              a.api.grouping &&
                "undefined" != typeof b &&
                null !== b &&
                !angular.equals(b, {}) &&
                a.api.grouping.setGrouping(b);
            },
            restoreTreeView: function (a, b) {
              a.api.treeView &&
                "undefined" != typeof b &&
                null !== b &&
                !angular.equals(b, {}) &&
                a.api.treeView.setTreeView(b);
            },
            restorePagination: function (a, b) {
              a.api.pagination &&
                a.options.paginationPageSize &&
                ((a.options.paginationCurrentPage = b.paginationCurrentPage),
                (a.options.paginationPageSize = b.paginationPageSize));
            },
            findRowByIdentity: function (a, b) {
              if (!a.options.saveRowIdentity) return null;
              var c = a.rows.filter(function (c) {
                return a.options.saveRowIdentity(c.entity) === b.row;
              });
              return c.length > 0 ? c[0] : null;
            },
          };
          return g;
        },
      ]),
      a.directive("uiGridSaveState", [
        "uiGridSaveStateConstants",
        "uiGridSaveStateService",
        "gridUtil",
        "$compile",
        function (a, b, c, d) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            link: function (a, c, d, e) {
              b.initializeGrid(e.grid);
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.selection", ["ui.grid"]);
    a.constant("uiGridSelectionConstants", {
      featureName: "selection",
      selectionRowHeaderColName: "selectionRowHeaderCol",
    }),
      angular.module("ui.grid").config([
        "$provide",
        function (a) {
          a.decorator("GridRow", [
            "$delegate",
            function (a) {
              return (
                (a.prototype.setSelected = function (a) {
                  a !== this.isSelected &&
                    ((this.isSelected = a),
                    (this.grid.selection.selectedCount += a ? 1 : -1));
                }),
                a
              );
            },
          ]);
        },
      ]),
      a.service("uiGridSelectionService", [
        "$q",
        "$templateCache",
        "uiGridSelectionConstants",
        "gridUtil",
        function (a, b, c, d) {
          var e = {
            initializeGrid: function (a) {
              (a.selection = {}),
                (a.selection.lastSelectedRow = null),
                (a.selection.selectAll = !1),
                (a.selection.selectedCount = 0),
                e.defaultGridOptions(a.options);
              var b = {
                events: {
                  selection: {
                    rowSelectionChanged: function (a, b, c) {},
                    rowSelectionChangedBatch: function (a, b, c) {},
                  },
                },
                methods: {
                  selection: {
                    toggleRowSelection: function (b, c) {
                      var d = a.getRow(b);
                      null !== d &&
                        e.toggleRowSelection(
                          a,
                          d,
                          c,
                          a.options.multiSelect,
                          a.options.noUnselect
                        );
                    },
                    selectRow: function (b, c) {
                      var d = a.getRow(b);
                      null === d ||
                        d.isSelected ||
                        e.toggleRowSelection(
                          a,
                          d,
                          c,
                          a.options.multiSelect,
                          a.options.noUnselect
                        );
                    },
                    selectRowByVisibleIndex: function (b, c) {
                      var d = a.renderContainers.body.visibleRowCache[b];
                      null === d ||
                        "undefined" == typeof d ||
                        d.isSelected ||
                        e.toggleRowSelection(
                          a,
                          d,
                          c,
                          a.options.multiSelect,
                          a.options.noUnselect
                        );
                    },
                    unSelectRow: function (b, c) {
                      var d = a.getRow(b);
                      null !== d &&
                        d.isSelected &&
                        e.toggleRowSelection(
                          a,
                          d,
                          c,
                          a.options.multiSelect,
                          a.options.noUnselect
                        );
                    },
                    selectAllRows: function (b) {
                      if (a.options.multiSelect !== !1) {
                        var c = [];
                        a.rows.forEach(function (d) {
                          d.isSelected ||
                            d.enableSelection === !1 ||
                            (d.setSelected(!0),
                            e.decideRaiseSelectionEvent(a, d, c, b));
                        }),
                          e.decideRaiseSelectionBatchEvent(a, c, b),
                          (a.selection.selectAll = !0);
                      }
                    },
                    selectAllVisibleRows: function (b) {
                      if (a.options.multiSelect !== !1) {
                        var c = [];
                        a.rows.forEach(function (d) {
                          d.visible
                            ? d.isSelected ||
                              d.enableSelection === !1 ||
                              (d.setSelected(!0),
                              e.decideRaiseSelectionEvent(a, d, c, b))
                            : d.isSelected &&
                              (d.setSelected(!1),
                              e.decideRaiseSelectionEvent(a, d, c, b));
                        }),
                          e.decideRaiseSelectionBatchEvent(a, c, b),
                          (a.selection.selectAll = !0);
                      }
                    },
                    clearSelectedRows: function (b) {
                      e.clearSelectedRows(a, b);
                    },
                    getSelectedRows: function () {
                      return e.getSelectedRows(a).map(function (a) {
                        return a.entity;
                      });
                    },
                    getSelectedGridRows: function () {
                      return e.getSelectedRows(a);
                    },
                    getSelectedCount: function () {
                      return a.selection.selectedCount;
                    },
                    setMultiSelect: function (b) {
                      a.options.multiSelect = b;
                    },
                    setModifierKeysToMultiSelect: function (b) {
                      a.options.modifierKeysToMultiSelect = b;
                    },
                    getSelectAllState: function () {
                      return a.selection.selectAll;
                    },
                  },
                },
              };
              a.api.registerEventsFromObject(b.events),
                a.api.registerMethodsFromObject(b.methods);
            },
            defaultGridOptions: function (a) {
              (a.enableRowSelection = a.enableRowSelection !== !1),
                (a.multiSelect = a.multiSelect !== !1),
                (a.noUnselect = a.noUnselect === !0),
                (a.modifierKeysToMultiSelect =
                  a.modifierKeysToMultiSelect === !0),
                (a.enableRowHeaderSelection =
                  a.enableRowHeaderSelection !== !1),
                "undefined" == typeof a.enableFullRowSelection &&
                  (a.enableFullRowSelection = !a.enableRowHeaderSelection),
                (a.enableSelectAll = a.enableSelectAll !== !1),
                (a.enableSelectionBatchEvent =
                  a.enableSelectionBatchEvent !== !1),
                (a.selectionRowHeaderWidth = angular.isDefined(
                  a.selectionRowHeaderWidth
                )
                  ? a.selectionRowHeaderWidth
                  : 30),
                (a.enableFooterTotalSelected =
                  a.enableFooterTotalSelected !== !1),
                (a.isRowSelectable = angular.isDefined(a.isRowSelectable)
                  ? a.isRowSelectable
                  : angular.noop);
            },
            toggleRowSelection: function (a, b, c, d, f) {
              var g = b.isSelected;
              if (b.enableSelection !== !1 || g) {
                var h;
                d || g
                  ? !d &&
                    g &&
                    ((h = e.getSelectedRows(a)),
                    h.length > 1 && ((g = !1), e.clearSelectedRows(a, c)))
                  : e.clearSelectedRows(a, c),
                  (g && f) ||
                    (b.setSelected(!g),
                    b.isSelected === !0 && (a.selection.lastSelectedRow = b),
                    (h = e.getSelectedRows(a)),
                    (a.selection.selectAll = a.rows.length === h.length),
                    a.api.selection.raise.rowSelectionChanged(b, c));
              }
            },
            shiftSelect: function (a, b, c, d) {
              if (d) {
                var f = e.getSelectedRows(a),
                  g =
                    f.length > 0
                      ? a.renderContainers.body.visibleRowCache.indexOf(
                          a.selection.lastSelectedRow
                        )
                      : 0,
                  h = a.renderContainers.body.visibleRowCache.indexOf(b);
                if (g > h) {
                  var i = g;
                  (g = h), (h = i);
                }
                for (var j = [], k = g; k <= h; k++) {
                  var l = a.renderContainers.body.visibleRowCache[k];
                  l &&
                    (l.isSelected ||
                      l.enableSelection === !1 ||
                      (l.setSelected(!0),
                      (a.selection.lastSelectedRow = l),
                      e.decideRaiseSelectionEvent(a, l, j, c)));
                }
                e.decideRaiseSelectionBatchEvent(a, j, c);
              }
            },
            getSelectedRows: function (a) {
              return a.rows.filter(function (a) {
                return a.isSelected;
              });
            },
            clearSelectedRows: function (a, b) {
              var c = [];
              e.getSelectedRows(a).forEach(function (d) {
                d.isSelected &&
                  (d.setSelected(!1), e.decideRaiseSelectionEvent(a, d, c, b));
              }),
                e.decideRaiseSelectionBatchEvent(a, c, b),
                (a.selection.selectAll = !1),
                (a.selection.selectedCount = 0);
            },
            decideRaiseSelectionEvent: function (a, b, c, d) {
              a.options.enableSelectionBatchEvent
                ? c.push(b)
                : a.api.selection.raise.rowSelectionChanged(b, d);
            },
            decideRaiseSelectionBatchEvent: function (a, b, c) {
              b.length > 0 &&
                a.api.selection.raise.rowSelectionChangedBatch(b, c);
            },
          };
          return e;
        },
      ]),
      a.directive("uiGridSelection", [
        "uiGridSelectionConstants",
        "uiGridSelectionService",
        "$templateCache",
        "uiGridConstants",
        function (a, b, c, d) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (c, e, f, g) {
                  if (
                    (b.initializeGrid(g.grid),
                    g.grid.options.enableRowHeaderSelection)
                  ) {
                    var h = {
                      name: a.selectionRowHeaderColName,
                      displayName: "",
                      width: g.grid.options.selectionRowHeaderWidth,
                      minWidth: 10,
                      cellTemplate: "ui-grid/selectionRowHeader",
                      headerCellTemplate: "ui-grid/selectionHeaderCell",
                      enableColumnResizing: !1,
                      enableColumnMenu: !1,
                      exporterSuppressExport: !0,
                      allowCellFocus: !0,
                    };
                    g.grid.addRowHeaderColumn(h, 0);
                  }
                  var i = !1,
                    j = function (a) {
                      return (
                        a.forEach(function (a) {
                          a.enableSelection = g.grid.options.isRowSelectable(a);
                        }),
                        a
                      );
                    },
                    k = function () {
                      g.grid.options.isRowSelectable !== angular.noop &&
                        i !== !0 &&
                        (g.grid.registerRowsProcessor(j, 500), (i = !0));
                    };
                  k();
                  var l = g.grid.registerDataChangeCallback(k, [
                    d.dataChange.OPTIONS,
                  ]);
                  c.$on("$destroy", l);
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]),
      a.directive("uiGridSelectionRowHeaderButtons", [
        "$templateCache",
        "uiGridSelectionService",
        "gridUtil",
        function (a, b, c) {
          return {
            replace: !0,
            restrict: "E",
            template: a.get("ui-grid/selectionRowHeaderButtons"),
            scope: !0,
            require: "^uiGrid",
            link: function (a, d, e, f) {
              function h(a, c) {
                c.stopPropagation(),
                  c.shiftKey
                    ? b.shiftSelect(g, a, c, g.options.multiSelect)
                    : c.ctrlKey || c.metaKey
                    ? b.toggleRowSelection(
                        g,
                        a,
                        c,
                        g.options.multiSelect,
                        g.options.noUnselect
                      )
                    : b.toggleRowSelection(
                        g,
                        a,
                        c,
                        g.options.multiSelect &&
                          !g.options.modifierKeysToMultiSelect,
                        g.options.noUnselect
                      );
              }
              function i(a) {
                (a.ctrlKey || a.shiftKey) &&
                  ((a.target.onselectstart = function () {
                    return !1;
                  }),
                  window.setTimeout(function () {
                    a.target.onselectstart = null;
                  }, 0));
              }
              var g = f.grid;
              (a.selectButtonClick = h),
                "ie" === c.detectBrowser() && d.on("mousedown", i),
                a.$on("$destroy", function () {
                  d.off();
                });
            },
          };
        },
      ]),
      a.directive("uiGridSelectionSelectAllButtons", [
        "$templateCache",
        "uiGridSelectionService",
        function (a, b) {
          return {
            replace: !0,
            restrict: "E",
            template: a.get("ui-grid/selectionSelectAllButtons"),
            scope: !1,
            link: function (a, c, d, e) {
              var f = a.col.grid;
              a.headerButtonClick = function (a, c) {
                f.selection.selectAll
                  ? (b.clearSelectedRows(f, c),
                    f.options.noUnselect &&
                      f.api.selection.selectRowByVisibleIndex(0, c),
                    (f.selection.selectAll = !1))
                  : f.options.multiSelect &&
                    (f.api.selection.selectAllVisibleRows(c),
                    (f.selection.selectAll = !0));
              };
            },
          };
        },
      ]),
      a.directive("uiGridViewport", [
        "$compile",
        "uiGridConstants",
        "uiGridSelectionConstants",
        "gridUtil",
        "$parse",
        "uiGridSelectionService",
        function (a, b, c, d, e, f) {
          return {
            priority: -200,
            scope: !1,
            compile: function (a, b) {
              var c = angular.element(a.children().children()[0]),
                d = c.attr("ng-class"),
                e = "";
              return (
                (e = d
                  ? d.slice(0, -1) + ",'ui-grid-row-selected': row.isSelected}"
                  : "{'ui-grid-row-selected': row.isSelected}"),
                c.attr("ng-class", e),
                {
                  pre: function (a, b, c, d) {},
                  post: function (a, b, c, d) {},
                }
              );
            },
          };
        },
      ]),
      a.directive("uiGridCell", [
        "$compile",
        "uiGridConstants",
        "uiGridSelectionConstants",
        "gridUtil",
        "$parse",
        "uiGridSelectionService",
        "$timeout",
        function (a, b, c, d, e, f, g) {
          return {
            priority: -200,
            restrict: "A",
            require: "?^uiGrid",
            scope: !1,
            link: function (a, c, d, e) {
              function m() {
                a.grid.options.enableRowSelection &&
                  a.grid.options.enableFullRowSelection &&
                  (c.addClass("ui-grid-disable-selection"),
                  c.on("touchstart", k),
                  c.on("touchend", l),
                  c.on("click", j),
                  (a.registered = !0));
              }
              function n() {
                a.registered &&
                  (c.removeClass("ui-grid-disable-selection"),
                  c.off("touchstart", k),
                  c.off("touchend", l),
                  c.off("click", j),
                  (a.registered = !1));
              }
              var h = 0,
                i = 300;
              e.grid.api.cellNav &&
                e.grid.api.cellNav.on.viewPortKeyDown(a, function (b, c) {
                  null !== c &&
                    c.row === a.row &&
                    c.col === a.col &&
                    32 === b.keyCode &&
                    "selectionRowHeaderCol" === a.col.colDef.name &&
                    (f.toggleRowSelection(
                      a.grid,
                      a.row,
                      b,
                      a.grid.options.multiSelect &&
                        !a.grid.options.modifierKeysToMultiSelect,
                      a.grid.options.noUnselect
                    ),
                    a.$apply());
                });
              var j = function (b) {
                  "ui-grid-icon-minus-squared" !== b.target.className &&
                    "ui-grid-icon-plus-squared" !== b.target.className &&
                    (c.off("touchend", l),
                    b.shiftKey
                      ? f.shiftSelect(
                          a.grid,
                          a.row,
                          b,
                          a.grid.options.multiSelect
                        )
                      : b.ctrlKey || b.metaKey
                      ? f.toggleRowSelection(
                          a.grid,
                          a.row,
                          b,
                          a.grid.options.multiSelect,
                          a.grid.options.noUnselect
                        )
                      : f.toggleRowSelection(
                          a.grid,
                          a.row,
                          b,
                          a.grid.options.multiSelect &&
                            !a.grid.options.modifierKeysToMultiSelect,
                          a.grid.options.noUnselect
                        ),
                    a.$apply(),
                    g(function () {
                      c.on("touchend", l);
                    }, i));
                },
                k = function (a) {
                  (h = new Date().getTime()), c.off("click", j);
                },
                l = function (a) {
                  var b = new Date().getTime(),
                    d = b - h;
                  d < i && j(a),
                    g(function () {
                      c.on("click", j);
                    }, i);
                };
              m();
              var o = a.grid.registerDataChangeCallback(
                function () {
                  a.grid.options.enableRowSelection &&
                  a.grid.options.enableFullRowSelection &&
                  !a.registered
                    ? m()
                    : (a.grid.options.enableRowSelection &&
                        a.grid.options.enableFullRowSelection) ||
                      !a.registered ||
                      n();
                },
                [b.dataChange.OPTIONS]
              );
              c.on("$destroy", o);
            },
          };
        },
      ]),
      a.directive("uiGridGridFooter", [
        "$compile",
        "uiGridConstants",
        "gridUtil",
        function (a, b, c) {
          return {
            restrict: "EA",
            replace: !0,
            priority: -1e3,
            require: "^uiGrid",
            scope: !0,
            compile: function (b, d) {
              return {
                pre: function (b, d, e, f) {
                  f.grid.options.showGridFooter &&
                    c
                      .getTemplate("ui-grid/gridFooterSelectedItems")
                      .then(function (c) {
                        var e = angular.element(c),
                          f = a(e)(b);
                        angular
                          .element(
                            d[0].getElementsByClassName(
                              "ui-grid-grid-footer"
                            )[0]
                          )
                          .append(f);
                      });
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.treeBase", ["ui.grid"]);
    a.constant("uiGridTreeBaseConstants", {
      featureName: "treeBase",
      rowHeaderColName: "treeBaseRowHeaderCol",
      EXPANDED: "expanded",
      COLLAPSED: "collapsed",
      aggregation: {
        COUNT: "count",
        SUM: "sum",
        MAX: "max",
        MIN: "min",
        AVG: "avg",
      },
    }),
      a.service("uiGridTreeBaseService", [
        "$q",
        "uiGridTreeBaseConstants",
        "gridUtil",
        "GridRow",
        "gridClassFactory",
        "i18nService",
        "uiGridConstants",
        "rowSorter",
        function (a, b, c, d, e, f, g, h) {
          var i = {
            initializeGrid: function (a, b) {
              (a.treeBase = {}),
                (a.treeBase.numberLevels = 0),
                (a.treeBase.expandAll = !1),
                (a.treeBase.tree = []),
                i.defaultGridOptions(a.options),
                a.registerRowsProcessor(i.treeRows, 410),
                a.registerColumnBuilder(i.treeBaseColumnBuilder),
                i.createRowHeader(a);
              var c = {
                events: { treeBase: { rowExpanded: {}, rowCollapsed: {} } },
                methods: {
                  treeBase: {
                    expandAllRows: function () {
                      i.expandAllRows(a);
                    },
                    collapseAllRows: function () {
                      i.collapseAllRows(a);
                    },
                    toggleRowTreeState: function (b) {
                      i.toggleRowTreeState(a, b);
                    },
                    expandRow: function (b) {
                      i.expandRow(a, b);
                    },
                    expandRowChildren: function (b) {
                      i.expandRowChildren(a, b);
                    },
                    collapseRow: function (b) {
                      i.collapseRow(a, b);
                    },
                    collapseRowChildren: function (b) {
                      i.collapseRowChildren(a, b);
                    },
                    getTreeExpandedState: function () {
                      return { expandedState: i.getTreeState(a) };
                    },
                    setTreeState: function (b) {
                      i.setTreeState(a, b);
                    },
                    getRowChildren: function (a) {
                      return a.treeNode.children.map(function (a) {
                        return a.row;
                      });
                    },
                  },
                },
              };
              a.api.registerEventsFromObject(c.events),
                a.api.registerMethodsFromObject(c.methods);
            },
            defaultGridOptions: function (a) {
              (a.treeRowHeaderBaseWidth = a.treeRowHeaderBaseWidth || 30),
                (a.treeIndent = a.treeIndent || 10),
                (a.showTreeRowHeader = a.showTreeRowHeader !== !1),
                (a.showTreeExpandNoChildren =
                  a.showTreeExpandNoChildren !== !1),
                (a.treeRowHeaderAlwaysVisible =
                  a.treeRowHeaderAlwaysVisible !== !1),
                (a.treeCustomAggregations = a.treeCustomAggregations || {}),
                (a.enableExpandAll = a.enableExpandAll !== !1);
            },
            treeBaseColumnBuilder: function (a, b, c) {
              "undefined" != typeof a.customTreeAggregationFn &&
                (b.treeAggregationFn = a.customTreeAggregationFn),
                "undefined" != typeof a.treeAggregationType &&
                  ((b.treeAggregation = { type: a.treeAggregationType }),
                  "undefined" !=
                  typeof c.treeCustomAggregations[a.treeAggregationType]
                    ? ((b.treeAggregationFn =
                        c.treeCustomAggregations[
                          a.treeAggregationType
                        ].aggregationFn),
                      (b.treeAggregationFinalizerFn =
                        c.treeCustomAggregations[
                          a.treeAggregationType
                        ].finalizerFn),
                      (b.treeAggregation.label =
                        c.treeCustomAggregations[a.treeAggregationType].label))
                    : "undefined" !=
                        typeof i.nativeAggregations()[a.treeAggregationType] &&
                      ((b.treeAggregationFn = i.nativeAggregations()[
                        a.treeAggregationType
                      ].aggregationFn),
                      (b.treeAggregation.label = i.nativeAggregations()[
                        a.treeAggregationType
                      ].label))),
                "undefined" != typeof a.treeAggregationLabel &&
                  ("undefined" == typeof b.treeAggregation &&
                    (b.treeAggregation = {}),
                  (b.treeAggregation.label = a.treeAggregationLabel)),
                (b.treeAggregationUpdateEntity =
                  a.treeAggregationUpdateEntity !== !1),
                "undefined" == typeof b.customTreeAggregationFinalizerFn &&
                  (b.customTreeAggregationFinalizerFn =
                    a.customTreeAggregationFinalizerFn);
            },
            createRowHeader: function (a) {
              var c = {
                name: b.rowHeaderColName,
                displayName: "",
                width: a.options.treeRowHeaderBaseWidth,
                minWidth: 10,
                cellTemplate: "ui-grid/treeBaseRowHeader",
                headerCellTemplate: "ui-grid/treeBaseHeaderCell",
                enableColumnResizing: !1,
                enableColumnMenu: !1,
                exporterSuppressExport: !0,
                allowCellFocus: !0,
              };
              (c.visible = a.options.treeRowHeaderAlwaysVisible),
                a.addRowHeaderColumn(c, -100);
            },
            expandAllRows: function (a) {
              a.treeBase.tree.forEach(function (c) {
                i.setAllNodes(a, c, b.EXPANDED);
              }),
                (a.treeBase.expandAll = !0),
                a.queueGridRefresh();
            },
            collapseAllRows: function (a) {
              a.treeBase.tree.forEach(function (c) {
                i.setAllNodes(a, c, b.COLLAPSED);
              }),
                (a.treeBase.expandAll = !1),
                a.queueGridRefresh();
            },
            setAllNodes: function (a, c, d) {
              "undefined" != typeof c.state &&
                c.state !== d &&
                ((c.state = d),
                d === b.EXPANDED
                  ? a.api.treeBase.raise.rowExpanded(c.row)
                  : a.api.treeBase.raise.rowCollapsed(c.row)),
                c.children &&
                  c.children.forEach(function (b) {
                    i.setAllNodes(a, b, d);
                  });
            },
            toggleRowTreeState: function (a, c) {
              "undefined" == typeof c.treeLevel ||
                null === c.treeLevel ||
                c.treeLevel < 0 ||
                (c.treeNode.state === b.EXPANDED
                  ? i.collapseRow(a, c)
                  : i.expandRow(a, c),
                a.queueGridRefresh());
            },
            expandRow: function (a, c) {
              "undefined" == typeof c.treeLevel ||
                null === c.treeLevel ||
                c.treeLevel < 0 ||
                (c.treeNode.state !== b.EXPANDED &&
                  ((c.treeNode.state = b.EXPANDED),
                  a.api.treeBase.raise.rowExpanded(c),
                  (a.treeBase.expandAll = i.allExpanded(a.treeBase.tree)),
                  a.queueGridRefresh()));
            },
            expandRowChildren: function (a, c) {
              "undefined" == typeof c.treeLevel ||
                null === c.treeLevel ||
                c.treeLevel < 0 ||
                (i.setAllNodes(a, c.treeNode, b.EXPANDED),
                (a.treeBase.expandAll = i.allExpanded(a.treeBase.tree)),
                a.queueGridRefresh());
            },
            collapseRow: function (a, c) {
              "undefined" == typeof c.treeLevel ||
                null === c.treeLevel ||
                c.treeLevel < 0 ||
                (c.treeNode.state !== b.COLLAPSED &&
                  ((c.treeNode.state = b.COLLAPSED),
                  (a.treeBase.expandAll = !1),
                  a.api.treeBase.raise.rowCollapsed(c),
                  a.queueGridRefresh()));
            },
            collapseRowChildren: function (a, c) {
              "undefined" == typeof c.treeLevel ||
                null === c.treeLevel ||
                c.treeLevel < 0 ||
                (i.setAllNodes(a, c.treeNode, b.COLLAPSED),
                (a.treeBase.expandAll = !1),
                a.queueGridRefresh());
            },
            allExpanded: function (a) {
              var b = !0;
              return (
                a.forEach(function (a) {
                  i.allExpandedInternal(a) || (b = !1);
                }),
                b
              );
            },
            allExpandedInternal: function (a) {
              if (a.children && a.children.length > 0) {
                if (a.state === b.COLLAPSED) return !1;
                var c = !0;
                return (
                  a.children.forEach(function (a) {
                    i.allExpandedInternal(a) || (c = !1);
                  }),
                  c
                );
              }
              return !0;
            },
            treeRows: function (a) {
              if (0 === a.length) return a;
              var c = this;
              b.EXPANDED;
              return (
                (c.treeBase.tree = i.createTree(c, a)),
                i.updateRowHeaderWidth(c),
                i.sortTree(c),
                i.fixFilter(c),
                i.renderTree(c.treeBase.tree)
              );
            },
            updateRowHeaderWidth: function (a) {
              var c = a.getColumn(b.rowHeaderColName),
                d =
                  a.options.treeRowHeaderBaseWidth +
                  a.options.treeIndent *
                    Math.max(a.treeBase.numberLevels - 1, 0);
              c && d !== c.width && ((c.width = d), a.queueRefresh());
              var e = !0;
              a.options.showTreeRowHeader === !1 && (e = !1),
                a.options.treeRowHeaderAlwaysVisible === !1 &&
                  a.treeBase.numberLevels <= 0 &&
                  (e = !1),
                c.visible !== e &&
                  ((c.visible = e),
                  (c.colDef.visible = e),
                  a.queueGridRefresh());
            },
            renderTree: function (a) {
              var c = [];
              return (
                a.forEach(function (a) {
                  a.row.visible && c.push(a.row),
                    a.state === b.EXPANDED &&
                      a.children &&
                      a.children.length > 0 &&
                      (c = c.concat(i.renderTree(a.children)));
                }),
                c
              );
            },
            createTree: function (a, c) {
              var f,
                d = -1,
                e = [];
              (a.treeBase.tree = []), (a.treeBase.numberLevels = 0);
              var g = i.getAggregations(a),
                h = function (c) {
                  if (
                    ("undefined" != typeof c.entity.$$treeLevel &&
                      c.treeLevel !== c.entity.$$treeLevel &&
                      (c.treeLevel = c.entity.$$treeLevel),
                    c.treeLevel <= d)
                  ) {
                    for (; c.treeLevel <= d; ) {
                      var h = e.pop();
                      i.finaliseAggregations(h), d--;
                    }
                    f = e.length > 0 ? i.setCurrentState(e) : b.EXPANDED;
                  }
                  ("undefined" == typeof c.treeLevel ||
                    null === c.treeLevel ||
                    c.treeLevel < 0) &&
                    c.visible &&
                    i.aggregate(a, c, e),
                    i.addOrUseNode(a, c, e, g),
                    "undefined" != typeof c.treeLevel &&
                      null !== c.treeLevel &&
                      c.treeLevel >= 0 &&
                      (e.push(c), d++, (f = i.setCurrentState(e))),
                    a.treeBase.numberLevels < c.treeLevel + 1 &&
                      (a.treeBase.numberLevels = c.treeLevel + 1);
                };
              for (c.forEach(h); e.length > 0; ) {
                var j = e.pop();
                i.finaliseAggregations(j);
              }
              return a.treeBase.tree;
            },
            addOrUseNode: function (a, c, d, e) {
              var f = [];
              e.forEach(function (a) {
                f.push(i.buildAggregationObject(a.col));
              });
              var g = {
                state: b.COLLAPSED,
                row: c,
                parentRow: null,
                aggregations: f,
                children: [],
              };
              c.treeNode && (g.state = c.treeNode.state),
                d.length > 0 && (g.parentRow = d[d.length - 1]),
                (c.treeNode = g),
                0 === d.length
                  ? a.treeBase.tree.push(g)
                  : d[d.length - 1].treeNode.children.push(g);
            },
            setCurrentState: function (a) {
              var c = b.EXPANDED;
              return (
                a.forEach(function (a) {
                  a.treeNode.state === b.COLLAPSED && (c = b.COLLAPSED);
                }),
                c
              );
            },
            sortTree: function (a) {
              a.columns.forEach(function (a) {
                a.sort && a.sort.ignoreSort && delete a.sort.ignoreSort;
              }),
                (a.treeBase.tree = i.sortInternal(a, a.treeBase.tree));
            },
            sortInternal: function (a, c) {
              var d = c.map(function (a) {
                return a.row;
              });
              d = h.sort(a, d, a.columns);
              var e = d.map(function (a) {
                return a.treeNode;
              });
              return (
                e.forEach(function (c) {
                  c.state === b.EXPANDED &&
                    c.children &&
                    c.children.length > 0 &&
                    (c.children = i.sortInternal(a, c.children));
                }),
                e
              );
            },
            fixFilter: function (a) {
              var b;
              a.treeBase.tree.forEach(function (a) {
                a.children &&
                  a.children.length > 0 &&
                  ((b = a.row.visible), i.fixFilterInternal(a.children, b));
              });
            },
            fixFilterInternal: function (a, b) {
              return (
                a.forEach(function (a) {
                  a.row.visible && !b && (i.setParentsVisible(a), (b = !0)),
                    a.children &&
                      a.children.length > 0 &&
                      i.fixFilterInternal(a.children, b && a.row.visible) &&
                      (b = !0);
                }),
                b
              );
            },
            setParentsVisible: function (a) {
              for (; a.parentRow; )
                (a.parentRow.visible = !0), (a = a.parentRow.treeNode);
            },
            buildAggregationObject: function (a) {
              var b = { col: a };
              return (
                a.treeAggregation &&
                  a.treeAggregation.type &&
                  (b.type = a.treeAggregation.type),
                a.treeAggregation &&
                  a.treeAggregation.label &&
                  (b.label = a.treeAggregation.label),
                b
              );
            },
            getAggregations: function (a) {
              var b = [];
              return (
                a.columns.forEach(function (c) {
                  "undefined" != typeof c.treeAggregationFn &&
                    (b.push(i.buildAggregationObject(c)),
                    a.options.showColumnFooter &&
                      "undefined" == typeof c.colDef.aggregationType &&
                      c.treeAggregation &&
                      ((c.treeFooterAggregation = i.buildAggregationObject(c)),
                      (c.aggregationType = i.treeFooterAggregationType)));
                }),
                b
              );
            },
            aggregate: function (a, b, c) {
              0 === c.length &&
                b.treeNode &&
                b.treeNode.aggregations &&
                b.treeNode.aggregations.forEach(function (c) {
                  if ("undefined" != typeof c.col.treeFooterAggregation) {
                    var d = a.getCellValue(b, c.col),
                      e = Number(d);
                    c.col.treeAggregationFn(
                      c.col.treeFooterAggregation,
                      d,
                      e,
                      b
                    );
                  }
                }),
                c.forEach(function (c, d) {
                  c.treeNode.aggregations &&
                    c.treeNode.aggregations.forEach(function (c) {
                      var e = a.getCellValue(b, c.col),
                        f = Number(e);
                      c.col.treeAggregationFn(c, e, f, b),
                        0 === d &&
                          "undefined" != typeof c.col.treeFooterAggregation &&
                          c.col.treeAggregationFn(
                            c.col.treeFooterAggregation,
                            e,
                            f,
                            b
                          );
                    });
                });
            },
            nativeAggregations: function () {
              var a = {
                count: {
                  label: f.get().aggregation.count,
                  menuTitle: f.get().grouping.aggregate_count,
                  aggregationFn: function (a, b, c) {
                    "undefined" == typeof a.value ? (a.value = 1) : a.value++;
                  },
                },
                sum: {
                  label: f.get().aggregation.sum,
                  menuTitle: f.get().grouping.aggregate_sum,
                  aggregationFn: function (a, b, c) {
                    isNaN(c) ||
                      ("undefined" == typeof a.value
                        ? (a.value = c)
                        : (a.value += c));
                  },
                },
                min: {
                  label: f.get().aggregation.min,
                  menuTitle: f.get().grouping.aggregate_min,
                  aggregationFn: function (a, b, c) {
                    "undefined" == typeof a.value
                      ? (a.value = b)
                      : "undefined" != typeof b &&
                        null !== b &&
                        (b < a.value || null === a.value) &&
                        (a.value = b);
                  },
                },
                max: {
                  label: f.get().aggregation.max,
                  menuTitle: f.get().grouping.aggregate_max,
                  aggregationFn: function (a, b, c) {
                    "undefined" == typeof a.value
                      ? (a.value = b)
                      : "undefined" != typeof b &&
                        null !== b &&
                        (b > a.value || null === a.value) &&
                        (a.value = b);
                  },
                },
                avg: {
                  label: f.get().aggregation.avg,
                  menuTitle: f.get().grouping.aggregate_avg,
                  aggregationFn: function (a, b, c) {
                    "undefined" == typeof a.count ? (a.count = 1) : a.count++,
                      isNaN(c) ||
                        ("undefined" == typeof a.value ||
                        "undefined" == typeof a.sum
                          ? ((a.value = c), (a.sum = c))
                          : ((a.sum += c), (a.value = a.sum / a.count)));
                  },
                },
              };
              return a;
            },
            finaliseAggregation: function (a, b) {
              b.col.treeAggregationUpdateEntity &&
                "undefined" != typeof a &&
                "undefined" != typeof a.entity["$$" + b.col.uid] &&
                angular.extend(b, a.entity["$$" + b.col.uid]),
                "function" == typeof b.col.treeAggregationFinalizerFn &&
                  b.col.treeAggregationFinalizerFn(b),
                "function" == typeof b.col.customTreeAggregationFinalizerFn &&
                  b.col.customTreeAggregationFinalizerFn(b),
                "undefined" == typeof b.rendered &&
                  (b.rendered = b.label ? b.label + b.value : b.value);
            },
            finaliseAggregations: function (a) {
              null != a &&
                "undefined" != typeof a.treeNode.aggregations &&
                a.treeNode.aggregations.forEach(function (b) {
                  if (
                    (i.finaliseAggregation(a, b),
                    b.col.treeAggregationUpdateEntity)
                  ) {
                    var c = {};
                    angular.forEach(b, function (a, d) {
                      b.hasOwnProperty(d) && "col" !== d && (c[d] = a);
                    }),
                      (a.entity["$$" + b.col.uid] = c);
                  }
                });
            },
            treeFooterAggregationType: function (a, b) {
              return (
                i.finaliseAggregation(void 0, b.treeFooterAggregation),
                "undefined" == typeof b.treeFooterAggregation.value ||
                null === b.treeFooterAggregation.rendered
                  ? ""
                  : b.treeFooterAggregation.rendered
              );
            },
          };
          return i;
        },
      ]),
      a.directive("uiGridTreeBaseRowHeaderButtons", [
        "$templateCache",
        "uiGridTreeBaseService",
        function (a, b) {
          return {
            replace: !0,
            restrict: "E",
            template: a.get("ui-grid/treeBaseRowHeaderButtons"),
            scope: !0,
            require: "^uiGrid",
            link: function (a, c, d, e) {
              var f = e.grid;
              a.treeButtonClick = function (a, c) {
                b.toggleRowTreeState(f, a, c);
              };
            },
          };
        },
      ]),
      a.directive("uiGridTreeBaseExpandAllButtons", [
        "$templateCache",
        "uiGridTreeBaseService",
        function (a, b) {
          return {
            replace: !0,
            restrict: "E",
            template: a.get("ui-grid/treeBaseExpandAllButtons"),
            scope: !1,
            link: function (a, c, d, e) {
              var f = a.col.grid;
              a.headerButtonClick = function (a, c) {
                f.treeBase.expandAll
                  ? b.collapseAllRows(f, c)
                  : b.expandAllRows(f, c);
              };
            },
          };
        },
      ]),
      a.directive("uiGridViewport", [
        "$compile",
        "uiGridConstants",
        "gridUtil",
        "$parse",
        function (a, b, c, d) {
          return {
            priority: -200,
            scope: !1,
            compile: function (a, b) {
              var c = angular.element(a.children().children()[0]),
                d = c.attr("ng-class"),
                e = "";
              return (
                (e = d
                  ? d.slice(0, -1) +
                    ",'ui-grid-tree-header-row': row.treeLevel > -1}"
                  : "{'ui-grid-tree-header-row': row.treeLevel > -1}"),
                c.attr("ng-class", e),
                {
                  pre: function (a, b, c, d) {},
                  post: function (a, b, c, d) {},
                }
              );
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.treeView", ["ui.grid", "ui.grid.treeBase"]);
    a.constant("uiGridTreeViewConstants", {
      featureName: "treeView",
      rowHeaderColName: "treeBaseRowHeaderCol",
      EXPANDED: "expanded",
      COLLAPSED: "collapsed",
      aggregation: {
        COUNT: "count",
        SUM: "sum",
        MAX: "max",
        MIN: "min",
        AVG: "avg",
      },
    }),
      a.service("uiGridTreeViewService", [
        "$q",
        "uiGridTreeViewConstants",
        "uiGridTreeBaseConstants",
        "uiGridTreeBaseService",
        "gridUtil",
        "GridRow",
        "gridClassFactory",
        "i18nService",
        "uiGridConstants",
        function (a, b, c, d, e, f, g, h, i) {
          var j = {
            initializeGrid: function (a, b) {
              d.initializeGrid(a, b),
                (a.treeView = {}),
                a.registerRowsProcessor(j.adjustSorting, 60);
              var c = { events: { treeView: {} }, methods: { treeView: {} } };
              a.api.registerEventsFromObject(c.events),
                a.api.registerMethodsFromObject(c.methods);
            },
            defaultGridOptions: function (a) {
              a.enableTreeView = a.enableTreeView !== !1;
            },
            adjustSorting: function (a) {
              var b = this;
              return (
                b.columns.forEach(function (a) {
                  a.sort && (a.sort.ignoreSort = !0);
                }),
                a
              );
            },
          };
          return j;
        },
      ]),
      a.directive("uiGridTreeView", [
        "uiGridTreeViewConstants",
        "uiGridTreeViewService",
        "$templateCache",
        function (a, b, c) {
          return {
            replace: !0,
            priority: 0,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (a, c, d, e) {
                  e.grid.options.enableTreeView !== !1 &&
                    b.initializeGrid(e.grid, a);
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]);
  })(),
  (function () {
    "use strict";
    var a = angular.module("ui.grid.validate", ["ui.grid"]);
    a.service("uiGridValidateService", [
      "$sce",
      "$q",
      "$http",
      "i18nService",
      "uiGridConstants",
      function (a, b, c, d, e) {
        var f = {
          validatorFactories: {},
          setExternalFactoryFunction: function (a) {
            f.externalFactoryFunction = a;
          },
          clearExternalFactory: function () {
            delete f.externalFactoryFunction;
          },
          getValidatorFromExternalFactory: function (a, b) {
            return f.externalFactoryFunction(a, b).validatorFactory(b);
          },
          getMessageFromExternalFactory: function (a, b) {
            return f.externalFactoryFunction(a, b).messageFunction(b);
          },
          setValidator: function (a, b, c) {
            f.validatorFactories[a] = {
              validatorFactory: b,
              messageFunction: c,
            };
          },
          getValidator: function (a, b) {
            if (f.externalFactoryFunction) {
              var c = f.getValidatorFromExternalFactory(a, b);
              if (c) return c;
            }
            if (!f.validatorFactories[a]) throw "Invalid validator name: " + a;
            return f.validatorFactories[a].validatorFactory(b);
          },
          getMessage: function (a, b) {
            if (f.externalFactoryFunction) {
              var c = f.getMessageFromExternalFactory(a, b);
              if (c) return c;
            }
            return f.validatorFactories[a].messageFunction(b);
          },
          isInvalid: function (a, b) {
            return a["$$invalid" + b.name];
          },
          setInvalid: function (a, b) {
            a["$$invalid" + b.name] = !0;
          },
          setValid: function (a, b) {
            delete a["$$invalid" + b.name];
          },
          setError: function (a, b, c) {
            a["$$errors" + b.name] || (a["$$errors" + b.name] = {}),
              (a["$$errors" + b.name][c] = !0);
          },
          clearError: function (a, b, c) {
            a["$$errors" + b.name] &&
              c in a["$$errors" + b.name] &&
              delete a["$$errors" + b.name][c];
          },
          getErrorMessages: function (a, b) {
            var c = [];
            return a["$$errors" + b.name] &&
              0 !== Object.keys(a["$$errors" + b.name]).length
              ? (Object.keys(a["$$errors" + b.name])
                  .sort()
                  .forEach(function (a) {
                    c.push(f.getMessage(a, b.validators[a]));
                  }),
                c)
              : c;
          },
          getFormattedErrors: function (b, c) {
            var e = "",
              g = f.getErrorMessages(b, c);
            if (g.length)
              return (
                g.forEach(function (a) {
                  e += a + "<br/>";
                }),
                a.trustAsHtml(
                  "<p><b>" + d.getSafeText("validate.error") + "</b></p>" + e
                )
              );
          },
          getTitleFormattedErrors: function (b, c) {
            var e = "\n",
              g = "",
              h = f.getErrorMessages(b, c);
            if (h.length)
              return (
                h.forEach(function (a) {
                  g += a + e;
                }),
                a.trustAsHtml(d.getSafeText("validate.error") + e + g)
              );
          },
          runValidators: function (a, c, d, e, g) {
            if (d !== e) {
              if ("undefined" == typeof c.name || !c.name)
                throw new Error(
                  "colDef.name is required to perform validation"
                );
              f.setValid(a, c);
              var h = function (a, b, c) {
                  return function (h) {
                    h ||
                      (f.setInvalid(a, b),
                      f.setError(a, b, c),
                      g && g.api.validate.raise.validationFailed(a, b, d, e));
                  };
                },
                i = [];
              for (var j in c.validators) {
                f.clearError(a, c, j);
                var l = f.getValidator(j, c.validators[j]),
                  m = b.when(l(e, d, a, c)).then(h(a, c, j));
                i.push(m);
              }
              return b.all(i);
            }
          },
          createDefaultValidators: function () {
            f.setValidator(
              "minLength",
              function (a) {
                return function (b, c, d, e) {
                  return (
                    void 0 === c || null === c || "" === c || c.length >= a
                  );
                };
              },
              function (a) {
                return d
                  .getSafeText("validate.minLength")
                  .replace("THRESHOLD", a);
              }
            ),
              f.setValidator(
                "maxLength",
                function (a) {
                  return function (b, c, d, e) {
                    return (
                      void 0 === c || null === c || "" === c || c.length <= a
                    );
                  };
                },
                function (a) {
                  return d
                    .getSafeText("validate.maxLength")
                    .replace("THRESHOLD", a);
                }
              ),
              f.setValidator(
                "required",
                function (a) {
                  return function (b, c, d, e) {
                    return !a || !(void 0 === c || null === c || "" === c);
                  };
                },
                function (a) {
                  return d.getSafeText("validate.required");
                }
              );
          },
          initializeGrid: function (a, b) {
            b.validate = {
              isInvalid: f.isInvalid,
              getFormattedErrors: f.getFormattedErrors,
              getTitleFormattedErrors: f.getTitleFormattedErrors,
              runValidators: f.runValidators,
            };
            var c = {
              events: {
                validate: { validationFailed: function (a, b, c, d) {} },
              },
              methods: {
                validate: {
                  isInvalid: function (a, c) {
                    return b.validate.isInvalid(a, c);
                  },
                  getErrorMessages: function (a, c) {
                    return b.validate.getErrorMessages(a, c);
                  },
                  getFormattedErrors: function (a, c) {
                    return b.validate.getFormattedErrors(a, c);
                  },
                  getTitleFormattedErrors: function (a, c) {
                    return b.validate.getTitleFormattedErrors(a, c);
                  },
                },
              },
            };
            b.api.registerEventsFromObject(c.events),
              b.api.registerMethodsFromObject(c.methods),
              b.edit &&
                b.api.edit.on.afterCellEdit(a, function (a, c, d, e) {
                  b.validate.runValidators(a, c, d, e, b);
                }),
              f.createDefaultValidators();
          },
        };
        return f;
      },
    ]),
      a.directive("uiGridValidate", [
        "gridUtil",
        "uiGridValidateService",
        function (a, b) {
          return {
            priority: 0,
            replace: !0,
            require: "^uiGrid",
            scope: !1,
            compile: function () {
              return {
                pre: function (a, c, d, e) {
                  b.initializeGrid(a, e.grid);
                },
                post: function (a, b, c, d) {},
              };
            },
          };
        },
      ]);
  })(),
  angular.module("ui.grid").run([
    "$templateCache",
    function (a) {
      "use strict";
      a.put(
        "ui-grid/ui-grid-filter",
        '<div class="ui-grid-filter-container" ng-style="col.extraStyle" ng-repeat="colFilter in col.filters" ng-class="{\'ui-grid-filter-cancel-button-hidden\' : colFilter.disableCancelFilterButton === true }"><div ng-if="colFilter.type !== \'select\'"><input type="text" class="ui-grid-filter-input ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-attr-placeholder="{{colFilter.placeholder || \'\'}}" aria-label="{{colFilter.ariaLabel || aria.defaultFilterLabel}}"><div role="button" class="ui-grid-filter-button" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term !== null && colFilter.term !== \'\'"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div><div ng-if="colFilter.type === \'select\'"><select class="ui-grid-filter-select ui-grid-filter-input-{{$index}}" ng-model="colFilter.term" ng-show="colFilter.selectOptions.length > 0" ng-attr-placeholder="{{colFilter.placeholder || aria.defaultFilterLabel}}" aria-label="{{colFilter.ariaLabel || \'\'}}" ng-options="option.value as option.label for option in colFilter.selectOptions"><option value=""></option></select><div role="button" class="ui-grid-filter-button-select" ng-click="removeFilter(colFilter, $index)" ng-if="!colFilter.disableCancelFilterButton" ng-disabled="colFilter.term === undefined || colFilter.term === null || colFilter.term === \'\'" ng-show="colFilter.term !== undefined && colFilter.term != null"><i class="ui-grid-icon-cancel" ui-grid-one-bind-aria-label="aria.removeFilter">&nbsp;</i></div></div></div>'
      ),
        a.put(
          "ui-grid/ui-grid-footer",
          '<div class="ui-grid-footer-panel ui-grid-footer-aggregates-row"><!-- tfooter --><div class="ui-grid-footer ui-grid-footer-viewport"><div class="ui-grid-footer-canvas"><div class="ui-grid-footer-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-footer-cell-row"><div ui-grid-footer-cell role="gridcell" ng-repeat="col in colContainer.renderedColumns track by col.uid" col="col" render-index="$index" class="ui-grid-footer-cell ui-grid-clearfix"></div></div></div></div></div></div>'
        ),
        a.put(
          "ui-grid/ui-grid-grid-footer",
          '<div class="ui-grid-footer-info ui-grid-grid-footer"><span>{{\'search.totalItems\' | t}} {{grid.rows.length}}</span> <span ng-if="grid.renderContainers.body.visibleRowCache.length !== grid.rows.length" class="ngLabel">({{"search.showingItems" | t}} {{grid.renderContainers.body.visibleRowCache.length}})</span></div>'
        ),
        a.put(
          "ui-grid/ui-grid-group-panel",
          '<div class="ui-grid-group-panel"><div ui-t="groupPanel.description" class="description" ng-show="groupings.length == 0"></div><ul ng-show="groupings.length > 0" class="ngGroupList"><li class="ngGroupItem" ng-repeat="group in configGroups"><span class="ngGroupElement"><span class="ngGroupName">{{group.displayName}} <span ng-click="removeGroup($index)" class="ngRemoveGroup">x</span></span> <span ng-hide="$last" class="ngGroupArrow"></span></span></li></ul></div>'
        ),
        a.put(
          "ui-grid/ui-grid-header",
          '<div role="rowgroup" class="ui-grid-header"><!-- theader --><div class="ui-grid-top-panel"><div class="ui-grid-header-viewport"><div class="ui-grid-header-canvas"><div class="ui-grid-header-cell-wrapper" ng-style="colContainer.headerCellWrapperStyle()"><div role="row" class="ui-grid-header-cell-row"><div class="ui-grid-header-cell ui-grid-clearfix" ng-repeat="col in colContainer.renderedColumns track by col.uid" ui-grid-header-cell col="col" render-index="$index"></div></div></div></div></div></div></div>'
        ),
        a.put(
          "ui-grid/ui-grid-menu-button",
          '<div class="ui-grid-menu-button"><div role="button" ui-grid-one-bind-id-grid="\'grid-menu\'" class="ui-grid-icon-container" ng-click="toggleMenu()" aria-haspopup="true"><i class="ui-grid-icon-menu" ui-grid-one-bind-aria-label="i18n.aria.buttonLabel">&nbsp;</i></div><div ui-grid-menu menu-items="menuItems"></div></div>'
        ),
        a.put(
          "ui-grid/ui-grid-no-header",
          '<div class="ui-grid-top-panel"></div>'
        ),
        a.put(
          "ui-grid/ui-grid-row",
          "<div ng-repeat=\"(colRenderIndex, col) in colContainer.renderedColumns track by col.uid\" ui-grid-one-bind-id-grid=\"rowRenderIndex + '-' + col.uid + '-cell'\" class=\"ui-grid-cell\" ng-class=\"{ 'ui-grid-row-header-cell': col.isRowHeader }\" role=\"{{col.isRowHeader ? 'rowheader' : 'gridcell'}}\" ui-grid-cell></div>"
        ),
        a.put(
          "ui-grid/ui-grid",
          '<div ui-i18n="en" class="ui-grid"><!-- TODO (c0bra): add "scoped" attr here, eventually? --><style ui-grid-style>.grid{{ grid.id }} {\n      /* Styles for the grid */\n    }\n\n    .grid{{ grid.id }} .ui-grid-row, .grid{{ grid.id }} .ui-grid-cell, .grid{{ grid.id }} .ui-grid-cell .ui-grid-vertical-bar {\n      height: {{ grid.options.rowHeight }}px;\n    }\n\n    .grid{{ grid.id }} .ui-grid-row:last-child .ui-grid-cell {\n      border-bottom-width: {{ ((grid.getTotalRowHeight() < grid.getViewportHeight()) && \'1\') || \'0\' }}px;\n    }\n\n    {{ grid.verticalScrollbarStyles }}\n    {{ grid.horizontalScrollbarStyles }}\n\n    /*\n    .ui-grid[dir=rtl] .ui-grid-viewport {\n      padding-left: {{ grid.verticalScrollbarWidth }}px;\n    }\n    */\n\n    {{ grid.customStyles }}</style><div class="ui-grid-contents-wrapper"><div ui-grid-menu-button ng-if="grid.options.enableGridMenu"></div><div ng-if="grid.hasLeftContainer()" style="width: 0" ui-grid-pinned-container="\'left\'"></div><div ui-grid-render-container container-id="\'body\'" col-container-name="\'body\'" row-container-name="\'body\'" bind-scroll-horizontal="true" bind-scroll-vertical="true" enable-horizontal-scrollbar="grid.options.enableHorizontalScrollbar" enable-vertical-scrollbar="grid.options.enableVerticalScrollbar"></div><div ng-if="grid.hasRightContainer()" style="width: 0" ui-grid-pinned-container="\'right\'"></div><div ui-grid-grid-footer ng-if="grid.options.showGridFooter"></div><div ui-grid-column-menu ng-if="grid.options.enableColumnMenus"></div><div ng-transclude></div></div></div>'
        ),
        a.put(
          "ui-grid/uiGridCell",
          '<div class="ui-grid-cell-contents" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>'
        ),
        a.put(
          "ui-grid/uiGridColumnMenu",
          '<div class="ui-grid-column-menu"><div ui-grid-menu menu-items="menuItems"><!-- <div class="ui-grid-column-menu">\n    <div class="inner" ng-show="menuShown">\n      <ul>\n        <div ng-show="grid.options.enableSorting">\n          <li ng-click="sortColumn($event, asc)" ng-class="{ \'selected\' : col.sort.direction == asc }"><i class="ui-grid-icon-sort-alt-up"></i> Sort Ascending</li>\n          <li ng-click="sortColumn($event, desc)" ng-class="{ \'selected\' : col.sort.direction == desc }"><i class="ui-grid-icon-sort-alt-down"></i> Sort Descending</li>\n          <li ng-show="col.sort.direction" ng-click="unsortColumn()"><i class="ui-grid-icon-cancel"></i> Remove Sort</li>\n        </div>\n      </ul>\n    </div>\n  </div> --></div></div>'
        ),
        a.put(
          "ui-grid/uiGridFooterCell",
          '<div class="ui-grid-cell-contents" col-index="renderIndex"><div>{{ col.getAggregationText() + ( col.getAggregationValue() CUSTOM_FILTERS ) }}</div></div>'
        ),
        a.put(
          "ui-grid/uiGridHeaderCell",
          '<div role="columnheader" ng-class="{ \'sortable\': sortable }" ui-grid-one-bind-aria-labelledby-grid="col.uid + \'-header-text \' + col.uid + \'-sortdir-text\'" aria-sort="{{col.sort.direction == asc ? \'ascending\' : ( col.sort.direction == desc ? \'descending\' : (!col.sort.direction ? \'none\' : \'other\'))}}"><div role="button" tabindex="0" class="ui-grid-cell-contents ui-grid-header-cell-primary-focus" col-index="renderIndex" title="TOOLTIP"><span class="ui-grid-header-cell-label" ui-grid-one-bind-id-grid="col.uid + \'-header-text\'">{{ col.displayName CUSTOM_FILTERS }}</span> <span ui-grid-one-bind-id-grid="col.uid + \'-sortdir-text\'" ui-grid-visible="col.sort.direction" aria-label="{{getSortDirectionAriaLabel()}}"><i ng-class="{ \'ui-grid-icon-up-dir\': col.sort.direction == asc, \'ui-grid-icon-down-dir\': col.sort.direction == desc, \'ui-grid-icon-blank\': !col.sort.direction }" title="{{isSortPriorityVisible() ? i18n.headerCell.priority + \' \' + ( col.sort.priority + 1 )  : null}}" aria-hidden="true"></i> <sub ui-grid-visible="isSortPriorityVisible()" class="ui-grid-sort-priority-number">{{col.sort.priority + 1}}</sub></span></div><div role="button" tabindex="0" ui-grid-one-bind-id-grid="col.uid + \'-menu-button\'" class="ui-grid-column-menu-button" ng-if="grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false" ng-click="toggleMenu($event)" ng-class="{\'ui-grid-column-menu-button-last-col\': isLastCol}" ui-grid-one-bind-aria-label="i18n.headerCell.aria.columnMenuButtonLabel" aria-haspopup="true"><i class="ui-grid-icon-angle-down" aria-hidden="true">&nbsp;</i></div><div ui-grid-filter></div></div>'
        ),
        a.put(
          "ui-grid/uiGridMenu",
          '<div class="ui-grid-menu" ng-if="shown"><style ui-grid-style>{{dynamicStyles}}</style><div class="ui-grid-menu-mid" ng-show="shownMid"><div class="ui-grid-menu-inner"><ul role="menu" class="ui-grid-menu-items"><li ng-repeat="item in menuItems" role="menuitem" ui-grid-menu-item ui-grid-one-bind-id="\'menuitem-\'+$index" action="item.action" name="item.title" active="item.active" icon="item.icon" shown="item.shown" context="item.context" template-url="item.templateUrl" leave-open="item.leaveOpen" screen-reader-only="item.screenReaderOnly"></li></ul></div></div></div>'
        ),
        a.put(
          "ui-grid/uiGridMenuItem",
          '<button type="button" class="ui-grid-menu-item" ng-click="itemAction($event, title)" ng-show="itemShown()" ng-class="{ \'ui-grid-menu-item-active\': active(), \'ui-grid-sr-only\': (!focus && screenReaderOnly) }" aria-pressed="{{active()}}" tabindex="0" ng-focus="focus=true" ng-blur="focus=false"><i ng-class="icon" aria-hidden="true">&nbsp;</i> {{ name }}</button>'
        ),
        a.put(
          "ui-grid/uiGridRenderContainer",
          "<div role=\"grid\" ui-grid-one-bind-id-grid=\"'grid-container'\" class=\"ui-grid-render-container\" ng-style=\"{ 'margin-left': colContainer.getMargin('left') + 'px', 'margin-right': colContainer.getMargin('right') + 'px' }\"><!-- All of these dom elements are replaced in place --><div ui-grid-header></div><div ui-grid-viewport></div><div ng-if=\"colContainer.needsHScrollbarPlaceholder()\" class=\"ui-grid-scrollbar-placeholder\" ng-style=\"{height:colContainer.grid.scrollbarHeight + 'px'}\"></div><ui-grid-footer ng-if=\"grid.options.showColumnFooter\"></ui-grid-footer></div>"
        ),
        a.put(
          "ui-grid/uiGridViewport",
          '<div role="rowgroup" class="ui-grid-viewport" ng-style="colContainer.getViewportStyle()"><!-- tbody --><div class="ui-grid-canvas"><div ng-repeat="(rowRenderIndex, row) in rowContainer.renderedRows track by $index" class="ui-grid-row" ng-style="Viewport.rowStyle(rowRenderIndex)"><div role="row" ui-grid-row="row" row-render-index="rowRenderIndex"></div></div></div></div>'
        ),
        a.put(
          "ui-grid/cellEditor",
          '<div><form name="inputForm"><input type="INPUT_TYPE" ng-class="\'colt\' + col.uid" ui-grid-editor ng-model="MODEL_COL_FIELD"></form></div>'
        ),
        a.put(
          "ui-grid/dropdownEditor",
          '<div><form name="inputForm"><select ng-class="\'colt\' + col.uid" ui-grid-edit-dropdown ng-model="MODEL_COL_FIELD" ng-options="field[editDropdownIdLabel] as field[editDropdownValueLabel] CUSTOM_FILTERS for field in editDropdownOptionsArray"></select></form></div>'
        ),
        a.put(
          "ui-grid/fileChooserEditor",
          '<div><form name="inputForm"><input ng-class="\'colt\' + col.uid" ui-grid-edit-file-chooser type="file" id="files" name="files[]" ng-model="MODEL_COL_FIELD"></form></div>'
        ),
        a.put(
          "ui-grid/emptyBaseLayerContainer",
          '<div class="ui-grid-empty-base-layer-container ui-grid-canvas"><div class="ui-grid-row" ng-repeat="(rowRenderIndex, row) in grid.baseLayer.emptyRows track by $index" ng-style="Viewport.rowStyle(rowRenderIndex)"><div><div><div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell {{ col.getColClass(false) }}"></div></div></div></div></div>'
        ),
        a.put(
          "ui-grid/expandableRow",
          '<div ui-grid-expandable-row ng-if="expandableRow.shouldRenderExpand()" class="expandableRow" style="float:left; margin-top: 1px; margin-bottom: 1px" ng-style="{width: (grid.renderContainers.body.getCanvasWidth()) + \'px\', height: row.expandedRowHeight + \'px\'}"></div>'
        ),
        a.put(
          "ui-grid/expandableRowHeader",
          '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-if="!row.groupHeader==true" ng-class="{ \'ui-grid-icon-plus-squared\' : !row.isExpanded, \'ui-grid-icon-minus-squared\' : row.isExpanded }" ng-click="grid.api.expandable.toggleRowExpansion(row.entity)"></i></div></div>'
        ),
        a.put(
          "ui-grid/expandableScrollFiller",
          "<div ng-if=\"expandableRow.shouldRenderFiller()\" ng-class=\"{scrollFiller:true, scrollFillerClass:(colContainer.name === 'body')}\" ng-style=\"{ width: (grid.getViewportWidth()) + 'px', height: row.expandedRowHeight + 2 + 'px', 'margin-left': grid.options.rowHeader.rowHeaderWidth + 'px' }\"><i class=\"ui-grid-icon-spin5 ui-grid-animate-spin\" ng-style=\"{'margin-top': ( row.expandedRowHeight/2 - 5) + 'px', 'margin-left' : ((grid.getViewportWidth() - grid.options.rowHeader.rowHeaderWidth)/2 - 5) + 'px'}\"></i></div>"
        ),
        a.put(
          "ui-grid/expandableTopRowHeader",
          '<div class="ui-grid-row-header-cell ui-grid-expandable-buttons-cell"><div class="ui-grid-cell-contents"><i ng-class="{ \'ui-grid-icon-plus-squared\' : !grid.expandable.expandedAll, \'ui-grid-icon-minus-squared\' : grid.expandable.expandedAll }" ng-click="grid.api.expandable.toggleAllRows()"></i></div></div>'
        ),
        a.put(
          "ui-grid/csvLink",
          '<span class="ui-grid-exporter-csv-link-span"><a href="data:text/csv;charset=UTF-8,CSV_CONTENT" download="FILE_NAME">LINK_LABEL</a></span>'
        ),
        a.put(
          "ui-grid/importerMenuItem",
          '<li class="ui-grid-menu-item"><form><input class="ui-grid-importer-file-chooser" type="file" id="files" name="files[]"></form></li>'
        ),
        a.put(
          "ui-grid/importerMenuItemContainer",
          "<div ui-grid-importer-menu-item></div>"
        ),
        a.put(
          "ui-grid/pagination",
          '<div role="contentinfo" class="ui-grid-pager-panel" ui-grid-pager ng-show="grid.options.enablePaginationControls"><div role="navigation" class="ui-grid-pager-container"><div role="menubar" class="ui-grid-pager-control"><button type="button" role="menuitem" class="ui-grid-pager-first" ui-grid-one-bind-title="aria.pageToFirst" ui-grid-one-bind-aria-label="aria.pageToFirst" ng-click="pageFirstPageClick()" ng-disabled="cantPageBackward()"><div ng-class="grid.isRTL() ? \'last-triangle\' : \'first-triangle\'"><div ng-class="grid.isRTL() ? \'last-bar-rtl\' : \'first-bar\'"></div></div></button> <button type="button" role="menuitem" class="ui-grid-pager-previous" ui-grid-one-bind-title="aria.pageBack" ui-grid-one-bind-aria-label="aria.pageBack" ng-click="pagePreviousPageClick()" ng-disabled="cantPageBackward()"><div ng-class="grid.isRTL() ? \'last-triangle prev-triangle\' : \'first-triangle prev-triangle\'"></div></button> <input type="number" ui-grid-one-bind-title="aria.pageSelected" ui-grid-one-bind-aria-label="aria.pageSelected" class="ui-grid-pager-control-input" ng-model="grid.options.paginationCurrentPage" min="1" max="{{ paginationApi.getTotalPages() }}" required> <span class="ui-grid-pager-max-pages-number" ng-show="paginationApi.getTotalPages() > 0"><abbr ui-grid-one-bind-title="paginationOf">/</abbr> {{ paginationApi.getTotalPages() }}</span> <button type="button" role="menuitem" class="ui-grid-pager-next" ui-grid-one-bind-title="aria.pageForward" ui-grid-one-bind-aria-label="aria.pageForward" ng-click="pageNextPageClick()" ng-disabled="cantPageForward()"><div ng-class="grid.isRTL() ? \'first-triangle next-triangle\' : \'last-triangle next-triangle\'"></div></button> <button type="button" role="menuitem" class="ui-grid-pager-last" ui-grid-one-bind-title="aria.pageToLast" ui-grid-one-bind-aria-label="aria.pageToLast" ng-click="pageLastPageClick()" ng-disabled="cantPageToLast()"><div ng-class="grid.isRTL() ? \'first-triangle\' : \'last-triangle\'"><div ng-class="grid.isRTL() ? \'first-bar-rtl\' : \'last-bar\'"></div></div></button></div><div class="ui-grid-pager-row-count-picker" ng-if="grid.options.paginationPageSizes.length > 1 && !grid.options.useCustomPagination"><select ui-grid-one-bind-aria-labelledby-grid="\'items-per-page-label\'" ng-model="grid.options.paginationPageSize" ng-options="o as o for o in grid.options.paginationPageSizes"></select><span ui-grid-one-bind-id-grid="\'items-per-page-label\'" class="ui-grid-pager-row-count-label">&nbsp;{{sizesLabel}}</span></div><span ng-if="grid.options.paginationPageSizes.length <= 1" class="ui-grid-pager-row-count-label">{{grid.options.paginationPageSize}}&nbsp;{{sizesLabel}}</span></div><div class="ui-grid-pager-count-container"><div class="ui-grid-pager-count"><span ng-show="grid.options.totalItems > 0">{{ 1 + paginationApi.getFirstRowIndex() }} <abbr ui-grid-one-bind-title="paginationThrough">-</abbr> {{ 1 + paginationApi.getLastRowIndex() }} {{paginationOf}} {{grid.options.totalItems}} {{totalItemsLabel}}</span></div></div></div>'
        ),
        a.put(
          "ui-grid/columnResizer",
          '<div ui-grid-column-resizer ng-if="grid.options.enableColumnResizing" class="ui-grid-column-resizer" col="col" position="right" render-index="renderIndex" unselectable="on"></div>'
        ),
        a.put(
          "ui-grid/gridFooterSelectedItems",
          '<span ng-if="grid.selection.selectedCount !== 0 && grid.options.enableFooterTotalSelected">({{"search.selectedItems" | t}} {{grid.selection.selectedCount}})</span>'
        ),
        a.put(
          "ui-grid/selectionHeaderCell",
          '<div><!-- <div class="ui-grid-vertical-bar">&nbsp;</div> --><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-selection-select-all-buttons ng-if="grid.options.enableSelectAll"></ui-grid-selection-select-all-buttons></div></div>'
        ),
        a.put(
          "ui-grid/selectionRowHeader",
          '<div class="ui-grid-disable-selection"><div class="ui-grid-cell-contents"><ui-grid-selection-row-header-buttons></ui-grid-selection-row-header-buttons></div></div>'
        ),
        a.put(
          "ui-grid/selectionRowHeaderButtons",
          '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-row-selected\': row.isSelected}" ng-click="selectButtonClick(row, $event)">&nbsp;</div>'
        ),
        a.put(
          "ui-grid/selectionSelectAllButtons",
          '<div class="ui-grid-selection-row-header-buttons ui-grid-icon-ok" ng-class="{\'ui-grid-all-selected\': grid.selection.selectAll}" ng-click="headerButtonClick($event)"></div>'
        ),
        a.put(
          "ui-grid/treeBaseExpandAllButtons",
          '<div class="ui-grid-tree-base-row-header-buttons" ng-class="{\'ui-grid-icon-minus-squared\': grid.treeBase.numberLevels > 0 && grid.treeBase.expandAll, \'ui-grid-icon-plus-squared\': grid.treeBase.numberLevels > 0 && !grid.treeBase.expandAll}" ng-click="headerButtonClick($event)"></div>'
        ),
        a.put(
          "ui-grid/treeBaseHeaderCell",
          '<div><div class="ui-grid-cell-contents" col-index="renderIndex"><ui-grid-tree-base-expand-all-buttons ng-if="grid.options.enableExpandAll"></ui-grid-tree-base-expand-all-buttons></div></div>'
        ),
        a.put(
          "ui-grid/treeBaseRowHeader",
          '<div class="ui-grid-cell-contents"><ui-grid-tree-base-row-header-buttons></ui-grid-tree-base-row-header-buttons></div>'
        ),
        a.put(
          "ui-grid/treeBaseRowHeaderButtons",
          "<div class=\"ui-grid-tree-base-row-header-buttons\" ng-class=\"{'ui-grid-tree-base-header': row.treeLevel > -1 }\" ng-click=\"treeButtonClick(row, $event)\"><i ng-class=\"{'ui-grid-icon-minus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'expanded', 'ui-grid-icon-plus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'collapsed'}\" ng-style=\"{'padding-left': grid.options.treeIndent * row.treeLevel + 'px'}\"></i> &nbsp;</div>"
        ),
        a.put(
          "ui-grid/cellTitleValidator",
          '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" title="{{grid.validate.getTitleFormattedErrors(row.entity,col.colDef)}}">{{COL_FIELD CUSTOM_FILTERS}}</div>'
        ),
        a.put(
          "ui-grid/cellTooltipValidator",
          '<div class="ui-grid-cell-contents" ng-class="{invalid:grid.validate.isInvalid(row.entity,col.colDef)}" tooltip-html-unsafe="{{grid.validate.getFormattedErrors(row.entity,col.colDef)}}" tooltip-enable="grid.validate.isInvalid(row.entity,col.colDef)" tooltip-append-to-body="true" tooltip-placement="top" title="TOOLTIP">{{COL_FIELD CUSTOM_FILTERS}}</div>'
        );
    },
  ]);
